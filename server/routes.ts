import type { Express, Response, Request } from "express";
import express from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import bcrypt from "bcrypt";
import { Vonage } from '@vonage/server-sdk';
import { WhatsAppText } from '@vonage/messages';
import { sendVerificationCode as sendWhatsAppOTP, isWhatsAppConfigured } from './whatsapp-service.js';
import nodemailer from 'nodemailer';
import multer from "multer";
import { v4 as uuidv4 } from "uuid";
import { upload, getFileType, getMimeTypeFromFileType, validateFile, type FileMetadata, FILE_CONFIGS } from "./upload.js";
import { z } from "zod";
import { cloudinaryStorage } from "./cloudinary-storage.js";

// Helper function to get file extension
const getFileExtension = (fileName: string): string => {
  const ext = fileName.split('.').pop()?.toLowerCase();
  return ext || 'txt';
};
import { db } from "./db.js";
import { requireAuth, requireAdmin, requireAdminOrModerator, requireSupportStaff, optionalAuth, type AuthenticatedRequest } from "./middleware/auth.js";
import { validateApiKey } from "./middleware/api-key.js";
import { storage } from "./storage.js";
import { countryCodes } from '../shared/countryCodes.js';
import { createPaypalOrder, capturePaypalOrder, loadPaypalDefault } from "./paypal.js";
import { getStripeInstance, getStripePublishableKey, invalidatePaymentGatewayCache } from "./utils/payment-gateways.js";
import { seedAPIKeys } from "./seed-api-keys.js";
import dodopayRoutes from "./dodopay-routes.js";
import vodapayRoutes from "./vodapay-routes.js";
import { clearSettingsCache } from "./utils/settings.js";
import { generateCertificateWithCertifier, generateVerificationCode } from "./utils/certifier-certificate-generator.js";
import { 
  users, 
  profiles, 
  userRoles,
  verificationCodes,
  passwordResetTokens,
  countries,
  gradeSystems,
  userLoginSessions,
  userPrivacySettings,
  userNotificationPreferences,
  userOtherSettings,
  systemSettings,
  paymentGateways,
  paymentMethods,
  notifications,
  teacherApplications,
  studentProgress,
  lessonProgress,
  tasks,
  courses,
  courseCategories,
  modules,
  lessons,
  lessonMedia,
  lessonContentBlocks,
  quizzes,
  certificates,
  topics,
  teacherAvailability,
  appointments,
  scheduleTemplates,
  courseEnrollments,
  coursePurchases,
  studyNotes,
  messages,
  chatThreads,
  chatParticipants,
  supportAgents,
  supportChatSessions,
  helpChatMessages,
  helpChatSettings,
  quickResponses,
  insertChatThreadSchema,
  insertChatParticipantSchema,
  insertMessageSchema,
  insertSupportAgentSchema,
  insertHelpChatSettingSchema,
  insertQuickResponseSchema,
  insertSupportChatSessionSchema,
  insertCourseSchema,
  insertModuleSchema,
  insertLessonSchema,
  insertLessonMediaSchema,
  insertQuizSchema,
  friendships,
  groupMemberships,
  premiumMessages,
  communityGroups,
  communityGroupMembers,
  communityPosts,
  communityReplies,
  communityReactions,
  pricingPlans,
  userSubscriptions,
  payments,
  curricula,
  countryCurricula,
  teacherStudentAssignments,
  announcements,
  announcementReads,
  moderationLogs,
  blogPosts,
  subjects,
  subjectChapters,
  subjectLessons,
  subjectExercises,
  subjectProgress,
  dailyQuestions,
  dailyQuestionProgress,
  dailyProgressSummary,
  transactions,
  payoutAccounts,
  userBalances,
  banks,
  insertPayoutAccountSchema,
  insertTransactionSchema,
  insertPricingPlanSchema,
  assignments,
  assignmentSubmissions,
  assignmentComments,
  courseReviews,
  projects,
  projectMilestones,
  downloads,
  insertProjectSchema,
  insertProjectMilestoneSchema,
  shopCategories,
  insertShopCategorySchema,
  categoryFilters,
  categoryFilterOptions,
  insertCategoryFilterSchema,
  insertCategoryFilterOptionSchema,
  categoryAccessApprovals,
  orders,
  orderItems,
  products,
  heroSections,
  insertHeroSectionSchema,
  insertProfileSchema,
  works,
  workMedia,
  shopCustomers,
  shopPurchases,
  shopAds,
  shopMemberships,
  shopTransactions,
  shopSupportTickets,
  shopMembershipPlans,
  manualPlanAssignments,
  insertShopMembershipPlanSchema,
  freelancerPricingPlans,
  insertFreelancerPricingPlanSchema,
  adsBanners,
  workLikes,
  workComments,
  courseComments,
  courseCommentReplies,
  courseCommentLikes,
  courseCommentReplyLikes,
  coupons,
  couponUsages,
  workViews,
  giftVoucherPurchases,
  shopVouchers
} from "../shared/schema.ts";
import { eq, desc, and, or, sql, count, avg, sum, gt, lt, like, ilike, inArray, asc, isNull, isNotNull, ne, gte, lte } from "drizzle-orm";
import { alias } from "drizzle-orm/pg-core";
import Stripe from "stripe";
import { seedCountries } from "./seed-countries.js";
import { seedGradeSystems } from "./seed-grade-systems.js";
import { seedCurricula } from "./seed-curricula.js";
import { seedMembershipPlans } from "./seed-membership-plans.js";
import { seedEnglishGrade3Zimbabwe } from "./seed-english-grade3-zimbabwe.js";
import { seedMathematicsGrade3Zimbabwe } from "./seed-mathematics-grade3-zimbabwe.js";
import { seedAIMLCourse } from "./seed-ai-ml-course.js";
import { seedEmailAccounts } from "./seed-email-accounts.js";
import { WORLD_COUNTRIES } from "./world-countries-data.js";
import communityRouter from "./community-routes.js";
import certificatePaymentRoutes from "./certificate-payment-routes.js";
import * as adsRoutes from "./routes/ads.js";
import * as bannerPaymentRoutes from "./routes/banner-payment.js";
import * as heroSectionRoutes from "./routes/hero-sections.ts";
import * as freelancerProjectRoutes from "./routes/freelancer-projects.js";
import { requireFreelancerRole } from "./routes/freelancer-projects.js";
import showcaseRoutes from "./routes/showcase.js";
import productsRoutes from "./routes/products.js";
import ordersRoutes from "./routes/orders.js";
import cartRoutes from "./routes/cart.js";
import storageStatusRoutes from "./routes/storage-status.js";
import portfolioRoutes from "./routes/portfolio.js";
import adminCouponsRoutes from "./routes/admin-coupons.js";
import manualPlanAssignmentRoutes from "./routes/manual-plan-assignment.js";
import certificateRoutes from "./routes/certificate-routes.js";
import adminCourseRoutes from "./routes/admin-course-routes.js";
import profileBoostRoutes from "./routes/profile-boost.js";
import workBoostRoutes from "./routes/work-boost.js";
import contactSubmissionsRoutes from "./routes/contact-submissions";
import creatorPayoutsRouter from "./routes/creator-payouts.js";
import adminTransactionsRoutes from "./routes/admin-transactions.js";
import { registerFinancialStatsRoutes } from "./routes/financial-stats.js";
import { trackProductDownload } from "./services/earnings.js";
// @ts-ignore - PayPal SDK types
import paypal from "@paypal/payouts-sdk";

// PayPal Configuration with proper types
const paypalClient = (): any => {
  const environment = process.env.PAYPAL_ENVIRONMENT === 'production' 
    ? new (paypal as any).core.LiveEnvironment(
        process.env.PAYPAL_CLIENT_ID!, 
        process.env.PAYPAL_CLIENT_SECRET!
      )
    : new (paypal as any).core.SandboxEnvironment(
        process.env.PAYPAL_CLIENT_ID || 'test_client_id', 
        process.env.PAYPAL_CLIENT_SECRET || 'test_client_secret'
      );

  return new (paypal as any).core.PayPalHttpClient(environment);
};

// File upload configuration is imported from upload.ts

// WebSocket clients management
const wsClients = new Map<string, WebSocket>();
const adminClients = new Set<WebSocket>();

// Rate limiting for community features
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

const createRateLimit = (windowMs: number, maxRequests: number) => {
  return (req: Request, res: Response, next: express.NextFunction) => {
    const key = `${req.ip || 'unknown'}_${req.headers['x-session-id'] || 'no-session'}`;
    const now = Date.now();
    
    // Clean up expired entries
    for (const [k, v] of rateLimitStore.entries()) {
      if (now > v.resetTime) {
        rateLimitStore.delete(k);
      }
    }
    
    let bucket = rateLimitStore.get(key);
    if (!bucket || now > bucket.resetTime) {
      bucket = { count: 0, resetTime: now + windowMs };
      rateLimitStore.set(key, bucket);
    }
    
    if (bucket.count >= maxRequests) {
      const remainingTime = Math.ceil((bucket.resetTime - now) / 1000);
      return res.status(429).json({
        success: false,
        error: 'Rate limit exceeded',
        retryAfter: remainingTime
      });
    }
    
    bucket.count++;
    next();
  };
};

// Helper function to map country names to codes
function getCountryCodeFromName(countryName: string): string {
  const country = countryCodes.find(c => c.name === countryName);
  return country ? country.code : 'US';
}

// Helper function to convert userId to UUID (handles both text ID and UUID formats)
async function getUserUuidByTextId(userIdOrUuid: string): Promise<string | null> {
  try {
    // Check if it's already a UUID format
    if (userIdOrUuid && userIdOrUuid.length === 36 && userIdOrUuid.includes('-')) {
      // It's already a UUID, return as-is
      return userIdOrUuid;
    }
    
    // It's a text ID, convert to UUID
    const user = await db
      .select({ id: users.id })
      .from(users)
      .where(eq(users.userId, userIdOrUuid))
      .limit(1);
    
    return user.length > 0 ? user[0].id : null;
  } catch (error) {
    console.error('Error converting userId to UUID:', error);
    return null;
  }
}

// Helper function to get text ID by profile UUID
async function getTextIdByProfileUuid(profileUuid: string): Promise<string | null> {
  try {
    // Get the user ID (UUID) from the profile
    const profile = await db
      .select({ userId: profiles.userId })
      .from(profiles)
      .where(eq(profiles.id, profileUuid))
      .limit(1);
    
    if (profile.length === 0) return null;
    
    // Get the text ID from users table
    const user = await db
      .select({ userId: users.userId })
      .from(users)
      .where(eq(users.id, profile[0].userId))
      .limit(1);
      
    return user.length > 0 ? user[0].userId : null;
  } catch (error) {
    console.error('Error getting text ID by profile UUID:', error);
    return null;
  }
}

// Helper function to check if user has active subscription
async function hasActiveSubscription(userIdOrUuid: string): Promise<{ hasAccess: boolean; subscriptionTier?: string; planExpiry?: Date; plan?: string }> {
  try {
    // Convert text ID to UUID if needed
    const userUuid = await getUserUuidByTextId(userIdOrUuid);
    if (!userUuid) {
      return { hasAccess: false };
    }

    const profile = await db
      .select({
        subscriptionTier: profiles.subscriptionTier,
        legacyPlan: profiles.legacyPlan,
        planExpiry: profiles.planExpiry,
        gradeLevel: profiles.gradeLevel,
        stripeSubscriptionId: profiles.stripeSubscriptionId
      })
      .from(profiles)
      .where(eq(profiles.userId, userUuid))
      .limit(1);

    if (profile.length === 0) {
      return { hasAccess: false };
    }

    const userProfile = profile[0];
    
    // New grade-based subscription system with proper expiry validation
    if (userProfile.subscriptionTier) {
      // CRITICAL: Must check planExpiry for grade-based subscriptions
      if (userProfile.planExpiry) {
        const expiry = new Date(userProfile.planExpiry);
        const now = new Date();
        
        if (expiry <= now) {
          // Subscription expired - no access
          return { 
            hasAccess: false, 
            subscriptionTier: userProfile.subscriptionTier,
            planExpiry: userProfile.planExpiry,
            plan: userProfile.subscriptionTier 
          };
        }
        
        // Valid subscription with future expiry
        return { 
          hasAccess: true, 
          subscriptionTier: userProfile.subscriptionTier,
          planExpiry: userProfile.planExpiry,
          plan: userProfile.subscriptionTier 
        };
      } else {
        // No expiry set means subscription was never properly activated
        return { 
          hasAccess: false, 
          subscriptionTier: userProfile.subscriptionTier,
          planExpiry: undefined,
          plan: userProfile.subscriptionTier 
        };
      }
    }
    
    // Legacy support: Check old plan system for backward compatibility
    if (userProfile.legacyPlan && userProfile.legacyPlan !== 'free' && userProfile.legacyPlan !== '') {
      // Check for indefinite access: if user has a premium plan but planExpiry is null, grant access
      if (!userProfile.planExpiry) {
        const hasPremiumPlan = userProfile.legacyPlan.includes('premium') || userProfile.legacyPlan.includes('pro');
        
        if (hasPremiumPlan) {
          return { 
            hasAccess: true, 
            subscriptionTier: userProfile.subscriptionTier || 'legacy_premium',
            planExpiry: undefined,
            plan: userProfile.legacyPlan 
          };
        }
        
        // For non-premium plans with null expiry, deny access
        return { 
          hasAccess: false, 
          subscriptionTier: userProfile.subscriptionTier || 'free',
          planExpiry: userProfile.planExpiry || undefined,
          plan: userProfile.legacyPlan 
        };
      }

      // Check if legacy subscription has expired
      if (userProfile.planExpiry && new Date() > userProfile.planExpiry) {
        return { 
          hasAccess: false, 
          subscriptionTier: userProfile.subscriptionTier || 'free',
          planExpiry: userProfile.planExpiry || undefined,
          plan: userProfile.legacyPlan 
        };
      }

      // User has active legacy subscription
      return { 
        hasAccess: true, 
        subscriptionTier: userProfile.subscriptionTier || 'legacy_premium',
        planExpiry: userProfile.planExpiry || undefined,
        plan: userProfile.legacyPlan 
      };
    }

    // No subscription found
    return { 
      hasAccess: false, 
      subscriptionTier: 'free',
      planExpiry: undefined,
      plan: 'free' 
    };

  } catch (error) {
    console.error('Error checking subscription status:', error);
    return { hasAccess: false };
  }
}

// Note: Stripe is now initialized dynamically from admin settings
// Use getStripeInstance() from payment-gateways.ts instead of this global instance

// Initialize Vonage (SMS & WhatsApp)

const vonage = new Vonage({
  apiKey: process.env.VONAGE_API_KEY?.trim() || '',
  apiSecret: process.env.VONAGE_API_SECRET?.trim() || ''
});

// Create email transporter for EduFiliova professional email system
const createEmailTransporter = (senderEmail: string) => {
  // Use EduFiliova domain SMTP through Spacemail
  return nodemailer.createTransport({
    host: 'mail.spacemail.com',
    port: 465,
    secure: true, // Use SSL for port 465
    auth: {
      user: senderEmail,
      pass: process.env.SMTP_PASSWORD || '' // Use environment variable for security
    },
    tls: {
      rejectUnauthorized: false // Allow self-signed certificates if needed
    }
  });
};

// Email templates with modern branding
export const getEmailTemplate = (type: 'verification' | 'welcome' | 'password_reset' | 'teacher-verification', data: any) => {
  const whiteLogoUrl = process.env.EDUFILIOVA_WHITE_LOGO_URL || 'https://res.cloudinary.com/dl2lomrhp/image/upload/v1763935567/edufiliova/edufiliova-white-logo.png';
  const baseUrl = process.env.REPLIT_DEV_DOMAIN 
    ? `https://${process.env.REPLIT_DEV_DOMAIN}`
    : 'https://edufiliova.com';
  const currentYear = new Date().getFullYear();
  
  const baseStyle = `
    <style>
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
        margin: 0; 
        padding: 0; 
        background-color: #f5f7fa; 
      }
      .container { 
        max-width: 600px; 
        margin: 0 auto; 
        background-color: #ffffff; 
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); 
      }
      .header { 
        background-color: #ff5834; 
        padding: 30px 40px; 
        text-align: center; 
      }
      .logo { 
        max-width: 200px; 
        height: auto; 
      }
      .content { 
        padding: 40px; 
      }
      .title { 
        color: #1a1a1a; 
        font-size: 26px; 
        font-weight: 700; 
        margin: 0 0 20px 0; 
        line-height: 1.3; 
      }
      .message { 
        color: #4a5568; 
        font-size: 16px; 
        line-height: 1.6; 
        margin: 0 0 25px 0; 
      }
      .verification-code-box {
        background: linear-gradient(135deg, #2d5ddd 0%, #1e4ac9 100%);
        border-radius: 12px;
        padding: 30px;
        text-align: center;
        margin: 30px 0;
      }
      .verification-code {
        font-size: 42px;
        font-weight: 800;
        color: #ffffff;
        letter-spacing: 10px;
        font-family: 'Courier New', monospace;
        margin: 10px 0;
      }
      .code-label {
        color: rgba(255, 255, 255, 0.9);
        font-size: 13px;
        font-weight: 600;
        letter-spacing: 2px;
        text-transform: uppercase;
      }
      .button { 
        display: inline-block; 
        background-color: #ff5834; 
        color: #ffffff !important; 
        padding: 14px 32px; 
        text-decoration: none; 
        border-radius: 8px; 
        font-weight: 600; 
        font-size: 15px; 
        margin: 20px 0; 
      }
      .alert-warning { 
        background-color: #fff4ed; 
        border-left: 4px solid #ff5834; 
        padding: 15px 20px; 
        border-radius: 6px; 
        margin: 20px 0; 
      }
      .footer { 
        background: #ff5834; 
        padding: 40px; 
        color: #ffffff; 
      }
      .footer-contact { 
        text-align: center; 
        margin: 25px 0; 
      }
      .footer-links { 
        text-align: center; 
        margin: 25px 0; 
        padding-top: 25px; 
        border-top: 1px solid rgba(255,255,255,0.2); 
      }
      .footer-link { 
        color: #ffffff !important; 
        text-decoration: none; 
        font-size: 13px; 
        margin: 0 12px; 
        font-weight: 500; 
      }
      .footer-bottom { 
        text-align: center; 
        padding-top: 20px; 
        margin-top: 20px; 
        border-top: 1px solid rgba(255,255,255,0.2); 
        color: rgba(255,255,255,0.7); 
        font-size: 12px; 
        line-height: 1.6; 
      }
    </style>
  `;

  const footer = `
    <div class="footer">
      <div class="footer-contact">
        <p style="color: #ffffff; font-size: 16px; margin: 0 0 20px 0; text-align: center;">
          You need help? Contact us on <a href="mailto:support@edufiliova.com" style="color: #ffffff; text-decoration: underline;">support@edufiliova.com</a>
        </p>
      </div>
      
      <div class="footer-links">
        <a href="${baseUrl}/?page=help-center" class="footer-link" style="color: #ffffff;">Help Center</a>
        <a href="${baseUrl}/?page=privacy-policy" class="footer-link" style="color: #ffffff;">Privacy Policy</a>
        <a href="${baseUrl}/?page=terms" class="footer-link" style="color: #ffffff;">Terms of Service</a>
        <a href="${baseUrl}/?page=refund-policy" class="footer-link" style="color: #ffffff;">Refund Policy</a>
        <a href="${baseUrl}/?page=contact" class="footer-link" style="color: #ffffff;">Contact Us</a>
      </div>
      
      <div class="footer-bottom">
        Â© ${currentYear} EduFiliova. All rights reserved.<br>
        Creativity, Learning, and Growth in One Place
      </div>
    </div>
  `;

  switch (type) {
    case 'verification':
      return `
        <!DOCTYPE html>
        <html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">${baseStyle}</head><body>
          <div class="container">
            <div class="header">
              <img src="${whiteLogoUrl}" alt="EduFiliova" class="logo" />
            </div>
            <div class="content">
              <h2 class="title">Verify Your Account</h2>
              <p class="message">
                ${data.name ? `Hi ${data.name},<br><br>` : ''}Welcome to EduFiliova! Please use the verification code below to complete your registration:
              </p>
              
              <div class="verification-code-box">
                <div class="code-label">YOUR VERIFICATION CODE</div>
                <div class="verification-code">${data.code}</div>
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px; margin-top: 10px;">
                  Code expires in 15 minutes
                </div>
              </div>
              
              <p class="message">
                Please enter this code on the verification page to complete your signup and create your account.
              </p>

              <div class="alert-warning">
                <div style="color: #92400e; font-size: 13px;">
                  <strong>Didn't request this?</strong> If you didn't try to sign up for EduFiliova, you can safely ignore this email.
                </div>
              </div>
              
              <p class="message" style="font-size: 14px;">
                Need help? Contact our support team at support@edufiliova.com
              </p>
            </div>
            ${footer}
          </div>
        </body></html>
      `;

    case 'welcome':
      return `
        <!DOCTYPE html>
        <html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">${baseStyle}</head><body>
          <div class="container">
            <div class="header">
              <img src="${whiteLogoUrl}" alt="EduFiliova" class="logo" />
            </div>
            <div class="content">
              <h2 class="title">Welcome to EduFiliova!</h2>
              <p class="message">
                Congratulations, <strong>${data.name}</strong>! Your account has been successfully verified and you're now part of our global learning community.
              </p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${data.loginUrl}" class="button">Start Learning</a>
              </div>
              
              <div style="background-color: #f9fafb; border-radius: 10px; padding: 25px; margin: 25px 0;">
                <h3 style="color: #1f2937; margin: 0 0 15px 0;">What's Next?</h3>
                <ul style="color: #4b5563; line-height: 2; margin: 0; padding-left: 20px;">
                  <li>Explore personalized learning content</li>
                  <li>Access premium educational resources</li>
                  <li>Connect with teachers and tutors</li>
                  <li>Track your learning progress</li>
                </ul>
              </div>
              
              <p class="message" style="font-size: 14px;">
                Need help getting started? Contact our support team at support@edufiliova.com
              </p>
            </div>
            ${footer}
          </div>
        </body></html>
      `;

    case 'password_reset':
      return `
        <!DOCTYPE html>
        <html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">${baseStyle}</head><body>
          <div class="container">
            <div class="header">
              <img src="${whiteLogoUrl}" alt="EduFiliova" class="logo" />
            </div>
            <div class="content">
              <h2 class="title">Reset Your Password</h2>
              <p class="message">
                We received a request to reset your password. Click the button below to create a new password:
              </p>
              
              <div style="text-align: center; margin: 30px 0;">
                <a href="${data.resetUrl}" class="button">Reset Password</a>
              </div>
              
              <div class="alert-warning">
                <div style="color: #92400e; font-size: 13px;">
                  <strong>Security Notice:</strong> This link expires in 1 hour. If you didn't request this reset, please ignore this email.
                </div>
              </div>
              
              <p class="message" style="font-size: 14px;">
                For security, this link can only be used once.
              </p>
            </div>
            ${footer}
          </div>
        </body></html>
      `;

    case 'teacher-verification':
      return `
        <!DOCTYPE html>
        <html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">${baseStyle}</head><body>
          <div class="container">
            <div class="header">
              <img src="${whiteLogoUrl}" alt="EduFiliova" class="logo" />
            </div>
            <div class="content">
              <h2 class="title">Verify Your Teacher Application</h2>
              <p class="message">
                Hi ${data.fullName},<br><br>
                Thank you for applying to teach with EduFiliova! Please use the verification code below to complete your application:
              </p>
              
              <div class="verification-code-box">
                <div class="code-label">YOUR VERIFICATION CODE</div>
                <div class="verification-code">${data.code}</div>
                <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px; margin-top: 10px;">
                  Code expires in 24 hours
                </div>
              </div>
              
              <p class="message">
                Please enter this code on the verification page to continue with your teacher application.
              </p>

              <div class="alert-warning">
                <div style="color: #92400e; font-size: 13px;">
                  <strong>Didn't request this?</strong> If you didn't apply to become a teacher, you can safely ignore this email.
                </div>
              </div>
              
              <p class="message" style="font-size: 14px; margin-top: 24px;">
                Once verified, your application will be reviewed by our team and you'll receive an update within 24-48 hours.
              </p>
            </div>
            ${footer}
          </div>
        </body></html>
      `;

    default:
      return '<p>Invalid email template</p>';
  }
};

// Utility functions
// Utility functions
const generateVerificationCode = () => {
  return Math.floor(100000 + Math.random() * 900000).toString();
};

const generateUserId = () => {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 10; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
};

const sendSMS = async (phoneNumber: string, message: string) => {
  try {
    if (!process.env.VONAGE_API_KEY || !process.env.VONAGE_API_SECRET) {
      console.log('âš ï¸ Vonage credentials not configured, skipping SMS');
      return { success: false, error: 'SMS service not configured' };
    }

    const from = "EduFiliova";
    const to = phoneNumber.startsWith('+') ? phoneNumber : `+${phoneNumber}`;
    
    const response = await vonage.sms.send({ to, from, text: message });
    console.log('âœ… SMS sent successfully:', response);
    return { success: true, messageId: response.messages[0]?.['message-id'] };
  } catch (error) {
    console.error('âŒ SMS sending failed:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
};

export const sendEmail = async (to: string, subject: string, html: string, fromAddress = 'verify@edufiliova.com') => {
  try {
    // Extract verification code from HTML for console logging
    const codeMatch = html.match(/<div class="code">(\d+)<\/div>/);
    const verificationCode = codeMatch ? codeMatch[1] : 'Unknown';
    
    // Store verification code (for development - remove in production)
    console.log('ðŸ“§ Subject:', subject);
    
    // Try to send email, but don't fail if SMTP fails
    try {
      const transporter = createEmailTransporter(fromAddress);
      
      const mailOptions = {
        from: `"EduFiliova" <${fromAddress}>`,
        to,
        subject,
        html,
      };

      const info = await transporter.sendMail(mailOptions);
      // Email sent successfully
      return { success: true, messageId: info.messageId };
    } catch (smtpError) {
      // Email sending failed - log error and return failure
      console.error('âŒ Email sending failed:', smtpError);
      return { success: false, error: 'Failed to send email' };
    }
  } catch (error) {
    console.error('âŒ Email processing failed:', error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
};

const isValidEmail = (email: string) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

const isValidPhone = (phone: string) => {
  const phoneRegex = /^\+?[1-9]\d{1,14}$/;
  return phoneRegex.test(phone.replace(/[\s\-\(\)]/g, ''));
};

// Broadcasting functions for real-time updates
const broadcastToAdmins = (message: any) => {
  adminClients.forEach(ws => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(message));
    }
  });
};

const broadcastToUser = (userId: string, message: any) => {
  const userWs = wsClients.get(userId);
  if (userWs && userWs.readyState === WebSocket.OPEN) {
    userWs.send(JSON.stringify(message));
  }
};

// Helper function to generate 14-character alphanumeric voucher code
function generateVoucherCode(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for (let i = 0; i < 14; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

export async function registerRoutes(app: Express): Promise<Server> {
  const server = createServer(app);

  // Run all seeding operations in parallel and await completion before serving requests
  // This ensures data integrity while still benefiting from parallel execution
  const results = await Promise.allSettled([
    seedCountries(),
    seedGradeSystems(),
    seedCurricula(),
    seedMembershipPlans(),
    seedAPIKeys(),
    seedEnglishGrade3Zimbabwe(),
    seedMathematicsGrade3Zimbabwe(),
    seedEmailAccounts(),
    seedAIMLCourse(),
  ]);
  
  results.forEach((result, index) => {
    const operations = ['countries', 'grade systems', 'curricula', 'membership plans', 'API keys', 'English Grade 3', 'Mathematics Grade 3', 'AI/ML Course'];
    if (result.status === 'rejected') {
      console.error(`âŒ Failed to seed ${operations[index]}:`, result.reason);
    }
  });

  // Clean up expired verification codes periodically
  const cleanupExpiredCodes = async () => {
    try {
      const now = new Date();
      const deleted = await db.delete(verificationCodes).where(
        or(
          lt(verificationCodes.expiresAt, now),
          eq(verificationCodes.isUsed, true)
        )
      );
      console.log('ðŸ§¹ Cleaned up expired verification codes');
    } catch (error) {
      console.error('âŒ Failed to cleanup verification codes:', error);
    }
  };

  // Run cleanup every 30 minutes
  setInterval(cleanupExpiredCodes, 30 * 60 * 1000);
  
  // Run initial cleanup
  cleanupExpiredCodes();

  // Mount community routes
  app.use('/api/community', communityRouter);
  // Mount certificate payment routes
  app.use(certificatePaymentRoutes);

  // Mount showcase portfolio routes
  app.use('/api/showcase', showcaseRoutes);
  
  // Mount portfolio routes (Behance-like works system)
  app.use('/api/portfolio', portfolioRoutes);

  // Mount products shop routes
  app.use('/api/products', productsRoutes);

  // Mount cart management routes
  app.use('/api/cart', cartRoutes);

  // Mount orders management routes  
  app.use('/api/orders', ordersRoutes);

  // Mount admin coupon management routes
  app.use('/api/certificates', certificateRoutes);
  app.use('/api/admin/courses', requireAuth, requireAdmin, adminCourseRoutes);
  app.use('/api/admin/coupons', adminCouponsRoutes);
  app.use('/api/admin/manual-plan-assignments', requireAuth, manualPlanAssignmentRoutes);
  app.use('/api', contactSubmissionsRoutes);
  app.use('/api/admin/profile-boost', requireAuth, requireAdmin, profileBoostRoutes);
  // Mount creator payouts routes
  app.use('/api/creator-payouts', creatorPayoutsRouter);
  registerFinancialStatsRoutes(app);
  app.use('/api', adminTransactionsRoutes);
  app.use('/api/admin/storage', storageStatusRoutes);
  app.use('/api/admin/work-boost', requireAuth, requireAdmin, workBoostRoutes);

  // PayPal routes - Referenced from PayPal integration blueprint
  app.get("/api/paypal/setup", async (req, res) => {
    await loadPaypalDefault(req, res);
  });

  app.post("/api/paypal/order", async (req, res) => {
    // Request body should contain: { intent, amount, currency }
    await createPaypalOrder(req, res);
  });

  app.post("/api/paypal/order/:orderID/capture", async (req, res) => {
  
    await capturePaypalOrder(req, res);
  });

  // DoDo Pay routes
  app.use("/api/dodopay", dodopayRoutes);

  // VodaPay routes
  app.use("/api/vodapay", vodapayRoutes);

  // Advertisement routes - Full CRUD Management System
  app.get('/api/ads/manage', requireAuth, adsRoutes.getManageAds);           // Get all ads (admin) or user's own ads
  app.get('/api/ads/my-ads', requireAuth, adsRoutes.getMyAds);               // Get current user's ads
  app.post('/api/ads/create', requireAuth, adsRoutes.createAd);              // Create ad (admin only - free)
  app.put('/api/ads/:id', requireAuth, adsRoutes.updateAd);                  // Edit ad (admin or owner)
  app.delete('/api/ads/:id', requireAuth, adsRoutes.deleteAd);               // Delete ad (admin or owner)
  app.post('/api/ads/approve/:id', requireAuth, adsRoutes.approveAd);        // Approve ad (admin only)
  app.post('/api/ads/reject/:id', requireAuth, adsRoutes.rejectAd);          // Reject ad (admin only)
  app.get('/api/ads/active', adsRoutes.getActiveAds);                        // Get active ads for dashboard
  app.post('/api/ads/impression', adsRoutes.trackImpression);                // Track impressions
  app.post('/api/ads/click', adsRoutes.trackClick);                          // Track clicks
  app.get('/api/ads/pricing-config', requireAuth, adsRoutes.getPricingConfig);    // Get pricing config (admin)
  app.put('/api/ads/pricing-config/:id', requireAuth, adsRoutes.updatePricingConfig); // Update pricing (admin)
  app.delete('/api/ads/pricing-config/:id', requireAuth, adsRoutes.deletePricingConfig); // Delete pricing (admin)
  app.post('/api/ads/calculate-price', adsRoutes.calculatePrice);            // Calculate ad price

  // Banner Payment Routes
  app.post('/api/ads/banner/create-with-payment', requireAuth, bannerPaymentRoutes.createBannerWithPayment);
  app.post('/api/ads/banner/confirm-payment', requireAuth, bannerPaymentRoutes.confirmBannerPayment);
  app.post('/api/ads/banner/confirm-paypal-payment', bannerPaymentRoutes.confirmPayPalBannerPayment);
  app.get('/api/ads/banner/payment-success', bannerPaymentRoutes.handlePaymentSuccess);
  app.delete('/api/ads/banner/:bannerId', requireAuth, bannerPaymentRoutes.deleteBannerAd);
  app.put('/api/ads/banner/:bannerId', requireAuth, bannerPaymentRoutes.updateBannerAd);

  // Hero Sections Routes - Admin management and public display
  app.get('/api/hero-sections/manage', requireAuth, heroSectionRoutes.getManageHeroSections);   // Get all hero sections (admin only)
  app.get('/api/hero-sections/my-hero-sections', requireAuth, heroSectionRoutes.getMyHeroSections);  // Get current user's hero sections
  app.post('/api/hero-sections/create', requireAuth, heroSectionRoutes.createHeroSection);     // Create hero section (admin only)
  app.put('/api/hero-sections/:id', requireAuth, heroSectionRoutes.updateHeroSection);        // Update hero section
  app.delete('/api/hero-sections/:id', requireAuth, heroSectionRoutes.deleteHeroSection);     // Delete hero section
  app.put('/api/hero-sections/:id/status', requireAuth, heroSectionRoutes.updateHeroSectionStatus); // Update hero section status (admin only)
  app.get('/api/hero-sections/active', heroSectionRoutes.getActiveHeroSections);              // Get active hero sections for display
  app.post('/api/hero-sections/impression', heroSectionRoutes.trackImpression);               // Track hero section impressions
  app.post('/api/hero-sections/click', heroSectionRoutes.trackClick);                         // Track hero section clicks

  // Freelancer Projects Routes - Secured with role-based authorization
  app.get('/api/freelancer/projects/my', requireFreelancerRole, freelancerProjectRoutes.getMyProjects);         // Get freelancer's projects
  app.get('/api/freelancer/projects/:id', requireFreelancerRole, freelancerProjectRoutes.getProject);           // Get specific project details
  app.post('/api/freelancer/projects', requireFreelancerRole, freelancerProjectRoutes.createProject);           // Create new project
  app.put('/api/freelancer/projects/:id', requireFreelancerRole, freelancerProjectRoutes.updateProject);        // Update project
  app.delete('/api/freelancer/projects/:id', requireFreelancerRole, freelancerProjectRoutes.deleteProject);     // Delete project
  app.post('/api/freelancer/projects/:id/milestones', requireFreelancerRole, freelancerProjectRoutes.addMilestone); // Add milestone to project
  
  // Freelancer stats endpoint
  app.get('/api/freelancer/stats', requireAuth, requireFreelancerRole, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Calculate freelancer stats
      const userProjects = await db
        .select()
        .from(projects)
        .where(eq(projects.freelancerId, userId));

      const completedProjects = userProjects.filter(p => p.status === 'completed');
      const averageRating = completedProjects.length > 0 
        ? completedProjects.reduce((sum, p) => sum + (p.feedbackRating ?? 0), 0) / completedProjects.length 
        : 0;

      const stats = {
        averageRating: Math.round(averageRating * 10) / 10, // Round to 1 decimal
        totalReviews: completedProjects.filter(p => (p.feedbackRating ?? 0) > 0).length
      };

      res.json(stats);
    } catch (error) {
      console.error('Error fetching freelancer stats:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch stats' });
    }
  });

  // Profile Statistics Endpoints - views, likes, follows
  
  // Get all freelancers - supports filtering, sorting, and pagination
  app.get('/api/freelancers', async (req: Request, res: Response) => {
    try {
      const { sort = 'rating', page = 1, limit = 12 } = req.query;

      const freelancers = await db
        .select()
        .from(profiles)
        .where(eq(profiles.role, 'freelancer'))
        .orderBy(desc(profiles.createdAt))
        .limit(Number(limit))
        .offset((Number(page) - 1) * Number(limit));

      // Get portfolio stats for each freelancer
      const portfolioStats = await db
        .select({
          userId: works.userId,
          worksCount: count(works.id),
          totalLikes: sum(works.likesCount),
        })
        .from(works)
        .where(inArray(works.userId, freelancers.map(f => f.userId)))
        .groupBy(works.userId);

      const portfolioStatsMap = portfolioStats.reduce((acc, stat) => {
        acc[stat.userId] = {
          worksCount: Number(stat.worksCount) || 0,
          totalLikes: Number(stat.totalLikes) || 0,
        };
        return acc;
      }, {} as Record<string, { worksCount: number; totalLikes: number }>);

      const transformedFreelancers = freelancers.map(f => ({
        id: f.userId,
        name: f.name || '',
        displayName: f.displayName || f.name || '',
        avatarUrl: f.avatarUrl,
        coverImageUrl: f.coverImageUrl,
        bio: f.bio,
        title: f.professionalTitle,
        skills: f.skills || [],
        hourlyRate: f.hourlyRate ? Number(f.hourlyRate) : null,
        location: f.location,
        rating: f.averageRating ? Number(f.averageRating) : 0,
        reviewCount: f.clientReviews || 0,
        completedProjects: f.completedProjects || 0,
        isOnline: f.isOnline || false,
        profileViews: f.profileViews || 0,
        joinedAt: f.createdAt?.toISOString() || new Date().toISOString(),
        verificationBadge: f.verificationBadge,
        responseTime: f.responseTime,
        workAvailability: f.workAvailability,
        likesCount: (portfolioStatsMap[f.userId]?.totalLikes || 0) + (f.likesCount || 0),
        worksShared: portfolioStatsMap[f.userId]?.worksCount || 0,
      }));

      res.json({
        success: true,
        data: transformedFreelancers,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          hasMore: freelancers.length === Number(limit)
        }
      });
    } catch (error) {
      console.error('Error fetching freelancers:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch freelancers' });
    }
  });
  app.get('/api/freelancers/:id/stats', async (req: Request, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      const viewerUserId = (req as any).user?.id;
      
      // Look up the profile ID from the user ID
      const profile = await db.select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }
      
      const profileId = profile[0].id;
      const stats = await storage.getProfileStats(profileId, viewerUserId);
      res.json(stats);
    } catch (error) {
      console.error('Error fetching profile stats:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch profile stats' });
    }
  });

  // Get freelancer profile
  app.get('/api/freelancers/:id/profile', async (req: Request, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      
      // Fetch the complete profile data
      const profileData = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profileData.length === 0) {
        return res.status(404).json({ success: false, error: 'Freelancer profile not found' });
      }
      
      const profile = profileData[0];
      
      // Return the profile data in the format expected by the frontend
      res.json({
        success: true,
        data: {
          id: profile.id,
          userId: profile.userId,
          name: profile.name || '',
          displayName: profile.displayName || profile.name || '',
          professionalTitle: profile.professionalTitle || '',
          tagline: profile.tagline || '',
          email: profile.email || '',
          contactEmail: profile.contactEmail || profile.email || '',
          avatarUrl: profile.avatarUrl,
          coverImageUrl: profile.coverImageUrl,
          bio: profile.bio,
          professionalStatement: profile.professionalStatement,
          location: profile.location,
          country: profile.country,
          hourlyRate: profile.hourlyRate,
          experienceYears: profile.experienceYears,
          skills: profile.skills,
          languages: profile.languages,
          education: profile.education,
          certifications: profile.certifications,
          portfolioUrl: profile.portfolioUrl,
          websiteUrl: profile.websiteUrl,
          linkedinUrl: profile.linkedinUrl,
          twitterUrl: profile.twitterUrl,
          instagramUrl: profile.instagramUrl,
          behanceUrl: profile.behanceUrl,
          dribbbleUrl: profile.dribbbleUrl,
          githubUrl: profile.githubUrl,
          availability: profile.availability,
          role: profile.role,
          approvalStatus: profile.approvalStatus,
          qualifications: profile.qualifications,
          experience: profile.experience,
          availableHours: profile.availableHours,
          verificationBadge: profile.verificationBadge,
          verified: profile.verified,
          verificationBadges: profile.verificationBadges,
          profileViews: profile.profileViews,
          likesCount: profile.likesCount,
          followersCount: profile.followersCount,
          completedProjects: profile.completedProjects,
          reviewCount: profile.reviewCount || profile.clientReviews,
          rating: profile.rating || profile.averageRating,
          responseTime: profile.responseTime,
          workAvailability: profile.workAvailability,
          yearsOfExperience: profile.yearsOfExperience || profile.experienceYears,
          phoneNumber: profile.phoneNumber,
          socialLinks: profile.socialLinks,
          joinedAt: profile.createdAt
        }
      });
    } catch (error) {
      console.error('Error fetching freelancer profile:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch freelancer profile' });
    }
  });

  // Get freelancer portfolio works
  app.get('/api/freelancers/:id/portfolio', async (req: Request, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      
      // First get the profile to verify the freelancer exists
      const profileData = await db
        .select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profileData.length === 0) {
        return res.status(404).json({ success: false, error: 'Freelancer not found' });
      }
      
      // Fetch portfolio works for this freelancer
      const portfolioWorks = await db
        .select()
        .from(works)
        .where(eq(works.userId, freelancerId))
        .orderBy(desc(works.createdAt));
      
      // Fetch media for each work
      const worksWithMedia = await Promise.all(
        portfolioWorks.map(async (work) => {
          const media = await db
            .select()
            .from(workMedia)
            .where(eq(workMedia.workId, work.id))
            .orderBy(asc(workMedia.sortOrder));
          
          return {
            ...work,
            media
          };
        })
      );
      
      res.json({
        success: true,
        data: worksWithMedia
      });
    } catch (error) {
      console.error('Error fetching freelancer portfolio:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch portfolio' });
    }
  });

  app.post('/api/freelancers/:id/views', async (req: Request, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      const viewerUserId = (req as any).user?.id;
      const { visitorId, sessionId, ipHash, uaHash, referer } = req.body;
      
      // Look up the profile ID from the user ID
      const profile = await db.select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }
      
      const profileId = profile[0].id;
      
      const recorded = await storage.recordProfileView(profileId, {
        viewerUserId,
        visitorId,
        sessionId,
        ipHash,
        uaHash,
        referer
      });
      
      res.json({ success: true, recorded });
    } catch (error) {
      console.error('Error recording profile view:', error);
      res.status(500).json({ success: false, error: 'Failed to record view' });
    }
  });

  app.post('/api/freelancers/:id/likes', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ success: false, error: 'Authentication required to like profiles' });
      }
      
      // Look up the profile ID from the user ID
      const profile = await db.select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }
      
      const profileId = profile[0].id;
      const result = await storage.toggleProfileLike(profileId, userId);
      res.json({ success: true, ...result });
    } catch (error) {
      console.error('Error toggling profile like:', error);
      res.status(500).json({ success: false, error: 'Failed to toggle like' });
    }
  });

  app.post('/api/freelancers/:id/follows', requireAuth, async (req: AuthenticatedRequest, res: Response) => {
    try {
      const freelancerId = req.params.id; // This is the user ID
      const followerUserId = req.user?.id;
      
      if (!followerUserId) {
        return res.status(401).json({ success: false, error: 'Authentication required to follow profiles' });
      }
      
      // Look up the profile ID from the user ID
      const profile = await db.select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);
      
      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }
      
      const profileId = profile[0].id;
      const result = await storage.toggleProfileFollow(profileId, followerUserId);
      res.json({ success: true, isFollowing: result.following, followersCount: result.followersCount });
    } catch (error) {
      console.error('Error toggling profile follow:', error);
      res.status(500).json({ success: false, error: 'Failed to toggle follow' });
    }
  });

  // Comprehensive health check endpoint
  app.get("/api/health", async (_req, res) => {
    try {
      const startTime = Date.now();
      
      // Database connectivity check
      await db.select().from(users).limit(1);
      
      // Check if countries are properly seeded
      const countriesCount = await db.select({ count: count() }).from(countries);
      const isCountriesHealthy = countriesCount[0].count >= 190; // Should have ~199 countries
      
      // Check if grade systems are properly seeded
      const gradeSystemsCount = await db.select({ count: count() }).from(gradeSystems);
      const isGradeSystemsHealthy = gradeSystemsCount[0].count >= 2000; // Should have ~2987 grade systems
      
      // Check verification codes cleanup
      const expiredCodesCount = await db
        .select({ count: count() })
        .from(verificationCodes)
        .where(lt(verificationCodes.expiresAt, new Date()));
      
      const responseTime = Date.now() - startTime;
      
      const healthStatus = {
        status: "healthy",
        timestamp: new Date().toISOString(),
        responseTime: `${responseTime}ms`,
        database: {
          connected: true,
          countries: {
            count: countriesCount[0].count,
            healthy: isCountriesHealthy
          },
          gradeSystems: {
            count: gradeSystemsCount[0].count,
            healthy: isGradeSystemsHealthy
          },
          verificationCodes: {
            expiredCount: expiredCodesCount[0].count,
            needsCleanup: expiredCodesCount[0].count > 100
          }
        },
        services: {
          emailService: "configured",
          smsService: process.env.VONAGE_API_KEY ? "configured" : "missing",
          stripeService: process.env.STRIPE_SECRET_KEY ? "configured" : "missing"
        },
        loginSystem: {
          status: isCountriesHealthy && isGradeSystemsHealthy ? "operational" : "degraded",
          countriesAvailable: isCountriesHealthy,
          gradeSystemsAvailable: isGradeSystemsHealthy
        }
      };
      
      const statusCode = (isCountriesHealthy && isGradeSystemsHealthy) ? 200 : 206;
      res.status(statusCode).json(healthStatus);
      
    } catch (error) {
      res.status(503).json({ 
        status: "unhealthy", 
        timestamp: new Date().toISOString(),
        database: "disconnected",
        error: error instanceof Error ? error.message : 'Unknown error',
        loginSystem: {
          status: "unavailable"
        }
      });
    }
  });

  // Countries API with auto-recovery
  app.get("/api/countries", async (_req, res) => {
    try {
      const countriesData = await db.select().from(countries).orderBy(countries.name);
      
      // Auto-recovery: If countries data is missing or corrupted, re-seed
      if (countriesData.length < 190) {
        // Countries data incomplete - triggering auto-recovery
        await seedCountries();
        const reseededCountries = await db.select().from(countries).orderBy(countries.name);
        return res.json({ success: true, data: reseededCountries, recovered: true });
      }
      
      res.json({ success: true, data: countriesData });
    } catch (error) {
      console.error('Countries fetch error:', error);
      
      // Try to recover by reseeding
      try {
        // Attempting database recovery
        await seedCountries();
        const recoveredCountries = await db.select().from(countries).orderBy(countries.name);
        return res.json({ success: true, data: recoveredCountries, recovered: true });
      } catch (recoveryError) {
        // Database recovery failed
        // Fallback to static countries data when database fails
        console.log('ðŸ”„ Using fallback countries data due to database connectivity issues');
        const fallbackCountries = WORLD_COUNTRIES.map((country, index) => ({
          id: index + 1,
          code: country.code,
          name: country.name,
          gradeSystemType: country.gradeSystemType,
          createdAt: new Date()
        }));
        res.json({ success: true, data: fallbackCountries, fallback: true });
      }
    }
  });

  // Location detection API - returns user's detected location
  app.get("/api/location/detect", (req, res) => {
    try {
      const location = req.userLocation;
      
      if (!location) {
        return res.json({
          country: 'Unknown',
          city: 'Unknown',
          region: 'Unknown'
        });
      }

      res.json({
        country: location.country || 'Unknown',
        city: location.city || 'Unknown',
        region: location.region || 'Unknown',
        timezone: location.timezone,
        latitude: location.latitude,
        longitude: location.longitude
      });
    } catch (error) {
      console.error('Location detection error:', error);
      res.json({
        country: 'Unknown',
        city: 'Unknown',
        region: 'Unknown'
      });
    }
  });

  // Cities API by country
  app.get("/api/cities/:countryCode", async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      // Handle country code mapping for cities
      // Some countries have different codes in the countries table vs cities table
      const countryCodeMapping: { [key: string]: string } = {
        'UK': 'GB',  // United Kingdom maps to Great Britain in cities
        // Add more mappings as needed
      };
      
      const actualCountryCode = countryCodeMapping[countryCode] || countryCode;
      
      const citiesData = await db
        .select({
          id: sql`cities.id`,
          name: sql`cities.name`,
          countryCode: sql`cities.country_code`,
          isMajor: sql`cities.is_major`
        })
        .from(sql`cities`)
        .where(sql`cities.country_code = ${actualCountryCode}`)
        .orderBy(sql`cities.name`);
      
      res.json({ success: true, data: citiesData });
    } catch (error) {
      console.error('Cities fetch error:', error);
      // Return empty array if no cities found for this country
      res.json({ success: true, data: [] });
    }
  });

  // Grade systems API with auto-recovery
  app.get("/api/grade-systems/:countryId", async (req, res) => {
    try {
      const countryId = parseInt(req.params.countryId);
      const gradeSystemsData = await db
        .select()
        .from(gradeSystems)
        .where(eq(gradeSystems.countryId, countryId))
        .orderBy(gradeSystems.gradeNumber);
      
      // Auto-recovery: If grade systems data is missing for this country, re-seed
      if (gradeSystemsData.length === 0) {
        console.log(`âš ï¸ Grade systems data missing for country ${countryId}, triggering auto-recovery...`);
        await seedGradeSystems();
        const reseededGrades = await db
          .select()
          .from(gradeSystems)
          .where(eq(gradeSystems.countryId, countryId))
          .orderBy(gradeSystems.gradeNumber);
        console.log('âœ… Grade systems auto-recovery completed');
        return res.json({ success: true, data: reseededGrades, recovered: true });
      }
      
      res.json({ success: true, data: gradeSystemsData });
    } catch (error) {
      console.error('Grade systems fetch error:', error);
      
      // Try to recover by reseeding
      try {
        console.log('ðŸ”„ Attempting grade systems recovery...');
        await seedGradeSystems();
        const recoveredGrades = await db
          .select()
          .from(gradeSystems)
          .where(eq(gradeSystems.countryId, parseInt(req.params.countryId)))
          .orderBy(gradeSystems.gradeNumber);
        console.log('âœ… Grade systems recovery successful');
        return res.json({ success: true, data: recoveredGrades, recovered: true });
      } catch (recoveryError) {
        console.error('âŒ Grade systems recovery failed:', recoveryError);
        // Fallback to default grade system when database fails
        console.log('ðŸ”„ Using fallback grade systems data due to database connectivity issues');
        const fallbackGrades = [
          { id: 1, countryId: parseInt(req.params.countryId), gradeNumber: 1, displayName: "Grade 1", educationLevel: "Primary", ageRange: "6-7", createdAt: new Date() },
          { id: 2, countryId: parseInt(req.params.countryId), gradeNumber: 2, displayName: "Grade 2", educationLevel: "Primary", ageRange: "7-8", createdAt: new Date() },
          { id: 3, countryId: parseInt(req.params.countryId), gradeNumber: 3, displayName: "Grade 3", educationLevel: "Primary", ageRange: "8-9", createdAt: new Date() },
          { id: 4, countryId: parseInt(req.params.countryId), gradeNumber: 4, displayName: "Grade 4", educationLevel: "Primary", ageRange: "9-10", createdAt: new Date() },
          { id: 5, countryId: parseInt(req.params.countryId), gradeNumber: 5, displayName: "Grade 5", educationLevel: "Primary", ageRange: "10-11", createdAt: new Date() },
          { id: 6, countryId: parseInt(req.params.countryId), gradeNumber: 6, displayName: "Grade 6", educationLevel: "Primary", ageRange: "11-12", createdAt: new Date() },
          { id: 7, countryId: parseInt(req.params.countryId), gradeNumber: 7, displayName: "Grade 7", educationLevel: "Secondary", ageRange: "12-13", createdAt: new Date() },
          { id: 8, countryId: parseInt(req.params.countryId), gradeNumber: 8, displayName: "Grade 8", educationLevel: "Secondary", ageRange: "13-14", createdAt: new Date() },
          { id: 9, countryId: parseInt(req.params.countryId), gradeNumber: 9, displayName: "Grade 9", educationLevel: "Secondary", ageRange: "14-15", createdAt: new Date() },
          { id: 10, countryId: parseInt(req.params.countryId), gradeNumber: 10, displayName: "Grade 10", educationLevel: "Secondary", ageRange: "15-16", createdAt: new Date() },
          { id: 11, countryId: parseInt(req.params.countryId), gradeNumber: 11, displayName: "Grade 11", educationLevel: "Secondary", ageRange: "16-17", createdAt: new Date() },
          { id: 12, countryId: parseInt(req.params.countryId), gradeNumber: 12, displayName: "Grade 12", educationLevel: "Secondary", ageRange: "17-18", createdAt: new Date() },
          { id: 13, countryId: parseInt(req.params.countryId), gradeNumber: 13, displayName: "College", educationLevel: "College", ageRange: "18+", createdAt: new Date() },
          { id: 14, countryId: parseInt(req.params.countryId), gradeNumber: 14, displayName: "University", educationLevel: "University", ageRange: "18+", createdAt: new Date() },
          { id: 15, countryId: parseInt(req.params.countryId), gradeNumber: 15, displayName: "Other", educationLevel: "Other", ageRange: "Any", createdAt: new Date() }
        ];
        res.json({ success: true, data: fallbackGrades, fallback: true });
      }
    }
  });

  // Get current user profile (for refreshing auth state)
  app.get("/api/auth/profile", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Get fresh profile data from database
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      res.json({
        success: true,
        user: {
          id: user.id,
          userId: user.userId,
          email: user.email
        },
        profile: profile[0]
      });

    } catch (error) {
      console.error('Get profile error:', error);
      res.status(500).json({ success: false, error: 'Failed to get profile' });
    }
  });

  // Get Teacher Profile with Application Data
  app.get("/api/teacher/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const userUuid = req.user.id; // This is the UUID from the auth middleware
      const userTextId = req.user.userId; // This is the text ID like "T2509P002"

      console.log('ðŸ” Teacher profile request - userUuid:', userUuid, 'userTextId:', userTextId);

      // Get basic profile data using UUID
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userUuid))
        .limit(1);

      if (profile.length === 0) {
        console.log('âŒ Profile not found for UUID:', userUuid);
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      // Get user email using UUID
      const user = await db.select()
        .from(users)
        .where(eq(users.id, userUuid))
        .limit(1);

      console.log('âœ… Found basic data - profile:', !!profile[0], 'user:', !!user[0]);

      // Create a basic teacher profile with essential data
      const teacherProfile = {
        // Basic profile data
        id: profile[0].id,
        userId: profile[0].userId,
        name: profile[0].name || 'Teacher Name',
        email: user[0]?.email || profile[0].email || 'teacher@example.com',
        bio: profile[0].bio || '',
        avatarUrl: profile[0].avatarUrl || null,
        country: profile[0].country || '',
        role: profile[0].role,
        
        // Teacher application data from profile
        phoneNumber: profile[0].phoneNumber || null,
        qualifications: profile[0].qualifications || '',
        experience: profile[0].experience || '',
        portfolioLinks: [],
        certifications: [],
        availableHours: profile[0].availableHours || '',
        hourlyRate: profile[0].hourlyRate || '25.00',
        applicationStatus: 'approved'
      };

      console.log('ðŸ“‹ Returning teacher profile:', {
        name: teacherProfile.name,
        email: teacherProfile.email,
        phoneNumber: teacherProfile.phoneNumber,
        hourlyRate: teacherProfile.hourlyRate,
        qualifications: teacherProfile.qualifications,
        experience: teacherProfile.experience,
        availableHours: teacherProfile.availableHours
      });

      res.json({
        success: true,
        profile: teacherProfile
      });

    } catch (error) {
      console.error('Get teacher profile error:', error);
      res.status(500).json({ success: false, error: 'Failed to get teacher profile' });
    }
  });

  // Update Teacher Profile
  app.put("/api/teacher/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const userUuid = req.user.id;
      const { 
        name, 
        bio, 
        phoneNumber, 
        hourlyRate, 
        availableHours,
        qualifications,
        experience,
        portfolioLinks,
        certifications,
        avatarUrl 
      } = req.body;

      console.log('ðŸ”„ Updating teacher profile for:', userUuid, 'with data:', {
        name, bio, phoneNumber, hourlyRate, availableHours
      });

      // Update profile table (this should always work)
      const profileUpdates: any = { updatedAt: new Date() };
      if (name !== undefined && name.trim()) profileUpdates.name = name.trim();
      if (bio !== undefined) profileUpdates.bio = bio;
      if (avatarUrl !== undefined) profileUpdates.avatarUrl = avatarUrl;
      if (qualifications !== undefined) profileUpdates.qualifications = qualifications;
      if (experience !== undefined) profileUpdates.experience = experience;
      if (availableHours !== undefined) profileUpdates.availableHours = availableHours;
      if (hourlyRate !== undefined) profileUpdates.hourlyRate = hourlyRate;
      if (phoneNumber !== undefined) profileUpdates.phoneNumber = phoneNumber;

      if (Object.keys(profileUpdates).length > 1) { // More than just updatedAt
        await db
          .update(profiles)
          .set(profileUpdates)
          .where(eq(profiles.userId, userUuid));
        console.log('âœ… Profile table updated successfully');
      }

      // Try to update teacher application table with only safe columns
      try {
        const teacherApp = await db.select({ id: teacherApplications.id })
          .from(teacherApplications)
          .where(eq(teacherApplications.userId, userUuid))
          .limit(1);

        if (teacherApp.length > 0) {
          const safeAppUpdates: any = { updatedAt: new Date() };
          
          // Only update fields that we know exist
          if (phoneNumber !== undefined) safeAppUpdates.phoneNumber = phoneNumber;
          if (hourlyRate !== undefined) safeAppUpdates.hourlyRate = hourlyRate;
          if (qualifications !== undefined) safeAppUpdates.qualifications = qualifications;
          if (experience !== undefined) safeAppUpdates.experience = experience;
          if (bio !== undefined) safeAppUpdates.bio = bio;

          if (Object.keys(safeAppUpdates).length > 1) {
            await db
              .update(teacherApplications)
              .set(safeAppUpdates)
              .where(eq(teacherApplications.userId, userUuid));
            console.log('âœ… Teacher application table updated successfully');
          }
        } else {
          console.log('â„¹ï¸ No teacher application record found, skipping app table update');
        }
      } catch (appError) {
        console.log('âš ï¸ Could not update teacher application table:', appError.message);
        // Don't fail the entire request if teacher app table update fails
      }

      res.json({
        success: true,
        message: 'Teacher profile updated successfully'
      });

    } catch (error) {
      console.error('Update teacher profile error:', error);
      res.status(500).json({ success: false, error: 'Failed to update teacher profile' });
    }
  });

  // Freelancer Registration Endpoint
  app.post("/api/freelancer-register", async (req, res) => {
    try {
      const {
        fullName,
        email,
        password,
        phoneNumber,
        skills,
        experience,
        hourlyRate,
        portfolio,
        specializations,
        bio,
        contactType,
        verificationMethod
      } = req.body;

      // Check for existing verification request (don't check users table before verification)
      const existingVerification = await db
        .select()
        .from(verificationCodes)
        .where(eq(verificationCodes.contactInfo, email))
        .limit(1);

      if (existingVerification.length > 0 && !existingVerification[0].isUsed) {
        return res.status(400).json({
          success: false,
          error: "A verification request is already pending for this email. Please check your email or wait a few minutes."
        });
      }

      // Clean up any expired verification codes
      await db.delete(verificationCodes).where(eq(verificationCodes.contactInfo, email));

      // Prepare user data but DON'T create user yet - wait for verification
      const hashedPassword = await bcrypt.hash(password, 12);
      const verificationCode = generateVerificationCode();
      const userIdString = generateUserId();

      // Store ALL registration data in verification codes table temporarily
      await db
        .insert(verificationCodes)
        .values({
          contactInfo: email,
          type: 'email',
          code: verificationCode,
          expiresAt: new Date(Date.now() + 15 * 60 * 1000),
          userData: { 
            // User data
            userId: userIdString,
            email,
            passwordHash: hashedPassword,
            educationLevel: 'other',
            // Profile data
            fullName,
            age: 25,
            grade: 12,
            country: 'Unknown',
            countryId: null,
            role: 'freelancer',
            bio: bio || '',
            experience: experience || '',
            hourlyRate: hourlyRate || null,
            qualifications: specializations ? specializations.join(', ') : null,
            availableHours: 'Flexible',
            // Additional freelancer data
            skills, 
            portfolio, 
            phoneNumber,
            specializations,
            userType: 'freelancer' 
          }
        });

      // Send verification email
      if (contactType === 'email') {
        try {
          const emailTemplate = getEmailTemplate('verification', {
            name: fullName,
            code: verificationCode,
            expiryMinutes: 15
          });

          const transporter = createEmailTransporter('verify@edufiliova.com');
          await transporter.sendMail({
            from: '"EduFiliova Freelancer Platform" <verify@edufiliova.com>',
            to: email,
            subject: 'Verify Your Freelancer Account - EduFiliova',
            html: emailTemplate
          });
          console.log('âœ… Verification email sent successfully to:', email);
        } catch (emailError) {
          console.error('âŒ Failed to send verification email:', {
            error: emailError instanceof Error ? emailError.message : 'Unknown error',
            code: (emailError as any)?.code,
            response: (emailError as any)?.response,
            responseCode: (emailError as any)?.responseCode,
            to: email,
            timestamp: new Date().toISOString()
          });
          
          // Clean up verification code since email failed
          await db
            .delete(verificationCodes)
            .where(eq(verificationCodes.contactInfo, email));

          return res.status(500).json({
            success: false,
            error: 'Failed to send verification email. Please try again.'
          });
        }
      }

      res.status(201).json({
        success: true,
        message: "Verification email sent successfully. Please check your email to complete registration.",
        data: {
          email: email,
          message: "Account will be created after email verification"
        }
      });

    } catch (error) {
      console.error('Freelancer registration error:', error);
      res.status(500).json({
        success: false,
        error: 'Registration failed. Please try again.'
      });
    }
  });

  // Resend verification code endpoint
  app.post("/api/auth/resend-verification", async (req, res) => {
    try {
      const { email } = req.body;

      if (!email) {
        return res.status(400).json({
          success: false,
          error: "Email is required"
        });
      }

      // Find verification code for this email
      const existingCode = await db
        .select()
        .from(verificationCodes)
        .where(eq(verificationCodes.contactInfo, email))
        .orderBy(desc(verificationCodes.createdAt))
        .limit(1);

      if (existingCode.length === 0) {
        return res.status(404).json({
          success: false,
          error: "No verification code found for this email"
        });
      }

      const code = existingCode[0].code;

      // Resend verification email
      try {
        const emailTemplate = getEmailTemplate('verification', {
          name: 'User',
          code: code,
          expiryMinutes: 15
        });

        const transporter = createEmailTransporter('verify@edufiliova.com');
        await transporter.sendMail({
          from: '"EduFiliova Platform" <verify@edufiliova.com>',
          to: email,
          subject: 'Verification Code - EduFiliova',
          html: emailTemplate
        });

        console.log('âœ… Verification email resent successfully to:', email);

        res.status(200).json({
          success: true,
          message: "Verification code resent successfully"
        });

      } catch (emailError) {
        console.error('âŒ Failed to resend verification email:', {
          error: emailError instanceof Error ? emailError.message : 'Unknown error',
          code: (emailError as any)?.code,
          response: (emailError as any)?.response,
          responseCode: (emailError as any)?.responseCode,
          to: email,
          timestamp: new Date().toISOString()
        });

        res.status(500).json({
          success: false,
          error: 'Failed to resend verification email. Please try again.'
        });
      }

    } catch (error) {
      console.error('Resend verification error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to resend verification code. Please try again.'
      });
    }
  });

  // Admin Freelancer Management Routes
  app.get("/api/admin/freelancers", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { status, search } = req.query;
      
      console.log('ðŸ” Freelancer search request:', { status, search });
      
      // Build conditions array
      const conditions = [eq(profiles.role, 'freelancer')];
      
      if (status) {
        conditions.push(eq(profiles.approvalStatus, status as any));
      }

      if (search && typeof search === 'string') {
        const searchPattern = `%${search}%`;
        console.log('ðŸ” Search pattern:', searchPattern);
        conditions.push(
          or(
            ilike(profiles.name, searchPattern),
            ilike(profiles.displayName, searchPattern),
            ilike(profiles.email, searchPattern)
          )
        );
      }

      const freelancers = await db
        .select({
          id: profiles.id,
          userId: profiles.userId,
          name: profiles.name,
          displayName: profiles.displayName,
          email: profiles.email,
          avatarUrl: profiles.avatarUrl,
          country: profiles.country,
          experience: profiles.experience,
          hourlyRate: profiles.hourlyRate,
          bio: profiles.bio,
          qualifications: profiles.qualifications,
          approvalStatus: profiles.approvalStatus,
          approvedBy: profiles.approvedBy,
          approvedAt: profiles.approvedAt,
          rejectionReason: profiles.rejectionReason,
          adminNotes: profiles.adminNotes,
          likesCount: profiles.likesCount,
          followersCount: profiles.followersCount,
          role: profiles.role,
          createdAt: profiles.createdAt
        })
        .from(profiles)
        .where(and(...conditions))
        .orderBy(profiles.createdAt);

      console.log('ðŸ” Found freelancers:', freelancers.length);
      console.log('ðŸ” Freelancer names:', freelancers.map(f => f.name));

      res.json({
        success: true,
        data: freelancers
      });
    } catch (error) {
      console.error('âŒ Error fetching freelancers:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch freelancers'
      });
    }
  });

  app.post("/api/admin/freelancers/:userId/approve", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { notes } = req.body;
      const adminUserId = req.user?.id;

      // Check if freelancer profile exists and is pending
      const [freelancerProfile] = await db
        .select()
        .from(profiles)
        .where(and(
          eq(profiles.userId, userId),
          eq(profiles.role, 'freelancer')
        ))
        .limit(1);

      if (!freelancerProfile) {
        return res.status(404).json({
          success: false,
          error: 'Freelancer profile not found'
        });
      }

      if (freelancerProfile.approvalStatus === 'approved') {
        return res.json({
          success: true,
          message: 'Freelancer already approved'
        });
      }

      // Update approval status
      await db
        .update(profiles)
        .set({
          approvalStatus: 'approved',
          approvedBy: adminUserId,
          approvedAt: new Date(),
          adminNotes: notes || null,
          rejectionReason: null
        })
        .where(eq(profiles.userId, userId));

      // Send approval email notification
      try {
        const emailTemplate = getEmailTemplate('welcome', {
          name: freelancerProfile.name,
          notes: notes || 'Your freelancer application has been approved!'
        });

        const transporter = createEmailTransporter('support@edufiliova.com');
        await transporter.sendMail({
          from: '"EduFiliova Support" <support@edufiliova.com>',
          to: freelancerProfile.email || '',
          subject: 'Congratulations! Your Freelancer Application Approved - EduFiliova',
          html: emailTemplate
        });
      } catch (emailError) {
        console.error('Failed to send approval email:', emailError);
      }

      res.json({
        success: true,
        message: 'Freelancer approved successfully'
      });

    } catch (error) {
      console.error('Error approving freelancer:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to approve freelancer'
      });
    }
  });

  app.post("/api/admin/freelancers/:userId/reject", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { reason, notes } = req.body;
      const adminUserId = req.user?.id;

      if (!reason || reason.trim() === '') {
        return res.status(400).json({
          success: false,
          error: 'Rejection reason is required'
        });
      }

      // Check if freelancer profile exists
      const [freelancerProfile] = await db
        .select()
        .from(profiles)
        .where(and(
          eq(profiles.userId, userId),
          eq(profiles.role, 'freelancer')
        ))
        .limit(1);

      if (!freelancerProfile) {
        return res.status(404).json({
          success: false,
          error: 'Freelancer profile not found'
        });
      }

      if (freelancerProfile.approvalStatus === 'rejected') {
        return res.json({
          success: true,
          message: 'Freelancer already rejected'
        });
      }

      // Update rejection status
      await db
        .update(profiles)
        .set({
          approvalStatus: 'rejected',
          approvedBy: adminUserId,
          approvedAt: new Date(),
          rejectionReason: reason,
          adminNotes: notes || null
        })
        .where(eq(profiles.userId, userId));

      // Send rejection email notification
      try {
        const emailTemplate = getEmailTemplate('freelancerRejection', {
          name: freelancerProfile.name,
          reason: reason,
          notes: notes
        });

        const transporter = createEmailTransporter('support@edufiliova.com');
        await transporter.sendMail({
          from: '"EduFiliova Support" <support@edufiliova.com>',
          to: freelancerProfile.email || '',
          subject: 'Update on Your Freelancer Application - EduFiliova',
          html: emailTemplate
        });
      } catch (emailError) {
        console.error('Failed to send rejection email:', emailError);
      }

      res.json({
        success: true,
        message: 'Freelancer rejected successfully'
      });

    } catch (error) {
      console.error('Error rejecting freelancer:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reject freelancer'
      });
    }
  });

  // Featured Users Management (Admin only)
  app.get("/api/admin/featured-users", requireAuth, requireAdmin, async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 20;
      const featuredUsers = await storage.getFeaturedUsers(limit);
      
      res.json({
        success: true,
        data: featuredUsers
      });
    } catch (error) {
      console.error('Error fetching featured users:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch featured users'
      });
    }
  });

  app.post("/api/admin/users/:userId/toggle-featured", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId: textUserId } = req.params;
      const adminUserId = req.user?.id;

      if (!adminUserId) {
        return res.status(401).json({
          success: false,
          error: 'Unauthorized'
        });
      }

      // Look up the user's UUID by their text userId
      const user = await db.select({ id: users.id })
        .from(users)
        .where(eq(users.userId, textUserId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'User not found'
        });
      }

      const userUuid = user[0].id;
      const result = await storage.toggleFeaturedStatus(userUuid, adminUserId);
      
      res.json({
        success: true,
        data: result,
        message: result.isFeatured ? 'User marked as featured' : 'User removed from featured'
      });
    } catch (error) {
      console.error('Error toggling featured status:', error);
      res.status(500).json({
        success: false,
        error: error instanceof Error ? error.message : 'Failed to toggle featured status'
      });
    }
  });

  // Public endpoint to get featured creators
  app.get("/api/featured-creators", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 10;
      const featuredUsers = await storage.getFeaturedUsers(limit);
      
      res.json({
        success: true,
        data: featuredUsers
      });
    } catch (error) {
      console.error('Error fetching featured creators:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch featured creators'
      });
    }
  });

  // User Registration with Dual Verification
  app.post("/api/auth/register", async (req, res) => {
    try {
      const { name, age, grade, educationLevel, country, email, phone, password } = req.body;

      // Validation
      if (!name || !age || !grade || !country || !email || !password) {
        return res.status(400).json({ success: false, error: "Missing required fields" });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      if (phone && !isValidPhone(phone)) {
        return res.status(400).json({ success: false, error: "Invalid phone number format" });
      }

      // Check for existing verification request (don't check users table before verification)
      const existingVerification = await db
        .select()
        .from(verificationCodes)
        .where(eq(verificationCodes.contactInfo, email))
        .limit(1);

      if (existingVerification.length > 0 && !existingVerification[0].isUsed) {
        return res.status(400).json({ 
          success: false, 
          error: "A verification request is already pending for this email. Please check your email or wait a few minutes." 
        });
      }

      // Clean up any expired verification codes
      await db.delete(verificationCodes).where(eq(verificationCodes.contactInfo, email));

      // Store registration data temporarily and send verification
      const emailCode = generateVerificationCode();
      const smsCode = phone ? generateVerificationCode() : null;

      const registrationData = {
        name,
        age: parseInt(age),
        grade: parseInt(grade),
        educationLevel: educationLevel || 'grade',
        country,
        email,
        phone: phone || null,
        passwordHash: await bcrypt.hash(password, 10),
        emailCode,
        smsCode,
        emailVerified: false,
        smsVerified: !phone // If no phone, consider SMS verified
      };

      // Send email verification first
      const emailResult = await sendEmail(
        email,
        'Verify Your EduFiliova Account',
        getEmailTemplate('verification', { code: emailCode })
      );

      // If email failed, return error immediately
      if (!emailResult.success) {
        return res.status(500).json({
          success: false,
          error: "Failed to send verification email. Please try again.",
          details: emailResult.error
        });
      }

      // Send WhatsApp OTP verification if phone provided (prioritize WhatsApp over SMS)
      let whatsappResult = { success: true, messageId: undefined as string | undefined, error: undefined as string | undefined };
      if (phone && smsCode) {
        if (isWhatsAppConfigured()) {
          // Use WhatsApp for OTP
          whatsappResult = await sendWhatsAppOTP(phone, smsCode);
          if (whatsappResult.success) {
            console.log('âœ… WhatsApp OTP sent successfully to:', phone);
          } else {
            console.warn('âš ï¸ WhatsApp OTP failed, user will verify via email only:', whatsappResult.error);
            // No SMS fallback - email verification is already sent, so phone verification is optional
          }
        } else {
          // WhatsApp not configured - email verification is already sent, so phone verification is optional
          console.log('âš ï¸ WhatsApp not configured, skipping phone OTP (email verification only)');
        }
        
        // If both failed but email succeeded, still continue (phone verification is optional)
        if (!whatsappResult.success) {
          console.warn('Phone verification failed but continuing with email-only verification:', whatsappResult.error);
        }
      }

      // Only store verification data AFTER successful email sending
      // Clean up any existing verification codes for this email/phone
      await db.delete(verificationCodes).where(eq(verificationCodes.contactInfo, email));
      if (phone) {
        await db.delete(verificationCodes).where(eq(verificationCodes.contactInfo, phone));
      }

      // Store email verification
      await db.insert(verificationCodes).values({
        contactInfo: email,
        type: 'email',
        code: emailCode,
        expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes
        userData: registrationData
      });

      // Store SMS verification if phone provided and SMS was sent successfully
      if (phone && smsCode && whatsappResult.success) {
        await db.insert(verificationCodes).values({
          contactInfo: phone,
          type: 'phone',
          code: smsCode,
          expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes
          userData: registrationData
        });
      }

      res.json({
        success: true,
        message: "Verification codes sent",
        requiresEmailVerification: true,
        requiresPhoneVerification: !!phone && whatsappResult.success,
        emailSent: emailResult.success,
        whatsappSent: whatsappResult.success
      });

    } catch (error) {
      console.error('Registration error:', error);
      
      // Provide specific error messages for better user experience
      if (error instanceof Error) {
        if (error.message.includes('duplicate key value violates unique constraint')) {
          if (error.message.includes('verification_codes_contact_info_unique')) {
            return res.status(400).json({ 
              success: false, 
              error: "A verification request is already pending for this email. Please check your email or try again in a few minutes." 
            });
          }
          if (error.message.includes('auth_users_email_unique')) {
            return res.status(400).json({ 
              success: false, 
              error: "An account with this email already exists. Please try logging in instead." 
            });
          }
        }
        if (error.message.includes('Connection') || error.message.includes('timeout')) {
          return res.status(503).json({ 
            success: false, 
            error: "Service temporarily unavailable. Please try again in a few minutes." 
          });
        }
      }
      
      res.status(500).json({ success: false, error: "Registration failed. Please try again." });
    }
  });

  // Verify Registration Codes
  app.post("/api/auth/verify-registration", async (req, res) => {
    try {
      const { email, emailCode, smsCode } = req.body;

      if (!email || !emailCode) {
        return res.status(400).json({ success: false, error: "Email and email code are required" });
      }

      // Get email verification record
      const emailVerification = await db
        .select()
        .from(verificationCodes)
        .where(and(
          eq(verificationCodes.contactInfo, email),
          eq(verificationCodes.type, 'email'),
          eq(verificationCodes.isUsed, false)
        ))
        .limit(1);

      if (emailVerification.length === 0) {
        return res.status(400).json({ success: false, error: "Invalid or expired email verification code" });
      }

      const emailRecord = emailVerification[0];

      // Check email code and expiration
      if (emailRecord.code !== emailCode || new Date() > emailRecord.expiresAt) {
        return res.status(400).json({ success: false, error: "Invalid or expired email verification code" });
      }

      const userData = emailRecord.userData as any;

      // Check SMS verification if phone was provided
      if (userData.phone && smsCode) {
        const smsVerification = await db
          .select()
          .from(verificationCodes)
          .where(and(
            eq(verificationCodes.contactInfo, userData.phone),
            eq(verificationCodes.type, 'phone'),
            eq(verificationCodes.isUsed, false)
          ))
          .limit(1);

        if (smsVerification.length === 0 || smsVerification[0].code !== smsCode || new Date() > smsVerification[0].expiresAt) {
          return res.status(400).json({ success: false, error: "Invalid or expired SMS verification code" });
        }

        // Mark SMS verification as used
        await db
          .update(verificationCodes)
          .set({ isUsed: true })
          .where(eq(verificationCodes.id, smsVerification[0].id));
      } else if (userData.phone && !smsCode) {
        return res.status(400).json({ success: false, error: "SMS verification code required" });
      }

      // Check if user already exists (in case verification is retried)
      const existingUser = await db.select().from(users).where(eq(users.email, userData.email)).limit(1);
      if (existingUser.length > 0) {
        return res.status(400).json({ success: false, error: "An account with this email already exists. Please try logging in instead." });
      }

      // Create user account
      const userId = generateUserId();
      
      const newUser = await db.insert(users).values({
        userId,
        email: userData.email,
        passwordHash: userData.passwordHash
      }).returning();

      // Find country ID
      const countryRecord = await db
        .select()
        .from(countries)
        .where(eq(countries.name, userData.country))
        .limit(1);

      // Get detected location from IP
      const detectedLocation = req.userLocation;
      const locationStr = detectedLocation 
        ? `${detectedLocation.city || ''}, ${detectedLocation.country || ''}`.trim() 
        : null;

      // Create profile with location data
      const newProfile = await db.insert(profiles).values({
        userId: newUser[0].id,
        name: userData.name || userData.fullName, // Handle freelancer fullName
        email: userData.email, // Add email to profile
        age: userData.age || 25, // Default age for freelancers
        grade: userData.grade || 12, // Add required grade field with default
        educationLevel: userData.educationLevel || "other", // Default education level
        country: userData.country,
        countryId: countryRecord.length > 0 ? countryRecord[0].id : null,
        location: locationStr, // Save detected location
        locationLat: detectedLocation?.latitude ? String(detectedLocation.latitude) : null,
        locationLng: detectedLocation?.longitude ? String(detectedLocation.longitude) : null,
        role: userData.skills ? "freelancer" : "student" // Set role based on registration type
      }).returning();

      // Mark email verification as used
      await db
        .update(verificationCodes)
        .set({ isUsed: true })
        .where(eq(verificationCodes.id, emailRecord.id));

      // Send welcome email
      await sendEmail(
        userData.email,
        'Welcome to EduFiliova!',
        getEmailTemplate('welcome', { 
          name: userData.name,
          loginUrl: `${req.protocol}://${req.get('host')}`
        })
      );

      res.json({
        success: true,
        message: "Account created successfully!",
        user: {
          userId: newUser[0].userId,
          email: newUser[0].email
        },
        profile: newProfile[0]
      });

    } catch (error) {
      console.error('Verification error:', error);
      res.status(500).json({ success: false, error: "Verification failed" });
    }
  });

  // User Login
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { loginId, password } = req.body;

      if (!loginId || !password) {
        return res.status(400).json({ success: false, error: "Login ID and password are required" });
      }

      // Find user by email or userId
      const user = await db
        .select()
        .from(users)
        .where(or(eq(users.email, loginId), eq(users.userId, loginId)))
        .limit(1);

      if (user.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Get user profile
      const profile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, user[0].id))
        .limit(1);

      if (profile.length === 0) {
        return res.status(401).json({ success: false, error: "User profile not found" });
      }

      // Check if user is banned or suspended
      if (profile[0].status === 'banned') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been banned. Please contact support if you believe this is an error.' 
        });
      }

      if (profile[0].status === 'suspended') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been temporarily suspended. Please contact support for more information.' 
        });
      }

      // Create session
      const sessionId = uuidv4();
      await db.insert(userLoginSessions).values({
        userId: user[0].id,
        sessionId,
        userAgent: req.headers['user-agent'] || 'Unknown',
        ipAddress: req.ip || 'Unknown',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });

      res.json({
        success: true,
        user: {
          id: user[0].id,
          userId: user[0].userId,
          email: user[0].email
        },
        profile: profile.length > 0 ? profile[0] : null,
        sessionId
      });

    } catch (error) {
      console.error('Login error:', error);
      res.status(500).json({ success: false, error: "Login failed" });
    }
  });

  // Password Reset Request
  app.post("/api/auth/forgot-password", async (req, res) => {
    try {
      const { email } = req.body;

      if (!email || !isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Valid email is required" });
      }

      // Find user
      const user = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (user.length === 0) {
        // Don't reveal if email exists
        return res.json({ success: true, message: "If an account with this email exists, a reset link has been sent." });
      }

      // Generate reset token
      const resetToken = uuidv4();
      const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour

      await db.insert(passwordResetTokens).values({
        userId: user[0].id,
        token: resetToken,
        expiresAt
      });

      // Send reset email
      const resetUrl = `${req.protocol}://${req.get('host')}/reset-password?token=${resetToken}`;
      await sendEmail(
        email,
        'Reset Your EduFiliova Password',
        getEmailTemplate('password_reset', { resetUrl })
      );

      res.json({ success: true, message: "If an account with this email exists, a reset link has been sent." });

    } catch (error) {
      console.error('Password reset request error:', error);
      res.status(500).json({ success: false, error: "Password reset request failed" });
    }
  });

  // Password Reset
  app.post("/api/auth/reset-password", async (req, res) => {
    try {
      const { token, newPassword } = req.body;

      if (!token || !newPassword) {
        return res.status(400).json({ success: false, error: "Token and new password are required" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ success: false, error: "Password must be at least 6 characters long" });
      }

      // Find valid reset token
      const resetToken = await db
        .select()
        .from(passwordResetTokens)
        .where(and(
          eq(passwordResetTokens.token, token),
          eq(passwordResetTokens.isUsed, false)
        ))
        .limit(1);

      if (resetToken.length === 0 || new Date() > resetToken[0].expiresAt) {
        return res.status(400).json({ success: false, error: "Invalid or expired reset token" });
      }

      // Update password
      const newPasswordHash = await bcrypt.hash(newPassword, 10);
      await db
        .update(users)
        .set({ passwordHash: newPasswordHash })
        .where(eq(users.id, resetToken[0].userId));

      // Mark token as used
      await db
        .update(passwordResetTokens)
        .set({ isUsed: true })
        .where(eq(passwordResetTokens.id, resetToken[0].id));

      res.json({ success: true, message: "Password reset successful" });

    } catch (error) {
      console.error('Password reset error:', error);
      res.status(500).json({ success: false, error: "Password reset failed" });
    }
  });

  // User Logout
  app.post("/api/auth/logout", async (req, res) => {
    try {
      const { sessionId } = req.body;

      if (sessionId) {
        await db
          .update(userLoginSessions)
          .set({ isActive: false })
          .where(eq(userLoginSessions.sessionId, sessionId));
      }

      res.json({ success: true, message: "Logged out successfully" });
    } catch (error) {
      console.error('Logout error:', error);
      res.status(500).json({ success: false, error: "Logout failed" });
    }
  });

  // Social Authentication Callback
  app.post("/api/auth/social-callback", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      const { provider, isCheckout } = req.body;

      if (!authHeader?.startsWith('Bearer ')) {
        return res.status(401).json({ 
          success: false, 
          error: "No authorization token provided" 
        });
      }

      // Create Supabase admin client for JWT verification
      const { createClient } = await import('@supabase/supabase-js');
      const supabaseUrl = process.env.VITE_SUPABASE_URL;
      const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;

      if (!supabaseUrl || !supabaseServiceKey) {
        console.error('Missing Supabase configuration');
        return res.status(500).json({ 
          success: false, 
          error: "Server configuration error" 
        });
      }

      const supabase = createClient(supabaseUrl, supabaseServiceKey, {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      });

      // Verify the JWT token
      const token = authHeader.replace('Bearer ', '');
      const { data: { user: supabaseUser }, error: jwtError } = await supabase.auth.getUser(token);

      if (jwtError || !supabaseUser) {
        console.error('JWT verification failed:', jwtError);
        return res.status(401).json({ 
          success: false, 
          error: "Invalid token" 
        });
      }

      // Check if user already exists by email or supabase_user_id
      const existingUser = await db
        .select()
        .from(users)
        .where(
          or(
            eq(users.email, supabaseUser.email || ''),
            eq(users.supabaseUserId, supabaseUser.id)
          )
        )
        .limit(1);

      let internalUser;
      let needsProfileCompletion = false;
      let needsRoleSelection = false;

      if (existingUser.length > 0) {
        // Update existing user with Supabase ID if not already set
        internalUser = existingUser[0];
        if (!internalUser.supabaseUserId) {
          await db
            .update(users)
            .set({ supabaseUserId: supabaseUser.id })
            .where(eq(users.id, internalUser.id));
        }
      } else {
        // Create new user from social login
        const userId = generateUserId(); // Generate 10-digit user ID
        const userName = supabaseUser.user_metadata?.name || 
                        supabaseUser.user_metadata?.full_name || 
                        supabaseUser.email?.split('@')[0] || 
                        'User';
        
        const newUserData = {
          userId: userId,
          email: supabaseUser.email || '',
          passwordHash: null, // No password for social auth
          supabaseUserId: supabaseUser.id,
          authProvider: provider,
          hasCompletedProfile: false,
          hasSelectedRole: false,
        };

        const [createdUser] = await db.insert(users).values(newUserData).returning();
        
        // Create a basic profile for the new user
        await db.insert(profiles).values({
          userId: createdUser.id,
          name: userName,
          email: createdUser.email,
          age: 18, // Default age, will be updated during profile completion
          grade: 12, // Default grade, will be updated during profile completion
          country: "Not specified", // Will be updated during profile completion
        });
        
        internalUser = createdUser;
        needsProfileCompletion = true;
        needsRoleSelection = true;
      }

      // Check profile completion status
      if (internalUser.hasCompletedProfile === false) {
        needsProfileCompletion = true;
      }

      // Check role selection status  
      if (internalUser.hasSelectedRole === false) {
        needsRoleSelection = true;
      }

      // Create session for internal auth system
      const sessionId = uuidv4();
      const sessionExpiry = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

      await db.insert(userLoginSessions).values({
        userId: internalUser.id,
        sessionId: sessionId,
        expiresAt: sessionExpiry,
        isActive: true,
        loginMethod: 'social',
        provider: provider,
        createdAt: new Date()
      });

      // For checkout users, mark them appropriately
      if (isCheckout) {
        await db
          .update(users)
          .set({ 
            isFromCheckout: true,
            hasSelectedRole: false // Force role selection for checkout users
          })
          .where(eq(users.id, internalUser.id));
        needsRoleSelection = true;
      }

      res.json({ 
        success: true, 
        sessionId,
        user: {
          id: internalUser.id,
          email: internalUser.email,
          userId: internalUser.userId,
          hasCompletedProfile: internalUser.hasCompletedProfile,
          hasSelectedRole: internalUser.hasSelectedRole,
        },
        needsProfileCompletion,
        needsRoleSelection,
        isFromCheckout: isCheckout || internalUser.isFromCheckout
      });

    } catch (error) {
      console.error('Social auth callback error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Authentication failed" 
      });
    }
  });

  // Complete Profile after Social Login
  app.post("/api/auth/complete-profile", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Not authenticated" });
      }

      const user = await getUserFromSession(authHeader);
      if (!user) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const { age, grade, country } = req.body;

      // Update user's profile
      await db
        .update(users)
        .set({
          age: parseInt(age),
          grade: parseInt(grade),  
          country: country,
          hasCompletedProfile: true
        })
        .where(eq(users.id, user.id));

      res.json({ 
        success: true, 
        message: "Profile completed successfully" 
      });

    } catch (error) {
      console.error('Profile completion error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to complete profile" 
      });
    }
  });

  // Select Role after Social Login  
  app.post("/api/auth/select-role", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Not authenticated" });
      }

      const user = await getUserFromSession(authHeader);
      if (!user) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const { role } = req.body;

      if (!['student', 'teacher', 'freelancer'].includes(role)) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid role selected" 
        });
      }

      // Update user's role
      await db
        .update(users)
        .set({
          role: role,
          hasSelectedRole: true
        })
        .where(eq(users.id, user.id));

      res.json({ 
        success: true, 
        message: "Role selected successfully",
        role: role 
      });

    } catch (error) {
      console.error('Role selection error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to select role" 
      });
    }
  });

  // Mark user as from checkout
  app.post("/api/auth/mark-checkout-user", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Not authenticated" });
      }

      const user = await getUserFromSession(authHeader);
      if (!user) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      await db
        .update(users)
        .set({ isFromCheckout: true })
        .where(eq(users.id, user.id));

      res.json({ 
        success: true, 
        message: "Checkout user marked successfully" 
      });

    } catch (error) {
      console.error('Mark checkout user error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to mark checkout user" 
      });
    }
  });

  // Freelancer Authentication Endpoints
  app.post("/api/freelancer/signup", async (req, res) => {
    try {
      const { email, password, fullName, role } = req.body;

      // Validation
      if (!email || !password || !fullName) {
        return res.status(400).json({ success: false, error: "Email, password, and full name are required" });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      if (password.length < 8) {
        return res.status(400).json({ success: false, error: "Password must be at least 8 characters long" });
      }

      // Check if user already exists
      const existingUser = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (existingUser.length > 0) {
        return res.status(400).json({ success: false, error: "Email already registered. Please sign in instead." });
      }

      // Check for existing verification request
      const existingVerification = await db
        .select()
        .from(verificationCodes)
        .where(eq(verificationCodes.contactInfo, email))
        .limit(1);

      if (existingVerification.length > 0 && !existingVerification[0].isUsed) {
        return res.status(400).json({ 
          success: false, 
          error: "A verification request is already pending for this email. Please check your email or wait a few minutes." 
        });
      }

      // Clean up any expired verification codes
      await db.delete(verificationCodes).where(eq(verificationCodes.contactInfo, email));

      // Store registration data temporarily and send verification
      const emailCode = generateVerificationCode();

      const registrationData = {
        name: fullName,
        age: 25, // Default age for freelancers
        grade: 0, // No grade for freelancers
        educationLevel: 'freelancer',
        country: 'Global', // Default for freelancers
        email,
        phone: null,
        passwordHash: await bcrypt.hash(password, 10),
        emailCode,
        smsCode: null,
        emailVerified: false,
        smsVerified: true, // No SMS for freelancers
        role: 'freelancer'
      };

      // Send email verification
      const emailResult = await sendEmail(
        email,
        'Verify Your Freelancer Account - EduFiliova',
        getEmailTemplate('verification', { code: emailCode, name: fullName })
      );

      // If email failed, return error immediately
      if (!emailResult.success) {
        return res.status(500).json({
          success: false,
          error: "Failed to send verification email. Please try again.",
          details: emailResult.error
        });
      }

      // Store email verification
      await db.insert(verificationCodes).values({
        contactInfo: email,
        type: 'email',
        code: emailCode,
        expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 minutes
        userData: registrationData
      });

      res.json({
        success: true,
        message: "Verification code sent to your email",
        needsVerification: true,
        emailSent: true
      });

    } catch (error) {
      console.error('Freelancer signup error:', error);
      res.status(500).json({ success: false, error: "Registration failed" });
    }
  });

  app.post("/api/freelancer/signin", async (req, res) => {
    try {
      const { email, password, role } = req.body;

      if (!email || !password) {
        return res.status(400).json({ success: false, error: "Email and password are required" });
      }

      // Find user by email
      const user = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (user.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Get user profile
      const profile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, user[0].id))
        .limit(1);

      if (profile.length === 0) {
        return res.status(401).json({ success: false, error: "User profile not found" });
      }

      // Check if user is banned or suspended
      if (profile[0].status === 'banned') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been banned. Please contact support if you believe this is an error.' 
        });
      }

      if (profile[0].status === 'suspended') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been temporarily suspended. Please contact support for more information.' 
        });
      }

      // Update user role to freelancer if not already
      if (profile[0].role !== 'freelancer') {
        await db
          .update(profiles)
          .set({ role: 'freelancer' })
          .where(eq(profiles.userId, user[0].id));
        
        // Refresh profile data
        const updatedProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, user[0].id))
          .limit(1);

        profile[0] = updatedProfile[0];
      }

      // Create session
      const sessionId = uuidv4();
      await db.insert(userLoginSessions).values({
        userId: user[0].id,
        sessionId,
        userAgent: req.headers['user-agent'] || 'Unknown',
        ipAddress: req.ip || 'Unknown',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });

      res.json({
        success: true,
        user: {
          id: user[0].id,
          userId: user[0].userId,
          email: user[0].email
        },
        profile: profile[0],
        sessionId
      });

    } catch (error) {
      console.error('Freelancer signin error:', error);
      res.status(500).json({ success: false, error: "Sign in failed" });
    }
  });

  // Shop Authentication Routes
  app.post("/api/shop/signup", async (req, res) => {
    try {
      const { email, password, fullName } = req.body;

      // Validation
      if (!email || !password || !fullName) {
        return res.status(400).json({ success: false, error: "Email, password, and full name are required" });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      if (password.length < 8) {
        return res.status(400).json({ success: false, error: "Password must be at least 8 characters long" });
      }

      // Check if user already exists
      const existingUser = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (existingUser.length > 0) {
        return res.status(400).json({ success: false, error: "Email already registered. Please sign in instead." });
      }

      // Check if there's a pending signup for this email
      const existingPending = await storage.getPendingShopSignup(email);
      if (existingPending) {
        // Delete old pending signup
        await storage.deletePendingShopSignup(email);
      }

      // Generate secure verification token instead of 6-digit code
      const crypto = await import('crypto');
      const verificationToken = crypto.randomBytes(32).toString('hex');

      // Hash password
      const passwordHash = await bcrypt.hash(password, 10);

      // Set expiration to 24 hours from now
      const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000);

      // Save pending signup with token
      await storage.createPendingShopSignup({
        email,
        fullName,
        passwordHash,
        verificationCode: verificationToken, // Store token in verificationCode field
        expiresAt
      });

      // Generate verification link - points directly to API route
      const baseUrl = process.env.REPLIT_DEV_DOMAIN
        ? `https://${process.env.REPLIT_DEV_DOMAIN}`
        : process.env.BASE_URL || 'http://localhost:5000';
      const verificationLink = `${baseUrl}/api/shop/verify-link?token=${verificationToken}`;

      // Send verification link email instead of code
      const { emailService } = await import('./utils/email.js');
      await emailService.sendShopVerificationLinkEmail(email, {
        fullName,
        verificationLink,
        expiresIn: '24 hours'
      });

      res.json({
        success: true,
        requiresLinkVerification: true, // New flag for link-based verification
        message: "Please check your email and click the verification link to complete your registration.",
        email
      });

    } catch (error) {
      console.error('Shop signup error:', error);
      res.status(500).json({ success: false, error: "Registration failed" });
    }
  });

  app.post("/api/shop/verify-email", async (req, res) => {
    try {
      const { email, code } = req.body;

      // Validation
      if (!email || !code) {
        return res.status(400).json({ success: false, error: "Email and verification code are required" });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      // Get pending signup
      const pendingSignup = await storage.getPendingShopSignup(email);

      if (!pendingSignup) {
        return res.status(400).json({ 
          success: false, 
          error: "No pending signup found for this email. Please sign up again." 
        });
      }

      // Check if verification code matches
      if (pendingSignup.verificationCode !== code) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid verification code" 
        });
      }

      // Check if code has expired
      if (new Date() > new Date(pendingSignup.expiresAt)) {
        await storage.deletePendingShopSignup(email);
        return res.status(400).json({ 
          success: false, 
          error: "Verification code has expired. Please sign up again." 
        });
      }

      // Check if user already exists BEFORE creating account
      const existingUser = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (existingUser.length > 0) {
        // Delete the pending signup
        await storage.deletePendingShopSignup(email);
        return res.status(400).json({ 
          success: false, 
          error: "Email already registered. Please sign in instead." 
        });
      }

      // Generate unique user ID
      let userIdToUse = generateUserId();

      // Wrap user creation in try-catch for duplicate email constraint
      try {
        // Create user with verified email
        const newUser = await db.insert(users).values({
          userId: userIdToUse,
          email: pendingSignup.email,
          passwordHash: pendingSignup.passwordHash,
          isEmailVerified: true,
          isPhoneVerified: false
        }).returning();

        // Create profile with general role (shop customer)
        const newProfile = await db.insert(profiles).values({
          userId: newUser[0].id,
          name: pendingSignup.fullName,
          age: 18,
          grade: 12,
          country: 'United States',
          role: 'general',
          status: 'active'
        }).returning();

        // Create shop customer record
        const newCustomer = await db.insert(shopCustomers).values({
          userId: newUser[0].id,
          fullName: pendingSignup.fullName,
          email: pendingSignup.email,
          accountType: 'free'
        }).returning();

        // Create free membership for new customer
        if (newCustomer[0]) {
          await db.insert(shopMemberships).values({
            customerId: newCustomer[0].id,
            plan: 'free',
            status: 'active',
            billingCycle: 'monthly'
          });
        }

        // Create session
        const sessionId = uuidv4();
        await db.insert(userLoginSessions).values({
          userId: newUser[0].id,
          sessionId,
          userAgent: req.headers['user-agent'] || 'Unknown',
          ipAddress: req.ip || 'Unknown',
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
        });

        // Delete the pending signup after successful account creation
        await storage.deletePendingShopSignup(email);

        res.json({
          success: true,
          user: {
            id: newUser[0].id,
            userId: newUser[0].userId,
            email: newUser[0].email
          },
          profile: newProfile[0],
          sessionId
        });

      } catch (userCreationError: any) {
        // Ensure pending signup is deleted even if user creation fails
        await storage.deletePendingShopSignup(email);

        // Handle duplicate email constraint error
        if (userCreationError?.code === '23505' || userCreationError?.constraint?.includes('email')) {
          return res.status(400).json({ 
            success: false, 
            error: "Email already registered. Please sign in instead." 
          });
        }

        // Re-throw other errors to be caught by outer catch
        throw userCreationError;
      }

    } catch (error) {
      console.error('Shop email verification error:', error);
      res.status(500).json({ success: false, error: "Email verification failed" });
    }
  });
  app.post("/api/shop/signin", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ success: false, error: "Email and password are required" });
      }

      // Find user by email
      const user = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      if (user.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ success: false, error: "Invalid credentials" });
      }

      // Get user profile
      const profile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, user[0].id))
        .limit(1);

      if (profile.length === 0) {
        return res.status(401).json({ success: false, error: "User profile not found" });
      }

      // Check if user is banned or suspended
      if (profile[0].status === 'banned') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been banned. Please contact support if you believe this is an error.' 
        });
      }

      if (profile[0].status === 'suspended') {
        return res.status(403).json({ 
          success: false, 
          error: 'Account has been temporarily suspended. Please contact support for more information.' 
        });
      }

      // Create session
      const sessionId = uuidv4();
      await db.insert(userLoginSessions).values({
        userId: user[0].id,
        sessionId,
        userAgent: req.headers['user-agent'] || 'Unknown',
        ipAddress: req.ip || 'Unknown',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });

      res.json({
        success: true,
        user: {
          id: user[0].id,
          userId: user[0].userId,
          email: user[0].email
        },
        profile: profile[0],
        sessionId
      });

    } catch (error) {
      console.error('Shop signin error:', error);
      res.status(500).json({ success: false, error: "Sign in failed" });
    }
  });

  // ============================================
  // CUSTOMER DASHBOARD API ROUTES
  // ============================================

  // Get customer dashboard statistics
  app.get("/api/shop/dashboard/stats", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      
      // Get or create shop customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        const profile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        customer = await storage.createShopCustomer({
          userId,
          fullName: profile[0]?.name || 'Customer',
          email: (req as AuthenticatedRequest).user?.email || ''
        });
      }

      const stats = await storage.getCustomerDashboardStats(customer.id);
      res.json(stats);
    } catch (error) {
      console.error('Dashboard stats error:', error);
      res.status(500).json({ error: "Failed to fetch dashboard statistics" });
    }
  });

  // Get purchase history
  app.get("/api/shop/purchases", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ success: true, data: [] });
      }

      const purchases = await storage.getShopPurchasesByCustomerId(customer.id);
      res.json({ success: true, data: purchases });
    } catch (error) {
      console.error('Get purchases error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch purchases" });
    }
  });

  // Get course purchase history
  app.get("/api/course-purchases", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      
      const purchases = await db
        .select({
          id: coursePurchases.id,
          courseId: coursePurchases.courseId,
          courseTitle: courses.title,
          amount: coursePurchases.amount,
          currency: coursePurchases.currency,
          paymentStatus: coursePurchases.paymentStatus,
          purchasedAt: coursePurchases.purchasedAt,
          createdAt: coursePurchases.createdAt,
        })
        .from(coursePurchases)
        .leftJoin(courses, eq(coursePurchases.courseId, courses.id))
        .where(eq(coursePurchases.userId, userId))
        .orderBy(desc(coursePurchases.purchasedAt));
      
      res.json(purchases);
    } catch (error) {
      console.error('Get course purchases error:', error);
      res.status(500).json({ error: "Failed to fetch course purchases" });
    }
  });

  // Claim free digital item and create purchase record
  app.post("/api/shop/purchases/claim-free", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { productId, productName } = req.body;

      if (!productId || !productName) {
        return res.status(400).json({ error: "Product ID and name are required" });
      }

      // Get or create customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        const user = await db.select().from(users).where(eq(users.id, userId)).limit(1);
        
        if (!userProfile[0] || !user[0]) {
          return res.status(404).json({ error: "User profile not found" });
        }

        customer = await storage.createShopCustomer({
          userId: userId,
          fullName: userProfile[0].name,
          email: user[0].email
        });
      }

      // Check daily free download limit (5 per day)
      const todaysPurchases = await db
        .select()
        .from(shopPurchases)
        .where(
          and(
            eq(shopPurchases.customerId, customer.id),
            eq(shopPurchases.price, '0.00'),
            sql`DATE(${shopPurchases.createdAt}) = CURRENT_DATE`
          )
        );

      console.log(`ðŸ”’ Free download check - Customer: ${customer.id}, Today's claims: ${todaysPurchases.length}/5`);

      if (todaysPurchases.length >= 5) {
        console.log(`âŒ Daily limit reached for customer ${customer.id}`);
        return res.status(429).json({ 
          error: "Daily limit reached. You can download up to 5 free products per day. Please try again tomorrow." 
        });
      }

      // Get product details
      const [product] = await db.select().from(products).where(eq(products.id, productId)).limit(1);
      
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }

      // Verify it's a free digital item
      if (product.type !== 'digital' || parseFloat(product.price) > 0) {
        return res.status(400).json({ error: "This product is not a free digital item" });
      }

      // Create purchase record
      const purchase = await storage.createShopPurchase({
        customerId: customer.id,
        itemName: productName,
        itemType: 'digital',
        downloadUrl: product.images[0] || '',
        thumbnailUrl: product.images[0] || '',
        price: '0.00'
      });

      // Create download record for tracking
      const crypto = await import('crypto');
      const downloadToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

      await db.insert(downloads).values({
        userId: userId,
        productId: product.id,
        orderId: null, // No order for free claims
        downloadToken: downloadToken,
        expiresAt: expiresAt,
        isExpired: false,
        downloadedAt: new Date() // Mark as downloaded immediately for free claims
      });

      // Track the download in stats
      await trackProductDownload({
        productId: product.id,
        userId: userId,
        downloadType: 'free',
        ipAddress: (req as any).ip,
        userAgent: req.get('User-Agent')
      });

      console.log(`âœ… Free product claimed and download tracked: ${product.name} by user ${userId}`);

      res.json({ 
        success: true, 
        data: { 
          ...purchase,
          downloadUrl: product.images[0] || '',
          downloadToken: downloadToken
        }
      });
    } catch (error) {
      console.error('Claim free item error:', error);
      res.status(500).json({ error: "Failed to claim free item" });
    }
  });

  // Check if user can download a product with their membership
  app.get("/api/shop/membership/can-download/:productId", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { productId } = req.params;

      // Get product details
      const [product] = await db.select().from(products).where(eq(products.id, productId)).limit(1);
      
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }

      // Free products can always be downloaded (with daily limits)
      if (parseFloat(product.price) === 0) {
        return res.json({ 
          canDownload: true,
          method: 'free',
          reason: 'Free product'
        });
      }

      // Get customer
      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.json({ 
          canDownload: false,
          method: 'purchase',
          reason: 'No membership. Please purchase or upgrade your plan.'
        });
      }

      // Get membership
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      if (!membership) {
        return res.json({ 
          canDownload: false,
          method: 'purchase',
          reason: 'No membership. Please upgrade your plan to download paid products.'
        });
      }

      // Check download limits
      const limitCheck = await checkDownloadLimits(userId, [productId]);
      
      if (limitCheck.canDownload) {
        return res.json({
          canDownload: true,
          method: 'membership',
          reason: 'Can download with membership'
        });
      } else {
        return res.json({
          canDownload: false,
          method: 'purchase',
          reason: limitCheck.reason,
          limitType: limitCheck.limitType
        });
      }
    } catch (error) {
      console.error('Check download eligibility error:', error);
      res.status(500).json({ error: "Failed to check download eligibility" });
    }
  });

  // Claim paid product using membership limits
  app.post("/api/shop/purchases/claim-with-membership", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { productId } = req.body;

      if (!productId) {
        return res.status(400).json({ error: "Product ID is required" });
      }

      // Get product details
      const [product] = await db.select().from(products).where(eq(products.id, productId)).limit(1);
      
      if (!product) {
        return res.status(404).json({ error: "Product not found" });
      }

      // Must be a paid digital product
      if (product.type !== 'digital' || parseFloat(product.price) === 0) {
        return res.status(400).json({ error: "This endpoint is for paid digital products only" });
      }

      // Get or create customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        const user = await db.select().from(users).where(eq(users.id, userId)).limit(1);
        
        if (!userProfile[0] || !user[0]) {
          return res.status(404).json({ error: "User profile not found" });
        }

        customer = await storage.createShopCustomer({
          userId: userId,
          fullName: userProfile[0].name,
          email: user[0].email
        });
      }

      // Check download limits and update counters
      const limitCheck = await checkDownloadLimits(userId, [productId]);
      
      if (!limitCheck.canDownload) {
        return res.status(403).json({ 
          error: limitCheck.reason,
          limitType: limitCheck.limitType,
          upgradeRequired: true
        });
      }

      // Create a "free" order for this membership download
      const [order] = await db
        .insert(orders)
        .values({
          userId: userId,
          totalAmount: '0.00', // Free with membership
          status: 'delivered',
          paymentMethod: 'membership',
          completedAt: new Date()
        })
        .returning();

      // Create order item
      await db.insert(orderItems).values({
        orderId: order.id,
        productId: product.id,
        quantity: 1,
        price: product.price, // Original price for reference
        unitPrice: product.price,
        totalPrice: product.price
      });

      // Generate download token
      const crypto = await import('crypto');
      const downloadToken = crypto.randomBytes(32).toString('hex');
      const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

      const [downloadRecord] = await db
        .insert(downloads)
        .values({
          userId: userId,
          productId: product.id,
          orderId: order.id,
          downloadToken: downloadToken,
          expiresAt: expiresAt,
          isExpired: false
        })
        .returning();

      // Create purchase record for user's library
      const purchase = await storage.createShopPurchase({
        customerId: customer.id,
        itemName: product.name,
        itemType: 'digital',
        downloadUrl: `/download/${downloadToken}`,
        thumbnailUrl: product.images[0] || '',
        price: '0.00' // Free with membership
      });

      console.log(`âœ… Membership download claimed - User: ${userId}, Product: ${product.name}`);

      res.json({ 
        success: true, 
        data: { 
          ...purchase,
          downloadToken: downloadToken,
          downloadUrl: `/download/${downloadToken}`,
          expiresAt: expiresAt
        }
      });
    } catch (error) {
      console.error('Claim with membership error:', error);
      res.status(500).json({ error: "Failed to claim product with membership" });
    }
  });

  // Download digital product by token
  app.get("/download/:token", async (req, res) => {
    try {
      const { token } = req.params;

      // Find download record by token
      const [downloadRecord] = await db
        .select({
          download: downloads,
          product: products
        })
        .from(downloads)
        .leftJoin(products, eq(downloads.productId, products.id))
        .where(eq(downloads.downloadToken, token))
        .limit(1);

      if (!downloadRecord) {
        return res.status(404).json({ error: 'Download not found' });
      }

      // Check if expired
      const now = new Date();
      if (new Date(downloadRecord.download.expiresAt) < now) {
        return res.status(410).json({ error: 'Download link has expired' });
      }

      // Update downloadedAt timestamp if not already set
      if (!downloadRecord.download.downloadedAt) {
        await db
          .update(downloads)
          .set({ downloadedAt: now })
          .where(eq(downloads.id, downloadRecord.download.id));
      }

      // Determine the file URL to download
      let fileUrl = null;
      
      // Check downloadableFiles first (newer format)
      if (downloadRecord.product?.downloadableFiles && Array.isArray(downloadRecord.product.downloadableFiles)) {
        const files = downloadRecord.product.downloadableFiles as any[];
        if (files.length > 0 && files[0].url) {
          fileUrl = files[0].url;
        }
      }
      
      // Fallback to fileUrl (legacy format)
      if (!fileUrl && downloadRecord.product?.fileUrl) {
        fileUrl = downloadRecord.product.fileUrl;
      }

      // If we have a file URL, redirect to it for download
      if (fileUrl) {
        console.log(`ðŸ“¥ Downloading file: ${downloadRecord.product?.name} â†’ ${fileUrl}`);
        return res.redirect(fileUrl);
      }

      // No file found - return error
      console.error('No file URL found for product:', downloadRecord.product?.id);
      return res.status(404).json({ 
        error: 'File not found. The product does not have a downloadable file configured.' 
      });
    } catch (error) {
      console.error('Download error:', error);
      res.status(500).json({ error: 'Download failed' });
    }
  });

  // Get order details with items (for order slip viewer)
  app.get("/api/orders/:orderId", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { orderId } = req.params;

      // Fetch order details
      const [order] = await db
        .select()
        .from(orders)
        .where(eq(orders.id, orderId))
        .limit(1);

      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }

      // Verify user owns this order
      if (order.userId !== userId) {
        return res.status(403).json({ error: 'Unauthorized' });
      }

      // Fetch order items with product details
      const items = await db
        .select({
          id: orderItems.id,
          productId: orderItems.productId,
          productName: products.name,
          quantity: orderItems.quantity,
          unitPrice: orderItems.unitPrice,
          totalPrice: orderItems.totalPrice,
          productImage: products.images,
        })
        .from(orderItems)
        .leftJoin(products, eq(orderItems.productId, products.id))
        .where(eq(orderItems.orderId, orderId));

      res.json({
        success: true,
        data: {
          order,
          items: items.map(item => ({
            ...item,
            productImage: item.productImage?.[0] || null,
          }))
        }
      });
    } catch (error) {
      console.error('Get order details error:', error);
      res.status(500).json({ error: 'Failed to fetch order details' });
    }
  });

  // Download order slip as PDF
  app.get("/api/orders/:orderId/slip", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { orderId } = req.params;

      // Fetch order details
      const [order] = await db
        .select()
        .from(orders)
        .where(eq(orders.id, orderId))
        .limit(1);

      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }

      // Verify user owns this order
      if (order.userId !== userId) {
        return res.status(403).json({ error: 'Unauthorized' });
      }

      // Fetch order items with product details
      const items = await db
        .select({
          id: orderItems.id,
          productName: products.name,
          quantity: orderItems.quantity,
          unitPrice: orderItems.unitPrice,
          totalPrice: orderItems.totalPrice,
        })
        .from(orderItems)
        .leftJoin(products, eq(orderItems.productId, products.id))
        .where(eq(orderItems.orderId, orderId));

      // Import PDFKit for PDF generation
      const PDFDocument = require('pdfkit');
      const doc = new PDFDocument({ margin: 50 });

      // Set response headers for PDF download
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename=order-slip-${orderId.substring(0, 8)}.pdf`);

      // Pipe PDF to response
      doc.pipe(res);

      // Add header
      doc.fontSize(20).text('Order Receipt', { align: 'center' });
      doc.moveDown();

      // Order info
      doc.fontSize(12);
      doc.text(`Order ID: ${orderId.substring(0, 8).toUpperCase()}`, { continued: false });
      doc.text(`Date: ${new Date(order.createdAt).toLocaleDateString()}`, { continued: false });
      doc.text(`Status: ${order.status}`, { continued: false });
      doc.text(`Payment Method: ${order.paymentMethod || 'N/A'}`, { continued: false });
      doc.moveDown();

      // Items table
      doc.fontSize(14).text('Items:', { underline: true });
      doc.moveDown(0.5);
      
      items.forEach((item, index) => {
        doc.fontSize(11);
        doc.text(`${index + 1}. ${item.productName || 'Product'}`);
        doc.text(`   Quantity: ${item.quantity} Ã— $${item.unitPrice} = $${item.totalPrice}`, { indent: 20 });
        doc.moveDown(0.5);
      });

      doc.moveDown();
      
      // Total
      doc.fontSize(14);
      if (order.discountAmount && parseFloat(order.discountAmount as string) > 0) {
        doc.text(`Discount: -$${order.discountAmount}`, { align: 'right' });
      }
      doc.fontSize(16).text(`Total: $${order.totalAmount}`, { align: 'right', bold: true });

      // Finalize PDF
      doc.end();
    } catch (error) {
      console.error('Download order slip error:', error);
      res.status(500).json({ error: 'Failed to download order slip' });
    }
  });

  // Get digital downloads
  app.get("/api/digital-downloads", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;

      // Get downloads with product details
      const userDownloads = await db
        .select({
          id: downloads.id,
          downloadToken: downloads.downloadToken,
          downloadedAt: downloads.downloadedAt,
          expiresAt: downloads.expiresAt,
          isExpired: downloads.isExpired,
          orderId: downloads.orderId,
          productId: downloads.productId,
          productName: products.name,
          productDescription: products.description,
          productType: products.type,
          orderDate: orders.createdAt,
          orderTotal: orders.totalAmount
        })
        .from(downloads)
        .leftJoin(products, eq(downloads.productId, products.id))
        .leftJoin(orders, eq(downloads.orderId, orders.id))
        .where(eq(downloads.userId, userId))
        .orderBy(desc(downloads.expiresAt));

      // Check and update expired status
      const now = new Date();
      const downloadsWithStatus = userDownloads.map(download => {
        const isExpired = new Date(download.expiresAt) < now;
        return {
          ...download,
          isExpired,
          daysUntilExpiry: isExpired ? 0 : Math.ceil((new Date(download.expiresAt).getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
        };
      });

      res.json(downloadsWithStatus);
    } catch (error) {
      console.error('Get digital downloads error:', error);
      res.status(500).json({ error: "Failed to fetch digital downloads" });
    }
  });

  // Get ads campaigns - includes both shop ads and banner ads
  app.get("/api/shop/ads", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      
      // Fetch banner ads directly by userId
      const bannerAds = await db
        .select()
        .from(adsBanners)
        .where(eq(adsBanners.userId, userId))
        .orderBy(desc(adsBanners.createdAt));

      // Transform banner ads to match the shop ads format
      const transformedBannerAds = bannerAds.map(banner => ({
        id: banner.id,
        campaignName: banner.title,
        adType: 'banner',
        targetAudience: banner.targetLocations ? `Targeted (${JSON.parse(banner.targetLocations as string).length} locations)` : 'Global',
        adContent: `Banner ad - ${banner.size}`,
        budget: banner.price.toString(),
        status: banner.status as 'pending' | 'approved' | 'running' | 'paused' | 'rejected',
        impressions: banner.impressions,
        clicks: banner.clicks,
        startDate: banner.startDate.toISOString(),
        endDate: banner.endDate.toISOString(),
        createdAt: banner.createdAt.toISOString(),
        imageUrl: banner.imageUrl,
        placement: banner.placements || banner.placement,
      }));

      res.json(transformedBannerAds);
    } catch (error) {
      console.error('Get ads error:', error);
      res.status(500).json({ error: "Failed to fetch ads" });
    }
  });

  // Create new ad campaign
  app.post("/api/shop/ads", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Get user's membership
      const membership = await db
        .select()
        .from(shopMemberships)
        .where(eq(shopMemberships.customerId, customer.id))
        .limit(1);

      const userMembership = membership[0];
      const currentPlan = userMembership?.plan || 'free';
      
      // Determine if user has annual billing (not monthly)
      // Membership plan format: "free", "creator-monthly", "creator-annual", etc.
      const isAnnual = currentPlan.includes('annual') || currentPlan.endsWith('-yearly');

      // Get membership plan details to check ad limits
      let canCreateFreeCampaign = false;
      let campaignLimit = 0;
      
      if (isAnnual) {
        // Annual subscribers get free campaigns based on their plan
        const planId = currentPlan.replace('-annual', '').replace('-yearly', '');
        const planDetails = await db
          .select()
          .from(shopMembershipPlans)
          .where(eq(shopMembershipPlans.planId, planId))
          .limit(1);
        
        if (planDetails.length > 0) {
          // Use structured annualAdLimit field
          const adLimit = planDetails[0].annualAdLimit;
          
          if (adLimit === null) {
            // null = unlimited campaigns
            canCreateFreeCampaign = true;
            campaignLimit = Infinity;
          } else if (adLimit && adLimit > 0) {
            // Positive number = specific limit
            canCreateFreeCampaign = true;
            campaignLimit = adLimit;
          }
          // adLimit === 0 means no free campaigns (stays false)
        }
      }

      // If they can create free campaigns, check against their limit
      if (canCreateFreeCampaign) {
        // Count active campaigns
        const activeAds = await db
          .select()
          .from(shopAds)
          .where(and(
            eq(shopAds.customerId, customer.id),
            or(
              eq(shopAds.status, 'running'),
              eq(shopAds.status, 'pending')
            )
          ));

        if (activeAds.length >= campaignLimit) {
          return res.status(403).json({ 
            error: `Campaign limit reached. Your plan allows ${campaignLimit} active campaign${campaignLimit > 1 ? 's' : ''}.`,
            requiresPayment: false,
            limit: campaignLimit
          });
        }
      } else {
        // Non-annual users must pay for campaigns
        // Get campaign price from system settings or use default
        const campaignPrice = parseFloat(req.body.budget || '0');
        
        // Check wallet balance
        const wallet = await db
          .select()
          .from(shopTransactions)
          .where(eq(shopTransactions.customerId, customer.id));

        const balance = wallet.reduce((sum, tx) => {
          const amount = parseFloat(tx.amount);
          return tx.type === 'add_funds' ? sum + amount : sum - amount;
        }, 0);

        if (balance < campaignPrice) {
          return res.status(402).json({ 
            error: "Insufficient wallet balance. Please add funds or upgrade to an annual plan for free campaigns.",
            requiresPayment: true,
            requiredAmount: campaignPrice,
            currentBalance: balance
          });
        }

        // Deduct campaign cost from wallet
        await db.insert(shopTransactions).values({
          customerId: customer.id,
          amount: campaignPrice.toFixed(2),
          type: 'ad_spend',
          description: `Payment for advertising campaign: ${req.body.campaignName}`,
          status: 'completed'
        });
      }

      // Extract only allowed fields, never trust customerId from client
      const { campaignName, budget, targetAudience, adContent, startDate, endDate } = req.body;

      const newAd = await storage.createShopAd({
        customerId: customer.id, // Always use authenticated customer's ID
        campaignName,
        budget,
        targetAudience,
        adContent,
        startDate,
        endDate,
        status: 'pending' // Always start as pending
      });

      res.json({
        ...newAd,
        paidCampaign: !canCreateFreeCampaign
      });
    } catch (error) {
      console.error('Create ad error:', error);
      res.status(500).json({ error: "Failed to create ad campaign" });
    }
  });

  // Update ad campaign
  app.put("/api/shop/ads/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Verify ownership - check if ad belongs to this customer
      const existingAd = await storage.getShopAdById(id);
      if (!existingAd) {
        return res.status(404).json({ error: "Ad not found" });
      }

      if (existingAd.customerId !== customer.id) {
        return res.status(403).json({ error: "Unauthorized to modify this ad" });
      }

      // Extract only allowed fields for update
      const { campaignName, budget, targetAudience, adContent, startDate, endDate, status } = req.body;

      const updated = await storage.updateShopAd(id, {
        campaignName,
        budget,
        targetAudience,
        adContent,
        startDate,
        endDate,
        status
      });

      res.json(updated);
    } catch (error) {
      console.error('Update ad error:', error);
      res.status(500).json({ error: "Failed to update ad campaign" });
    }
  });

  // Delete ad campaign
  app.delete("/api/shop/ads/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Verify ownership - check if ad belongs to this customer
      const existingAd = await storage.getShopAdById(id);
      if (!existingAd) {
        return res.status(404).json({ error: "Ad not found" });
      }

      if (existingAd.customerId !== customer.id) {
        return res.status(403).json({ error: "Unauthorized to delete this ad" });
      }

      const deleted = await storage.deleteShopAd(id);

      res.json({ success: true });
    } catch (error) {
      console.error('Delete ad error:', error);
      res.status(500).json({ error: "Failed to delete ad campaign" });
    }
  });

  // Get membership details
  app.get("/api/shop/membership", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ plan: 'free', status: 'active' });
      }

      let membership = await storage.getShopMembershipByCustomerId(customer.id);
      
      if (!membership) {
        membership = await storage.createShopMembership({
          customerId: customer.id,
          plan: customer.accountType || 'free',
          status: 'active'
        });
      }

      res.json(membership);
    } catch (error) {
      console.error('Get membership error:', error);
      res.status(500).json({ error: "Failed to fetch membership details" });
    }
  });

  // Update membership
  app.put("/api/shop/membership", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      
      if (!membership) {
        return res.status(404).json({ error: "Membership not found" });
      }

      const updated = await storage.updateShopMembership(membership.id, req.body);
      
      // Also update customer account type
      await storage.updateShopCustomer(customer.id, { accountType: req.body.plan });

      // Send membership confirmation email
      try {
        const { emailService } = await import('./utils/email.js');
        const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        const userEmail = userProfile[0]?.email || customer.email;
        
        if (userEmail) {
          // Get plan details
          const planDetails = await db
            .select()
            .from(shopMembershipPlans)
            .where(eq(shopMembershipPlans.planId, req.body.plan))
            .limit(1);
          
          if (planDetails[0]) {
            await emailService.sendSubscriptionEmail(userEmail, {
              planName: planDetails[0].name,
              price: parseFloat(planDetails[0].monthlyPrice || '0'),
              billingCycle: 'Monthly',
              orderId: membership.id,
              customerName: customer.fullName || userProfile[0]?.name || undefined,
              features: planDetails[0].features || []
            });
            console.log('ðŸ“§ Membership upgrade email sent to:', userEmail);
          }
        }
      } catch (emailError) {
        console.error('Failed to send membership email:', emailError);
      }

      res.json(updated);
    } catch (error) {
      console.error('Update membership error:', error);
      res.status(500).json({ error: "Failed to update membership" });
    }
  });

  // Calculate shop membership upgrade cost (pro-rated)
  app.post("/api/shop/membership/calculate-upgrade", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { planId, billingCycle } = req.body;

      if (!planId || !billingCycle) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      // Get current membership
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      
      if (!membership || !membership.renewalDate) {
        return res.status(400).json({ error: "No active membership found" });
      }

      // Get target plan details
      const planDetails = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, planId))
        .limit(1);

      if (!planDetails || planDetails.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }

      const targetPlan = planDetails[0];
      
      // Get current plan details
      const currentPlanDetails = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, membership.plan))
        .limit(1);

      if (!currentPlanDetails || currentPlanDetails.length === 0) {
        return res.status(404).json({ error: "Current plan not found" });
      }

      const currentPlan = currentPlanDetails[0];

      // Calculate remaining days
      const now = new Date();
      const renewalDate = new Date(membership.renewalDate);
      const daysRemaining = Math.max(0, Math.ceil((renewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));

      // Determine days in period
      const daysInPeriod = billingCycle === 'monthly' ? 30 : 365;

      // Calculate credit from current plan
      const currentPlanPrice = parseFloat(billingCycle === 'monthly' ? currentPlan.monthlyPrice : currentPlan.yearlyPrice);
      const dailyRate = currentPlanPrice / daysInPeriod;
      const credit = dailyRate * daysRemaining;

      // Calculate target plan cost
      const targetPlanPrice = parseFloat(billingCycle === 'monthly' ? targetPlan.monthlyPrice : targetPlan.yearlyPrice);

      // Calculate upgrade cost
      const upgradeCost = Math.max(0, targetPlanPrice - credit);

      res.json({
        success: true,
        data: {
          currentPlan: membership.plan,
          targetPlan: planId,
          daysRemaining,
          credit: parseFloat(credit.toFixed(2)),
          targetPlanPrice: parseFloat(targetPlanPrice.toFixed(2)),
          upgradeCost: parseFloat(upgradeCost.toFixed(2)),
          billingCycle,
          renewalDate: renewalDate.toISOString()
        }
      });
    } catch (error: any) {
      console.error('Calculate upgrade cost error:', error);
      res.status(500).json({ error: "Failed to calculate upgrade cost" });
    }
  });

  // Upgrade membership with payment (wallet or card) - now supports pro-rated upgrades
  app.post("/api/shop/membership/upgrade", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { planId, billingCycle, paymentMethod } = req.body;

      if (!planId || !billingCycle || !paymentMethod) {
        return res.status(400).json({ error: "Missing required fields" });
      }

      // Get plan details
      const planDetails = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, planId))
        .limit(1);

      if (!planDetails || planDetails.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }

      const plan = planDetails[0];
      
      // Get current membership to calculate pro-rated price
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      let price = parseFloat(billingCycle === 'monthly' ? plan.monthlyPrice : plan.yearlyPrice);
      let isProrated = false;
      
      // Calculate pro-rated price if upgrading from an active membership
      if (membership && membership.renewalDate && membership.plan !== 'free') {
        const currentPlanDetails = await db
          .select()
          .from(shopMembershipPlans)
          .where(eq(shopMembershipPlans.planId, membership.plan))
          .limit(1);

        if (currentPlanDetails && currentPlanDetails.length > 0) {
          const currentPlan = currentPlanDetails[0];
          const now = new Date();
          const renewalDate = new Date(membership.renewalDate);
          const daysRemaining = Math.max(0, Math.ceil((renewalDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
          
          const daysInPeriod = billingCycle === 'monthly' ? 30 : 365;
          const currentPlanPrice = parseFloat(billingCycle === 'monthly' ? currentPlan.monthlyPrice : currentPlan.yearlyPrice);
          const dailyRate = currentPlanPrice / daysInPeriod;
          const credit = dailyRate * daysRemaining;
          
          price = Math.max(0, price - credit);
          isProrated = true;
          
          console.log(`ðŸ’° Pro-rated upgrade: ${membership.plan} â†’ ${planId}, ${daysRemaining} days credit = $${credit.toFixed(2)}, final price = $${price.toFixed(2)}`);
        }
      }

      // Free plan doesn't require payment
      if (planId === 'free' || price === 0) {
        const membership = await storage.getShopMembershipByCustomerId(customer.id);
        
        if (!membership) {
          return res.status(404).json({ error: "Membership not found" });
        }

        // Check if current plan is not free (i.e., downgrade to free)
        if (membership.plan !== 'free') {
          // DOWNGRADE to free: Schedule plan change for renewal date
          const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
          
          const updated = await storage.updateShopMembership(membership.id, { 
            scheduledPlan: planId,
            scheduledPlanDate: renewalDate,
            billingCycle: membership.billingCycle
          });

          if (!updated) {
            return res.status(500).json({ error: "Failed to schedule plan change" });
          }

          console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate}`);
          
          return res.json({ 
            success: true, 
            membership: updated,
            scheduled: true,
            scheduledDate: renewalDate,
            message: `Your plan will change to Free on ${renewalDate.toLocaleDateString()}. You will continue to enjoy your current plan benefits until then.`
          });
        }

        // Already on free plan - reset credits for consistency
        const updated = await storage.updateShopMembership(membership.id, { 
          plan: planId, 
          status: 'active',
          billingCycle,
          adsCreatedThisMonth: 0,
          dailyDownloadsUsed: 0,
          monthlyPaidDownloadsUsed: 0,
          lastDailyResetDate: new Date(),
          lastMonthlyResetDate: new Date()
        });
        
        await storage.updateShopCustomer(customer.id, { accountType: planId });
        
        return res.json({ success: true, membership: updated });
      }

      // Handle wallet payment
      if (paymentMethod === 'wallet') {
        const walletBalance = parseFloat(customer.walletBalance || '0');
        
        if (walletBalance < price) {
          return res.status(400).json({ 
            error: "Insufficient wallet balance",
            required: price,
            available: walletBalance 
          });
        }

        try {
          // Get current membership
          const membership = await storage.getShopMembershipByCustomerId(customer.id);
          let updated: any = null;
          let isDowngrade = false;
          
          if (!membership) {
            // Create new membership if doesn't exist - reset all credits for new plan
            const newMembership = await storage.createShopMembership({
              customerId: customer.id,
              plan: planId,
              status: 'active',
              billingCycle,
              adsCreatedThisMonth: 0,
              dailyDownloadsUsed: 0,
              monthlyPaidDownloadsUsed: 0,
              lastDailyResetDate: new Date(),
              lastMonthlyResetDate: new Date()
            });

            if (!newMembership) {
              throw new Error("Failed to create membership");
            }

            updated = newMembership;

            // Update customer account type
            await storage.updateShopCustomer(customer.id, { accountType: planId });
          } else {
            // Determine if this is an upgrade or downgrade
            const currentPlanDetails = await db
              .select()
              .from(shopMembershipPlans)
              .where(eq(shopMembershipPlans.planId, membership.plan))
              .limit(1);

            const currentPrice = currentPlanDetails.length > 0 
              ? parseFloat(membership.billingCycle === 'monthly' ? currentPlanDetails[0].monthlyPrice : currentPlanDetails[0].yearlyPrice)
              : 0;

            isDowngrade = price < currentPrice;

            if (isDowngrade) {
              // DOWNGRADE: Schedule plan change for renewal date
              const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
              
              updated = await storage.updateShopMembership(membership.id, { 
                scheduledPlan: planId,
                scheduledPlanDate: renewalDate,
                billingCycle: membership.billingCycle // Keep current billing cycle
              });

              if (!updated) {
                throw new Error("Failed to schedule plan change");
              }

              console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate}`);
            } else {
              // UPGRADE: Apply immediately and reset all credits for new plan
              updated = await storage.updateShopMembership(membership.id, { 
                plan: planId, 
                status: 'active',
                billingCycle,
                scheduledPlan: null, // Clear any scheduled changes
                scheduledPlanDate: null,
                adsCreatedThisMonth: 0, // Reset ad credits
                dailyDownloadsUsed: 0, // Reset daily download counter
                monthlyPaidDownloadsUsed: 0, // Reset monthly download counter
                lastDailyResetDate: new Date(), // Reset daily reset date
                lastMonthlyResetDate: new Date() // Reset monthly reset date
              });

              if (!updated) {
                throw new Error("Failed to update membership");
              }

              // Update customer account type
              await storage.updateShopCustomer(customer.id, { accountType: planId });

              console.log(`âœ… Immediately upgraded from ${membership.plan} to ${planId} - Credits reset to 0`);
            }
          }

          // Deduct from wallet after successful membership update
          await storage.updateWalletBalance(customer.id, -price);

          // Create transaction record
          await storage.createShopTransaction({
            customerId: customer.id,
            amount: price.toFixed(2),
            type: 'membership_upgrade',
            description: `${isDowngrade ? 'Scheduled downgrade' : 'Upgraded'} to ${plan.name} (${billingCycle})`,
            status: 'completed',
            paymentMethod: 'wallet'
          });
        } catch (updateError) {
          console.error('Wallet payment error:', updateError);
          return res.status(500).json({ error: "Failed to process wallet payment. Your balance has not been deducted." });
        }

        // Send confirmation email
        try {
          const { emailService } = await import('./utils/email.js');
          const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
          const userEmail = userProfile[0]?.email || customer.email;
          
          const membership = await storage.getShopMembershipByCustomerId(customer.id);
          
          if (userEmail) {
            await emailService.sendSubscriptionEmail(userEmail, {
              planName: plan.name,
              price: price,
              billingCycle: billingCycle === 'monthly' ? 'Monthly' : 'Yearly',
              orderId: membership?.id || '',
              customerName: customer.fullName || userProfile[0]?.name || undefined,
              features: plan.features || []
            });
          }
        } catch (emailError) {
          console.error('Failed to send membership email:', emailError);
        }

        return res.json({ 
          success: true, 
          membership: await storage.getShopMembershipByCustomerId(customer.id),
          paymentMethod: 'wallet' 
        });
      }

      // Handle card payment
      if (paymentMethod === 'card') {
        const stripe = await getStripeInstance();
        if (!stripe) {
          return res.status(500).json({ error: "Payment processing is not configured" });
        }

        // Create Stripe payment intent
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(price * 100), // Convert to cents
          currency: 'usd',
          automatic_payment_methods: {
            enabled: true,
          },
          metadata: {
            customerId: customer.id,
            userId: userId,
            planId: planId,
            billingCycle: billingCycle,
            type: 'membership_upgrade',
          },
        });

        // Store pending transaction
        try {
          const createdTransaction = await storage.createShopTransaction({
            customerId: customer.id,
            amount: price.toFixed(2),
            type: 'membership_upgrade',
            description: `Upgrade to ${plan.name} (${billingCycle})`,
            status: 'pending',
            referenceId: paymentIntent.id
          });
          console.log('âœ… Transaction created:', { id: createdTransaction.id, referenceId: createdTransaction.referenceId });
        } catch (txError) {
          console.error('âŒ Failed to create transaction:', txError);
          throw txError;
        }

        return res.json({ 
          success: true,
          paymentMethod: 'card',
          clientSecret: paymentIntent.client_secret,
          amount: price,
          planId: planId,
          billingCycle: billingCycle
        });
      }

      return res.status(400).json({ error: "Invalid payment method" });

    } catch (error) {
      console.error('Membership upgrade error:', error);
      res.status(500).json({ error: "Failed to process membership upgrade" });
    }
  });

  // Confirm membership upgrade payment (for card payments)
  app.post("/api/shop/membership/confirm-upgrade", requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { paymentIntentId } = req.body;

      if (!paymentIntentId) {
        return res.status(400).json({ error: "Payment intent ID is required" });
      }

      // Get transaction by payment intent ID
      const transactions = await storage.getShopTransactionsByCustomerId(customer.id);
      console.log('ðŸ” Looking for transaction with paymentIntentId:', paymentIntentId);
      console.log('ðŸ” Found transactions:', transactions.map((t: any) => ({ id: t.id, referenceId: t.referenceId, status: t.status, type: t.type })));
      const transaction = transactions.find((t: any) => t.referenceId === paymentIntentId);

      if (!transaction) {
        console.error('âŒ Transaction not found! PaymentIntentId:', paymentIntentId, 'Transactions count:', transactions.length);
        return res.status(404).json({ error: "Transaction not found" });
      }

      if (transaction.status === 'completed') {
        return res.status(409).json({ error: "Payment already processed", alreadyProcessed: true });
      }

      // Verify payment intent with Stripe
      if (stripe) {
        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        
        if (paymentIntent.status !== 'succeeded') {
          return res.status(400).json({ error: "Payment not successful. Status: " + paymentIntent.status });
        }

        // Verify amount matches transaction
        const expectedAmount = Math.round(parseFloat(transaction.amount) * 100);
        if (paymentIntent.amount !== expectedAmount) {
          console.error('Payment amount mismatch:', { expected: expectedAmount, received: paymentIntent.amount });
          return res.status(400).json({ error: "Payment amount mismatch" });
        }

        // Verify metadata matches
        const planId = paymentIntent.metadata.planId;
        const billingCycle = paymentIntent.metadata.billingCycle;

        if (!planId || !billingCycle) {
          return res.status(400).json({ error: "Invalid payment metadata" });
        }

        // Get plan details to verify
        const planDetails = await db
          .select()
          .from(shopMembershipPlans)
          .where(eq(shopMembershipPlans.planId, planId))
          .limit(1);

        if (!planDetails || planDetails.length === 0) {
          return res.status(404).json({ error: "Plan not found" });
        }

        // Update membership
        const membership = await storage.getShopMembershipByCustomerId(customer.id);
        const newPlanPrice = parseFloat(billingCycle === 'monthly' ? planDetails[0].monthlyPrice : planDetails[0].yearlyPrice);
        
        if (!membership) {
          // Create membership if it doesn't exist - reset all credits for new plan
          const newMembership = await storage.createShopMembership({
            customerId: customer.id,
            plan: planId,
            status: 'active',
            billingCycle,
            adsCreatedThisMonth: 0,
            dailyDownloadsUsed: 0,
            monthlyPaidDownloadsUsed: 0,
            lastDailyResetDate: new Date(),
            lastMonthlyResetDate: new Date()
          });

          if (!newMembership) {
            return res.status(500).json({ error: "Failed to create membership" });
          }

          await storage.updateShopCustomer(customer.id, { accountType: planId });
        } else {
          // Determine if this is an upgrade or downgrade
          const currentPlanDetails = await db
            .select()
            .from(shopMembershipPlans)
            .where(eq(shopMembershipPlans.planId, membership.plan))
            .limit(1);

          const currentPrice = currentPlanDetails.length > 0 
            ? parseFloat(membership.billingCycle === 'monthly' ? currentPlanDetails[0].monthlyPrice : currentPlanDetails[0].yearlyPrice)
            : 0;

          const isDowngrade = newPlanPrice < currentPrice;

          if (isDowngrade) {
            // DOWNGRADE: Schedule plan change for renewal date
            const renewalDate = membership.renewalDate || new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
            
            const updated = await storage.updateShopMembership(membership.id, { 
              scheduledPlan: planId,
              scheduledPlanDate: renewalDate,
              billingCycle: membership.billingCycle
            });

            if (!updated) {
              return res.status(500).json({ error: "Failed to schedule plan change" });
            }

            console.log(`ðŸ“… Scheduled downgrade from ${membership.plan} to ${planId} on ${renewalDate} (Card payment)`);
          } else {
            // UPGRADE: Apply immediately and reset all credits for new plan
            const updated = await storage.updateShopMembership(membership.id, { 
              plan: planId, 
              status: 'active',
              billingCycle,
              scheduledPlan: null,
              scheduledPlanDate: null,
              adsCreatedThisMonth: 0, // Reset ad credits
              dailyDownloadsUsed: 0, // Reset daily download counter
              monthlyPaidDownloadsUsed: 0, // Reset monthly download counter
              lastDailyResetDate: new Date(), // Reset daily reset date
              lastMonthlyResetDate: new Date() // Reset monthly reset date
            });

            if (!updated) {
              return res.status(500).json({ error: "Failed to update membership" });
            }

            await storage.updateShopCustomer(customer.id, { accountType: planId });

            console.log(`âœ… Immediately upgraded from ${membership.plan} to ${planId} (Card payment) - Credits reset to 0`);
          }
        }

        // Update transaction
        await db.update(shopTransactions)
          .set({ status: 'completed', updatedAt: new Date() })
          .where(eq(shopTransactions.id, transaction.id));

        // Create payment record for revenue tracking
        await db.insert(payments).values({
          userId,
          amount: transaction.amount,
          currency: 'USD',
          status: 'succeeded',
          planType: `Shop ${planId} (${billingCycle})`,
          stripePaymentIntentId: paymentIntentId,
          description: `Shop membership upgrade to ${planId}`,
          paymentMethod: 'card',
          processedAt: new Date()
        });

        // Send confirmation email
        try {
          const { emailService } = await import('./utils/email.js');
          const planDetails = await db
            .select()
            .from(shopMembershipPlans)
            .where(eq(shopMembershipPlans.planId, planId))
            .limit(1);
          
          const userProfile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
          const userEmail = userProfile[0]?.email || customer.email;
          
          if (userEmail && planDetails[0]) {
            await emailService.sendSubscriptionEmail(userEmail, {
              planName: planDetails[0].name,
              price: parseFloat(transaction.amount),
              billingCycle: billingCycle === 'monthly' ? 'Monthly' : 'Yearly',
              orderId: membership.id,
              customerName: customer.fullName || userProfile[0]?.name || undefined,
              features: planDetails[0].features || []
            });
          }
        } catch (emailError) {
          console.error('Failed to send membership email:', emailError);
        }

        // Fetch the updated membership to return
        const updatedMembership = await storage.getShopMembershipByCustomerId(customer.id);
        return res.json({ success: true, membership: updatedMembership });
      }

      return res.status(500).json({ error: "Payment verification failed" });

    } catch (error) {
      console.error('Confirm upgrade error:', error);
      res.status(500).json({ error: "Failed to confirm upgrade" });
    }
  });

  // Get wallet balance and info
  app.get("/api/shop/wallet", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ balance: '0.00' });
      }

      res.json({ balance: customer.walletBalance });
    } catch (error) {
      console.error('Get wallet error:', error);
      res.status(500).json({ error: "Failed to fetch wallet details" });
    }
  });

  // Get wallet transactions
  app.get("/api/shop/wallet/transactions", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json([]);
      }

      const transactions = await storage.getShopTransactionsByCustomerId(customer.id);
      res.json(transactions);
    } catch (error) {
      console.error('Get transactions error:', error);
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });

  // Create Stripe Payment Intent for embedded wallet top-up
  app.post("/api/shop/wallet/create-payment-intent", requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      
      // Get or create shop customer
      let customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        const profile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        customer = await storage.createShopCustomer({
          userId,
          fullName: profile[0]?.name || 'Customer',
          email: (req as AuthenticatedRequest).user?.email || ''
        });
      }

      const { amount } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }

      // Create Stripe payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(parseFloat(amount) * 100), // Convert to cents
        currency: 'usd',
        automatic_payment_methods: {
          enabled: true,
        },
        metadata: {
          customerId: customer.id,
          userId: userId,
          amount: amount,
          type: 'wallet_topup',
        },
      });

      // Store payment intent for later verification
      await storage.createShopTransaction({
        customerId: customer.id,
        amount: amount,
        type: 'add_funds',
        status: 'pending',
        description: `Wallet top-up $${amount}`,
        referenceId: paymentIntent.id,
      });

      res.json({ success: true, clientSecret: paymentIntent.client_secret });
    } catch (error) {
      console.error('Create payment intent error:', error);
      res.status(500).json({ error: "Failed to create payment intent" });
    }
  });

  // Confirm payment intent and update wallet balance
  app.post("/api/shop/wallet/confirm-payment", requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const { paymentIntentId } = req.body;
      
      if (!paymentIntentId) {
        return res.status(400).json({ error: "Payment intent ID is required" });
      }

      // Retrieve the payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      // Verify the payment intent belongs to this user
      if (paymentIntent.metadata?.userId !== userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      // Check if payment was successful
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: "Payment not successful" });
      }

      // Check if already processed
      const existingTransaction = await db
        .select()
        .from(shopTransactions)
        .where(eq(shopTransactions.referenceId, paymentIntentId))
        .limit(1);

      if (existingTransaction.length > 0 && existingTransaction[0].status === 'completed') {
        const customer = await storage.getShopCustomerByUserId(userId);
        return res.status(409).json({ 
          error: "Payment already processed",
          alreadyProcessed: true,
          balance: customer?.walletBalance || '0.00'
        });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer not found" });
      }

      const amount = paymentIntent.metadata?.amount;
      if (!amount) {
        return res.status(400).json({ error: "Invalid payment amount" });
      }

      // Update transaction status
      await db.update(shopTransactions)
        .set({ status: 'completed' })
        .where(eq(shopTransactions.referenceId, paymentIntentId));

      // Update wallet balance
      const newBalance = (parseFloat(customer.walletBalance) + parseFloat(amount)).toFixed(2);
      await storage.updateShopCustomer(customer.id, {
        walletBalance: newBalance
      });

      res.json({ success: true, newBalance });
    } catch (error) {
      console.error('Confirm payment error:', error);
      res.status(500).json({ error: "Failed to confirm payment" });
    }
  });

  // Create Stripe Checkout Session for wallet top-up (legacy)
  app.post("/api/shop/wallet/create-checkout-session", requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const { amount } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }

      // Create Stripe checkout session
      const baseUrl = process.env.REPLIT_DEV_DOMAIN 
        ? `https://${process.env.REPLIT_DEV_DOMAIN}` 
        : 'http://localhost:5000';
      
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: 'usd',
              product_data: {
                name: 'Wallet Top-Up',
                description: `Add $${amount} to your wallet balance`,
              },
              unit_amount: Math.round(parseFloat(amount) * 100), // Convert to cents
            },
            quantity: 1,
          },
        ],
        mode: 'payment',
        success_url: `${baseUrl}/customer-dashboard?payment=success&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${baseUrl}/customer-dashboard?payment=cancelled`,
        metadata: {
          customerId: customer.id,
          userId: userId,
          amount: amount,
          type: 'wallet_topup',
        },
      });

      res.json({ success: true, sessionId: session.id, url: session.url });
    } catch (error) {
      console.error('Create checkout session error:', error);
      res.status(500).json({ error: "Failed to create checkout session" });
    }
  });

  // Verify and process successful payment
  app.post("/api/shop/wallet/verify-payment", requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: "Payment processing is not configured" });
      }

      const userId = (req as AuthenticatedRequest).user?.id;
      const { sessionId } = req.body;
      
      if (!sessionId) {
        return res.status(400).json({ error: "Session ID is required" });
      }

      // CRITICAL: Check for duplicate processing FIRST, before calling Stripe
      const existingTransaction = await db
        .select()
        .from(shopTransactions)
        .where(eq(shopTransactions.referenceId, sessionId))
        .limit(1);

      if (existingTransaction.length > 0) {
        // Payment already processed - return current balance
        const customer = await storage.getShopCustomerByUserId(userId);
        return res.status(409).json({ 
          error: "Payment already processed",
          alreadyProcessed: true,
          balance: customer?.walletBalance || '0.00'
        });
      }

      // Retrieve the session from Stripe
      const session = await stripe.checkout.sessions.retrieve(sessionId);
      
      // Verify the session belongs to this user
      if (session.metadata?.userId !== userId) {
        return res.status(403).json({ error: "Unauthorized" });
      }

      // Check if payment was successful
      if (session.payment_status !== 'paid') {
        return res.status(400).json({ error: "Payment not completed" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const amount = session.metadata?.amount;
      if (!amount) {
        return res.status(400).json({ error: "Invalid payment data" });
      }

      // Create transaction record (this serves as our idempotency lock)
      try {
        await storage.createShopTransaction({
          customerId: customer.id,
          amount: amount,
          type: 'add_funds',
          description: `Added $${amount} to wallet via Stripe`,
          status: 'completed',
          referenceId: sessionId
        });
      } catch (dbError: any) {
        // Handle unique constraint violation (duplicate payment attempt)
        if (dbError.code === '23505' || dbError.message?.includes('unique')) {
          console.log(`Duplicate payment attempt blocked by database constraint: ${sessionId}`);
          return res.status(409).json({ 
            error: "Payment already processed",
            alreadyProcessed: true,
            balance: customer.walletBalance
          });
        }
        throw dbError; // Re-throw other database errors
      }

      // Update wallet balance
      const updated = await storage.updateWalletBalance(customer.id, parseFloat(amount));

      res.json({ success: true, newBalance: updated.walletBalance });
    } catch (error) {
      console.error('Verify payment error:', error);
      res.status(500).json({ error: "Failed to verify payment" });
    }
  });

  // Get support tickets (customer)
  app.get("/api/shop/support/tickets", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.json({ success: true, data: [] });
      }

      const tickets = await storage.getShopSupportTicketsByCustomerId(customer.id);
      res.json({ success: true, data: tickets });
    } catch (error) {
      console.error('Get tickets error:', error);
      res.status(500).json({ error: "Failed to fetch support tickets" });
    }
  });

  // Get all support tickets (admin only)
  app.get("/api/shop/support/tickets/all", requireAuth, requireAdmin, async (req, res) => {
    try {
      const tickets = await storage.getAllShopSupportTickets();
      
      const ticketsWithCustomerInfo = await Promise.all(
        tickets.map(async (ticket) => {
          const [customer] = await db.select().from(shopCustomers)
            .where(eq(shopCustomers.id, ticket.customerId))
            .limit(1);
          
          return {
            ...ticket,
            customerName: customer?.fullName || 'Unknown',
            customerEmail: customer?.email || 'Unknown'
          };
        })
      );
      
      res.json({ success: true, data: ticketsWithCustomerInfo });
    } catch (error) {
      console.error('Get all tickets error:', error);
      res.status(500).json({ error: "Failed to fetch all support tickets" });
    }
  });

  // Create support ticket
  app.post("/api/shop/support/tickets", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Extract only allowed fields, never trust customerId from client
      const { subject, message, category, priority } = req.body;

      // Validate required fields
      if (!subject || !message) {
        return res.status(400).json({ error: "Subject and message are required" });
      }

      const newTicket = await storage.createShopSupportTicket({
        customerId: customer.id, // Always use authenticated customer's ID
        subject,
        message,
        category: category || 'general',
        priority: priority || 'medium',
        status: 'open' // Always start as open
      });

      // Import email service for notifications
      try {
        const { emailService } = await import('./utils/email.js');
        
        // Send email notification to admin
        try {
          await emailService.sendEmail({
            to: 'support@edufiliova.com',
            subject: `New Support Ticket: ${subject}`,
            html: `
              <h2>New Support Ticket Submitted</h2>
              <p><strong>Customer:</strong> ${customer.fullName || customer.email}</p>
              <p><strong>Email:</strong> ${customer.email}</p>
              <p><strong>Subject:</strong> ${subject}</p>
              <p><strong>Category:</strong> ${category || 'general'}</p>
              <p><strong>Priority:</strong> ${priority || 'medium'}</p>
              <p><strong>Message:</strong></p>
              <p>${message}</p>
              <p><a href="${process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : 'http://localhost:5000'}/admin">View in Admin Panel</a></p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send admin notification email:', emailError);
        }

        // Send confirmation email to customer
        if (customer.email) {
          try {
            await emailService.sendEmail({
              to: customer.email,
              subject: `Support Ticket Received: ${subject}`,
              html: `
                <h2>Your Support Ticket Has Been Received</h2>
                <p>Hi ${customer.fullName || 'there'},</p>
                <p>We've received your support ticket and our team will respond within 24 hours.</p>
                <p><strong>Subject:</strong> ${subject}</p>
                <p><strong>Your Message:</strong></p>
                <p>${message}</p>
                <p>You can track your ticket status in your customer dashboard.</p>
                <br>
                <p>Best regards,<br>Support Team</p>
              `
            });
          } catch (emailError) {
            console.error('Failed to send customer confirmation email:', emailError);
          }
        }
      } catch (importError) {
        console.error('Failed to import email service:', importError);
      }

      res.json({ success: true, data: newTicket });
    } catch (error) {
      console.error('Create ticket error:', error);
      res.status(500).json({ error: "Failed to create support ticket" });
    }
  });

  // Update support ticket
  app.put("/api/shop/support/tickets/:id", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Verify ownership - check if ticket belongs to this customer
      const existingTicket = await storage.getShopSupportTicketById(id);
      if (!existingTicket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      if (existingTicket.customerId !== customer.id) {
        return res.status(403).json({ error: "Unauthorized to modify this ticket" });
      }

      // Customers can only update message field (to add more info)
      // Admin updates status/priority through admin panel
      const { message } = req.body;

      const updated = await storage.updateShopSupportTicket(id, {
        message
      });

      // If admin has replied to this ticket, send them a notification about customer's update
      if (existingTicket.adminEmail && existingTicket.adminReply) {
        try {
          const { emailService } = await import('./utils/email.js');
          await emailService.sendEmail({
            to: existingTicket.adminEmail,
            subject: `Customer Reply to Ticket: ${existingTicket.subject}`,
            html: `
              <h2>Customer Has Replied to Support Ticket</h2>
              <p>Hi ${existingTicket.adminName || 'there'},</p>
              <p>A customer has added a reply to a support ticket you responded to.</p>
              <br>
              <p><strong>Ticket Subject:</strong> ${existingTicket.subject}</p>
              <p><strong>Customer Name:</strong> ${customer.fullName || 'Unknown'}</p>
              <p><strong>Customer Email:</strong> ${customer.email || 'Unknown'}</p>
              <br>
              <p><strong>Your Previous Response:</strong></p>
              <p>${existingTicket.adminReply}</p>
              <br>
              <p><strong>Customer's New Message:</strong></p>
              <p>${message}</p>
              <br>
              <p>You can view and respond to this ticket in the admin dashboard.</p>
              <br>
              <p>Best regards,<br>EduFiliova Support System</p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send admin notification email:', emailError);
        }
      }

      res.json({ success: true, data: updated });
    } catch (error) {
      console.error('Update ticket error:', error);
      res.status(500).json({ error: "Failed to update support ticket" });
    }
  });

  // Admin reply to support ticket (admin only)
  app.post("/api/shop/support/tickets/:id/reply", requireAuth, async (req, res) => {
    try {
      const { id } = req.params;
      const { reply, adminName, adminEmail } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;
      const userEmail = (req as AuthenticatedRequest).user?.email;
      
      if (!reply) {
        return res.status(400).json({ error: "Reply message is required" });
      }

      // Get ticket
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      // Get customer info
      const customer = await db.select().from(shopCustomers).where(eq(shopCustomers.id, ticket.customerId)).limit(1);
      if (!customer[0]) {
        return res.status(404).json({ error: "Customer not found" });
      }

      // Update ticket with admin reply and store admin info
      const updatedTicket = await storage.updateShopSupportTicket(id, {
        adminReply: reply,
        adminName: adminName || 'Support Team',
        adminEmail: adminEmail || userEmail || 'support@edufiliova.com',
        status: 'responded'
      });

      // Send email notification to customer
      if (customer[0].email) {
        try {
          const { emailService } = await import('./utils/email.js');
          await emailService.sendEmail({
            to: customer[0].email,
            subject: `Support Team Response: ${ticket.subject}`,
            html: `
              <h2>Support Team Has Responded to Your Ticket</h2>
              <p>Hi ${customer[0].fullName || 'there'},</p>
              <p><strong>Your Original Message:</strong></p>
              <p>${ticket.message}</p>
              <br>
              <p><strong>Support Team Response:</strong></p>
              <p>${reply}</p>
              <br>
              <p>You can reply to this ticket in your customer dashboard or by replying to this email.</p>
              <br>
              <p>Best regards,<br>${adminName || 'Support Team'}</p>
            `
          });
        } catch (emailError) {
          console.error('Failed to send customer reply email:', emailError);
        }
      }

      res.json({ success: true, data: updatedTicket });
    } catch (error) {
      console.error('Reply to ticket error:', error);
      res.status(500).json({ error: "Failed to reply to support ticket" });
    }
  });

  // Close/Resolve support ticket (admin only)
  app.put("/api/shop/support/tickets/:id/close", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      const updatedTicket = await storage.updateShopSupportTicket(id, {
        status: 'resolved'
      });

      res.json({ success: true, data: updatedTicket });
    } catch (error) {
      console.error('Close ticket error:', error);
      res.status(500).json({ error: "Failed to close support ticket" });
    }
  });

  // Delete support ticket (admin only)
  app.delete("/api/shop/support/tickets/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const ticket = await storage.getShopSupportTicketById(id);
      if (!ticket) {
        return res.status(404).json({ error: "Ticket not found" });
      }

      await storage.deleteShopSupportTicket(id);

      res.json({ success: true, message: "Ticket deleted successfully" });
    } catch (error) {
      console.error('Delete ticket error:', error);
      res.status(500).json({ error: "Failed to delete support ticket" });
    }
  });

  // Voucher Management Routes

  // Create voucher (admin only)
  app.post("/api/admin/vouchers", requireAuth, requireAdmin, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { code, amount, description, maxRedemptions, expiresAt } = req.body;

      if (!code || !amount) {
        return res.status(400).json({ error: "Code and amount are required" });
      }

      const existingVoucher = await storage.getVoucherByCode(code.toUpperCase());
      if (existingVoucher) {
        return res.status(400).json({ error: "A voucher with this code already exists" });
      }

      const voucher = await storage.createVoucher({
        code: code.toUpperCase(),
        amount: amount.toString(),
        description,
        maxRedemptions: maxRedemptions || null,
        expiresAt: expiresAt ? new Date(expiresAt) : null,
        isActive: true,
        createdBy: userId,
      });

      res.json(voucher);
    } catch (error) {
      console.error('Create voucher error:', error);
      res.status(500).json({ error: "Failed to create voucher" });
    }
  });

  // Get all vouchers (admin only)
  app.get("/api/admin/vouchers", requireAuth, requireAdmin, async (req, res) => {
    try {
      const vouchers = await storage.getVouchers();
      res.json(vouchers);
    } catch (error) {
      console.error('Get vouchers error:', error);
      res.status(500).json({ error: "Failed to fetch vouchers" });
    }
  });

  // Delete voucher (admin only)
  app.delete("/api/admin/vouchers/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await storage.deleteVoucher(id);
      
      if (!deleted) {
        return res.status(404).json({ error: "Voucher not found" });
      }

      res.json({ success: true, message: "Voucher deleted successfully" });
    } catch (error) {
      console.error('Delete voucher error:', error);
      res.status(500).json({ error: "Failed to delete voucher" });
    }
  });

  // Get voucher redemptions (admin only)
  app.get("/api/admin/vouchers/:id/redemptions", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const redemptions = await storage.getVoucherRedemptions(id);
      res.json(redemptions);
    } catch (error) {
      console.error('Get redemptions error:', error);
      res.status(500).json({ error: "Failed to fetch redemptions" });
    }
  });

  // Redeem voucher (authenticated users)
  app.post("/api/shop/vouchers/redeem", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { code } = req.body;

      if (!code) {
        return res.status(400).json({ error: "Voucher code is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const normalizedCode = code.toUpperCase();
      
      // First check shop_vouchers table
      const voucher = await storage.getVoucherByCode(normalizedCode);
      
      if (voucher) {
        // Handle shop voucher redemption
        if (!voucher.isActive) {
          return res.status(400).json({ error: "This voucher is no longer active" });
        }

        if (voucher.expiresAt && new Date(voucher.expiresAt) < new Date()) {
          return res.status(400).json({ error: "This voucher has expired" });
        }

        if (voucher.maxRedemptions && voucher.currentRedemptions >= voucher.maxRedemptions) {
          return res.status(400).json({ error: "This voucher has reached its redemption limit" });
        }

        const existingRedemptions = await storage.getVoucherRedemptions(voucher.id);
        const alreadyRedeemed = existingRedemptions.some(r => r.customerId === customer.id);
        if (alreadyRedeemed) {
          return res.status(400).json({ error: "You have already redeemed this voucher" });
        }

        await storage.redeemVoucher(voucher.id, customer.id, voucher.amount);

        const currentBalance = parseFloat(customer.walletBalance || '0');
        const voucherAmount = parseFloat(voucher.amount);
        const newBalance = currentBalance + voucherAmount;
        await storage.updateWalletBalance(customer.id, newBalance);

        await storage.createShopTransaction({
          customerId: customer.id,
          amount: voucher.amount,
          type: 'add_funds',
          description: `Voucher redeemed: ${normalizedCode}`,
          status: 'completed',
          referenceId: `voucher_${voucher.id}`,
        });

        return res.json({ 
          success: true, 
          message: `Voucher redeemed! $${voucher.amount} added to your wallet`,
          newBalance: newBalance.toFixed(2)
        });
      }
      
      // Check gift_voucher_purchases table for wallet-purchased vouchers
      const [giftVoucher] = await db.select()
        .from(giftVoucherPurchases)
        .where(eq(giftVoucherPurchases.code, normalizedCode))
        .limit(1);
      
      if (giftVoucher) {
        // Check if payment was completed
        if (giftVoucher.paymentStatus !== 'completed') {
          return res.status(400).json({ error: "This voucher payment has not been completed" });
        }
        
        // Check if already redeemed
        if (giftVoucher.isRedeemed) {
          return res.status(400).json({ error: "This voucher has already been redeemed" });
        }
        
        // Check if expired
        if (giftVoucher.expiresAt && new Date(giftVoucher.expiresAt) < new Date()) {
          return res.status(400).json({ error: "This voucher has expired" });
        }
        
        // Mark as redeemed
        await db.update(giftVoucherPurchases)
          .set({ 
            isRedeemed: true, 
            redeemedAt: new Date(),
            redeemedBy: userId
          })
          .where(eq(giftVoucherPurchases.id, giftVoucher.id));
        
        // Add to wallet
        const currentBalance = parseFloat(customer.walletBalance || '0');
        const voucherAmount = parseFloat(giftVoucher.amount);
        const newBalance = currentBalance + voucherAmount;
        await storage.updateWalletBalance(customer.id, newBalance);
        
        // Create transaction record
        await storage.createShopTransaction({
          customerId: customer.id,
          amount: giftVoucher.amount,
          type: 'add_funds',
          description: `Gift voucher redeemed: ${normalizedCode}`,
          status: 'completed',
          referenceId: `gift_voucher_${giftVoucher.id}`,
        });
        
        return res.json({ 
          success: true, 
          message: `Gift voucher redeemed! $${giftVoucher.amount} added to your wallet`,
          newBalance: newBalance.toFixed(2)
        });
      }
      
      // No voucher found in either table
      return res.status(404).json({ error: "Invalid voucher code" });
      
    } catch (error: any) {
      console.error('Redeem voucher error:', error);
      if (error.message && error.message.includes('unique')) {
        return res.status(400).json({ error: "You have already redeemed this voucher" });
      }
      res.status(500).json({ error: "Failed to redeem voucher" });
    }
  });



  // ============ GIFT VOUCHER PURCHASE ROUTES ============

  // Create payment intent for gift voucher purchase
  app.post("/api/gift-vouchers/create-payment-intent", optionalAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }

      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }

      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      // Get Stripe instance
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: "Payment service not configured" });
      }

      // Create payment intent
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(amount * 100), // Convert to cents
        currency: 'usd',
        metadata: {
          type: 'gift_voucher',
          buyerId: userId || 'guest',
          buyerEmail: buyerEmail || '',
          buyerName: buyerName || '',
          recipientEmail,
          recipientName: recipientName || '',
          personalMessage: personalMessage || '',
          sendToSelf: sendToSelf ? 'true' : 'false',
          amount: amount.toString()
        }
      });

      // Create pending purchase record
      const [purchase] = await db.insert(giftVoucherPurchases).values({
        buyerId: userId || null,
        buyerEmail: buyerEmail || 'guest@edufiliova.com',
        buyerName: buyerName || null,
        recipientEmail,
        recipientName: recipientName || null,
        amount: amount.toString(),
        personalMessage: personalMessage || null,
        sendToSelf: sendToSelf || false,
        paymentIntentId: paymentIntent.id,
        paymentStatus: 'pending'
      }).returning();

      res.json({
        clientSecret: paymentIntent.client_secret,
        purchaseId: purchase.id
      });
    } catch (error: any) {
      console.error('Gift voucher payment intent error:', error);
      res.status(500).json({ error: error.message || "Failed to create payment" });
    }
  });

  // Confirm gift voucher purchase after payment
  app.post("/api/gift-vouchers/confirm-purchase", async (req, res) => {
    try {
      const { paymentIntentId, purchaseId, paymentMethod } = req.body;

      if (!paymentIntentId || !purchaseId) {
        return res.status(400).json({ error: "Payment intent ID and purchase ID required" });
      }

      // For Stripe payments, verify with Stripe API
      // For PayPal/Paystack, the payment is already verified in the callback handler
      if (!paymentMethod || paymentMethod === 'stripe' || paymentMethod === 'card') {
        const stripe = await getStripeInstance();
        if (!stripe) {
          return res.status(500).json({ error: "Payment service not configured" });
        }

        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        if (paymentIntent.status !== 'succeeded') {
          return res.status(400).json({ error: "Payment not completed" });
        }
      }

      // Get the purchase record
      const [purchase] = await db.select().from(giftVoucherPurchases).where(eq(giftVoucherPurchases.id, purchaseId));
      if (!purchase) {
        return res.status(404).json({ error: "Purchase not found" });
      }

      if (purchase.paymentStatus === 'completed') {
        return res.status(400).json({ error: "Purchase already completed" });
      }

      // Generate voucher code (14 characters)
      const generateCode = () => {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = 'GIFT-';
        for (let i = 0; i < 10; i++) {
          code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return code;
      };

      let voucherCode = generateCode();
      
      // Make sure code is unique
      let attempts = 0;
      while (attempts < 10) {
        const existing = await db.select().from(shopVouchers).where(eq(shopVouchers.code, voucherCode));
        if (existing.length === 0) break;
        voucherCode = generateCode();
        attempts++;
      }

      // Calculate expiry (1 year from now)
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      // Create the voucher
      const [voucher] = await db.insert(shopVouchers).values({
        code: voucherCode,
        amount: purchase.amount,
        description: purchase.personalMessage ? `Gift Voucher: ${purchase.personalMessage}` : 'Gift Voucher',
        maxRedemptions: 1,
        currentRedemptions: 0,
        expiresAt,
        isActive: true,
        recipientName: purchase.recipientName,
        recipientEmail: purchase.recipientEmail,
        createdBy: purchase.buyerId || null as any
      }).returning();

      // Update purchase record
      await db.update(giftVoucherPurchases)
        .set({
          voucherId: voucher.id,
          paymentStatus: 'completed',
          paymentMethod: 'stripe'
        })
        .where(eq(giftVoucherPurchases.id, purchaseId));

      // Send email to recipient
      try {
        const { sendVoucherEmail } = await import('./utils/email.js');
        await sendVoucherEmail({
          recipientEmail: purchase.recipientEmail,
          recipientName: purchase.recipientName || undefined,
          voucherCode,
          amount: parseFloat(purchase.amount),
          personalMessage: purchase.personalMessage || undefined,
          senderName: purchase.buyerName || 'Someone special',
          expiresAt: expiresAt.toISOString()
        });

        // Mark email as sent
        await db.update(giftVoucherPurchases)
          .set({
            emailSent: true,
            emailSentAt: new Date()
          })
          .where(eq(giftVoucherPurchases.id, purchaseId));
      } catch (emailError) {
        console.error('Failed to send voucher email:', emailError);
        // Don't fail the request if email fails
      }

      res.json({
        success: true,
        voucherCode,
        amount: purchase.amount,
        recipientEmail: purchase.recipientEmail,
        expiresAt: expiresAt.toISOString()
      });
    } catch (error: any) {
      console.error('Gift voucher confirmation error:', error);
      res.status(500).json({ error: error.message || "Failed to confirm purchase" });
    }
  });


  // Create gift voucher purchase record (for PayPal/Paystack - no Stripe intent)
  app.post("/api/gift-vouchers/create-purchase", optionalAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }
      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }
      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      const voucherCode = generateVoucherCode();
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      const [purchase] = await db.insert(giftVoucherPurchases).values({
        code: voucherCode,
        amount: amount.toString(),
        recipientEmail,
        recipientName: recipientName || null,
        personalMessage: personalMessage || null,
        buyerId: userId || null,
        buyerEmail: buyerEmail || null,
        buyerName: buyerName || null,
        sendToSelf: sendToSelf || false,
        paymentStatus: 'pending',
        expiresAt
      }).returning();

      res.json({
        purchaseId: purchase.id,
        voucherCode,
        amount: purchase.amount
      });
    } catch (error: any) {
      console.error('Create gift voucher purchase error:', error);
      res.status(500).json({ error: error.message || "Failed to create purchase" });
    }
  });

  // Purchase gift voucher with wallet balance
  app.post("/api/gift-vouchers/purchase-with-wallet", requireAuth, async (req, res) => {
    try {
      const { amount, recipientEmail, recipientName, personalMessage, sendToSelf, buyerEmail, buyerName } = req.body;
      const userId = (req as AuthenticatedRequest).user?.id;

      if (!amount || amount < 5) {
        return res.status(400).json({ error: "Minimum voucher amount is $5" });
      }
      if (amount > 500) {
        return res.status(400).json({ error: "Maximum voucher amount is $500" });
      }
      if (!recipientEmail) {
        return res.status(400).json({ error: "Recipient email is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(400).json({ error: "Customer account not found" });
      }

      const walletBalance = parseFloat(customer.walletBalance || '0');
      if (walletBalance < amount) {
        return res.status(400).json({ 
          error: "Insufficient wallet balance",
          required: amount,
          available: walletBalance
        });
      }

      const voucherCode = generateVoucherCode();
      const expiresAt = new Date();
      expiresAt.setFullYear(expiresAt.getFullYear() + 1);

      await storage.updateWalletBalance(customer.id, -amount);

      const [purchase] = await db.insert(giftVoucherPurchases).values({
        code: voucherCode,
        amount: amount.toString(),
        recipientEmail,
        recipientName: recipientName || null,
        personalMessage: personalMessage || null,
        buyerId: userId,
        buyerEmail: buyerEmail || null,
        buyerName: buyerName || null,
        sendToSelf: sendToSelf || false,
        paymentStatus: 'completed',
        paymentMethod: 'wallet',
        expiresAt
      }).returning();

      try {
        const { sendGiftVoucherEmail } = await import('./utils/email-templates.js');
        await sendGiftVoucherEmail(
          recipientEmail,
          recipientName || 'Friend',
          buyerName || 'Someone',
          voucherCode,
          parseFloat(amount.toString()),
          personalMessage || undefined
        );
      } catch (emailError) {
        console.error('Failed to send gift voucher email:', emailError);
      }

      res.json({
        success: true,
        voucherCode,
        amount: purchase.amount,
        recipientEmail: purchase.recipientEmail,
        expiresAt: purchase.expiresAt
      });
    } catch (error: any) {
      console.error('Wallet gift voucher purchase error:', error);
      res.status(500).json({ error: error.message || "Failed to process wallet payment" });
    }
  });
  // Get user's purchased gift vouchers
  app.get("/api/gift-vouchers/my-purchases", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;

      const purchases = await db.select()
        .from(giftVoucherPurchases)
        .where(
          and(
            eq(giftVoucherPurchases.buyerId, userId),
            eq(giftVoucherPurchases.paymentStatus, 'completed')
          )
        )
        .orderBy(desc(giftVoucherPurchases.createdAt));

      res.json(purchases);
    } catch (error: any) {
      console.error('Get gift voucher purchases error:', error);
      res.status(500).json({ error: "Failed to fetch purchases" });
    }
  });

  // ============ END GIFT VOUCHER PURCHASE ROUTES ============


  // Get customer profile
  app.get("/api/shop/profile", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      let customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        const profile = await db.select().from(profiles).where(eq(profiles.userId, userId)).limit(1);
        customer = await storage.createShopCustomer({
          userId,
          fullName: profile[0]?.name || 'Customer',
          email: (req as AuthenticatedRequest).user?.email || ''
        });
      }

      res.json(customer);
    } catch (error) {
      console.error('Get profile error:', error);
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  // Update customer profile
  app.put("/api/shop/profile", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      const updated = await storage.updateShopCustomer(customer.id, req.body);
      
      // Also update country in profiles table if provided
      if (req.body.country) {
        // Find country ID
        const countryRecord = await db
          .select()
          .from(countries)
          .where(eq(countries.name, req.body.country))
          .limit(1);

        await db
          .update(profiles)
          .set({
            country: req.body.country,
            countryId: countryRecord.length > 0 ? countryRecord[0].id : null
          })
          .where(eq(profiles.userId, userId));
      }
      
      res.json(updated);
    } catch (error) {
      console.error('Update profile error:', error);
      res.status(500).json({ error: "Failed to update profile" });
    }
  });

  // Get referral stats
  app.get("/api/shop/referral", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Generate referral code if not exists
      if (!customer.referralCode) {
        const code = Math.random().toString(36).substring(2, 10).toUpperCase();
        await storage.updateShopCustomer(customer.id, { referralCode: code });
        customer.referralCode = code;
      }

      // Calculate reward status
      const referralCount = customer.referralCount || 0;
      const rewardThreshold = 50;
      const rewardAmount = 15;
      const earnedRewards = Math.floor(referralCount / rewardThreshold) * rewardAmount;
      const nextRewardAt = (Math.floor(referralCount / rewardThreshold) + 1) * rewardThreshold;
      const referralsToNextReward = nextRewardAt - referralCount;

      const referralLink = `${req.protocol}://${req.get('host')}?ref=${customer.referralCode}`;

      res.json({
        success: true,
        data: {
          referralCode: customer.referralCode,
          referralLink,
          referralCount,
          earnedRewards,
          rewardThreshold,
          rewardAmount,
          referralsToNextReward: referralsToNextReward > 0 ? referralsToNextReward : 0,
        }
      });
    } catch (error) {
      console.error('Get referral stats error:', error);
      res.status(500).json({ error: "Failed to fetch referral stats" });
    }
  });

  // Track referral (when someone signs up with a referral code)
  app.post("/api/shop/referral/track", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { referralCode } = req.body;

      if (!referralCode) {
        return res.status(400).json({ error: "Referral code is required" });
      }

      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return res.status(404).json({ error: "Customer profile not found" });
      }

      // Check if already referred
      if (customer.referredBy) {
        return res.status(400).json({ error: "You have already been referred" });
      }

      // Find referrer by code
      const referrer = await db
        .select()
        .from(shopCustomers)
        .where(eq(shopCustomers.referralCode, referralCode))
        .limit(1);

      if (referrer.length === 0) {
        return res.status(404).json({ error: "Invalid referral code" });
      }

      if (referrer[0].id === customer.id) {
        return res.status(400).json({ error: "You cannot refer yourself" });
      }

      // Update customer with referrer
      await storage.updateShopCustomer(customer.id, { referredBy: referrer[0].id });

      // Increment referrer's count
      const newCount = (referrer[0].referralCount || 0) + 1;
      await storage.updateShopCustomer(referrer[0].id, { referralCount: newCount });

      // Check if referrer reached threshold and award $15
      if (newCount % 50 === 0) {
        const newBalance = parseFloat(referrer[0].walletBalance || '0') + 15;
        await storage.updateShopCustomer(referrer[0].id, { 
          walletBalance: newBalance.toFixed(2)
        });

        // Record transaction
        await storage.createShopTransaction({
          customerId: referrer[0].id,
          type: 'credit',
          amount: '15.00',
          description: `Referral reward for ${newCount} referrals`,
          status: 'completed'
        });
      }

      res.json({ success: true, message: "Referral tracked successfully" });
    } catch (error) {
      console.error('Track referral error:', error);
      res.status(500).json({ error: "Failed to track referral" });
    }
  });

  // Get all active membership plans (public - for pricing page)
  app.get("/api/shop/membership-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.active, true))
        .orderBy(asc(shopMembershipPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error) {
      console.error('Get membership plans error:', error);
      res.status(500).json({ error: "Failed to fetch membership plans" });
    }
  });

  // Get single membership plan by planId
  app.get("/api/shop/membership-plans/:planId", async (req, res) => {
    try {
      const { planId } = req.params;
      const plan = await db
        .select()
        .from(shopMembershipPlans)
        .where(and(
          eq(shopMembershipPlans.planId, planId),
          eq(shopMembershipPlans.active, true)
        ))
        .limit(1);
      
      if (plan.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json(plan[0]);
    } catch (error) {
      console.error('Get membership plan error:', error);
      res.status(500).json({ error: "Failed to fetch membership plan" });
    }
  });

  // Admin: Get all membership plans (including inactive)
  app.get("/api/admin/membership-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(shopMembershipPlans)
        .orderBy(asc(shopMembershipPlans.displayOrder));
      
      res.json(plans);
    } catch (error) {
      console.error('Admin get membership plans error:', error);
      res.status(500).json({ error: "Failed to fetch membership plans" });
    }
  });

  // Admin: Create new membership plan
  app.post("/api/admin/membership-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      
      const validatedData = insertShopMembershipPlanSchema.parse(bodyData);
      
      // Validate annualAdLimit is null or non-negative
      if (validatedData.annualAdLimit !== null && 
          validatedData.annualAdLimit !== undefined && 
          validatedData.annualAdLimit < 0) {
        return res.status(400).json({ error: "Annual ad limit cannot be negative" });
      }
      
      const newPlan = await db.insert(shopMembershipPlans).values(validatedData).returning();
      res.json(newPlan[0]);
    } catch (error) {
      console.error('Admin create membership plan error:', error);
      res.status(500).json({ error: "Failed to create membership plan" });
    }
  });

  // Admin: Update membership plan
  app.put("/api/admin/membership-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      
      const validatedData = insertShopMembershipPlanSchema.partial().parse(bodyData);
      
      // Validate annualAdLimit is null or non-negative
      if (validatedData.annualAdLimit !== null && 
          validatedData.annualAdLimit !== undefined && 
          validatedData.annualAdLimit < 0) {
        return res.status(400).json({ error: "Annual ad limit cannot be negative" });
      }
      
      const updated = await db
        .update(shopMembershipPlans)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(shopMembershipPlans.id, id))
        .returning();
      
      if (updated.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json(updated[0]);
    } catch (error) {
      console.error('Admin update membership plan error:', error);
      res.status(500).json({ error: "Failed to update membership plan" });
    }
  });

  // Admin: Delete membership plan
  app.delete("/api/admin/membership-plans/:id", requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await db
        .delete(shopMembershipPlans)
        .where(eq(shopMembershipPlans.id, id))
        .returning();
      
      if (deleted.length === 0) {
        return res.status(404).json({ error: "Plan not found" });
      }
      
      res.json({ message: "Plan deleted successfully" });
    } catch (error) {
      console.error('Admin delete membership plan error:', error);
      res.status(500).json({ error: "Failed to delete membership plan" });
    }
  });

  // ============ FREELANCER PRICING PLANS API ROUTES ============
  
  // Public: Get all active freelancer pricing plans
  app.get("/api/freelancer-pricing-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.active, true))
        .orderBy(asc(freelancerPricingPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error) {
      console.error('Get freelancer pricing plans error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch freelancer pricing plans" });
    }
  });

  // Admin: Get all freelancer pricing plans (including inactive)
  app.get("/api/admin/freelancer-pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(freelancerPricingPlans)
        .orderBy(asc(freelancerPricingPlans.displayOrder));
      
      res.json({ success: true, data: plans });
    } catch (error) {
      console.error('Admin get freelancer pricing plans error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch freelancer pricing plans" });
    }
  });

  // Admin: Create new freelancer pricing plan
  app.post("/api/admin/freelancer-pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const bodyData = { ...req.body };
      
      // Transform numeric prices to strings if needed
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      if (bodyData.lifetimePrice !== undefined && typeof bodyData.lifetimePrice === 'number') {
        bodyData.lifetimePrice = bodyData.lifetimePrice.toString();
      }
      
      const validatedData = insertFreelancerPricingPlanSchema.parse(bodyData);
      
      const newPlan = await db.insert(freelancerPricingPlans).values(validatedData).returning();
      res.json({ success: true, data: newPlan[0] });
    } catch (error) {
      console.error('Admin create freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to create freelancer pricing plan" });
    }
  });

  // Admin: Update freelancer pricing plan
  app.put("/api/admin/freelancer-pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const bodyData = { ...req.body };
      
      // Transform numeric prices to strings if needed
      if (bodyData.monthlyPrice !== undefined && typeof bodyData.monthlyPrice === 'number') {
        bodyData.monthlyPrice = bodyData.monthlyPrice.toString();
      }
      if (bodyData.yearlyPrice !== undefined && typeof bodyData.yearlyPrice === 'number') {
        bodyData.yearlyPrice = bodyData.yearlyPrice.toString();
      }
      if (bodyData.lifetimePrice !== undefined && typeof bodyData.lifetimePrice === 'number') {
        bodyData.lifetimePrice = bodyData.lifetimePrice.toString();
      }
      
      const validatedData = insertFreelancerPricingPlanSchema.partial().parse(bodyData);
      
      const updated = await db
        .update(freelancerPricingPlans)
        .set({ ...validatedData, updatedAt: new Date() })
        .where(eq(freelancerPricingPlans.id, id))
        .returning();
      
      if (updated.length === 0) {
        return res.status(404).json({ success: false, error: "Plan not found" });
      }
      
      res.json({ success: true, data: updated[0] });
    } catch (error) {
      console.error('Admin update freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to update freelancer pricing plan" });
    }
  });

  // Admin: Delete freelancer pricing plan
  app.delete("/api/admin/freelancer-pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const deleted = await db
        .delete(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.id, id))
        .returning();
      
      if (deleted.length === 0) {
        return res.status(404).json({ success: false, error: "Plan not found" });
      }
      
      res.json({ success: true, message: "Plan deleted successfully" });
    } catch (error) {
      console.error('Admin delete freelancer pricing plan error:', error);
      res.status(500).json({ success: false, error: "Failed to delete freelancer pricing plan" });
    }
  });

  app.post("/api/freelancer/verify-email", async (req, res) => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        return res.status(400).json({ success: false, error: "Email and verification code are required" });
      }

      // Find verification code
      const verification = await db
        .select()
        .from(verificationCodes)
        .where(
          and(
            eq(verificationCodes.contactInfo, email),
            eq(verificationCodes.type, 'email'),
            eq(verificationCodes.isUsed, false)
          )
        )
        .limit(1);

      if (verification.length === 0) {
        return res.status(400).json({ success: false, error: "Invalid or expired verification code" });
      }

      // Check if code matches and hasn't expired
      if (verification[0].code !== code || new Date() > verification[0].expiresAt) {
        return res.status(400).json({ success: false, error: "Invalid or expired verification code" });
      }

      const userData = verification[0].userData as any;

      // Generate unique user ID
      let userIdToUse = generateUserId();

      // Create user
      const newUser = await db.insert(users).values({
        userId: userIdToUse,
        email: userData.email,
        passwordHash: userData.passwordHash,
        isEmailVerified: true,
        isPhoneVerified: true
      }).returning();

      // Create profile
      const newProfile = await db.insert(profiles).values({
        userId: newUser[0].id,
        name: userData.name,
        age: userData.age,
        grade: userData.grade,
        educationLevel: userData.educationLevel,
        country: userData.country,
        role: 'freelancer',
        status: 'active'
      }).returning();

      // Mark verification as used
      await db
        .update(verificationCodes)
        .set({ isUsed: true })
        .where(eq(verificationCodes.id, verification[0].id));

      // Send welcome email
      await sendEmail(
        userData.email,
        'Welcome to EduFiliova Freelancer Platform!',
        getEmailTemplate('welcome', { 
          name: userData.name,
          loginUrl: `${req.protocol}://${req.get('host')}`
        })
      );

      res.json({
        success: true,
        message: "Email verified successfully! Your freelancer account has been created.",
        user: {
          id: newUser[0].id,
          userId: newUser[0].userId,
          email: newUser[0].email
        },
        profile: newProfile[0]
      });

    } catch (error) {
      console.error('Freelancer email verification error:', error);
      res.status(500).json({ success: false, error: "Verification failed" });
    }
  });

  // Convert existing user to freelancer
  app.post("/api/user/convert-to-freelancer", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ success: false, error: "Not authenticated" });
      }

      // Update user profile to freelancer role
      await db
        .update(profiles)
        .set({ role: 'freelancer' })
        .where(eq(profiles.userId, userId));

      // Get updated profile
      const updatedProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      res.json({
        success: true,
        message: "Successfully converted to freelancer account",
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Convert to freelancer error:', error);
      res.status(500).json({ success: false, error: "Conversion failed" });
    }
  });

  // User settings endpoint
  app.post('/api/user/settings', async (req, res) => {
    try {
      const { userId, ...settings } = req.body;
      
      if (!userId) {
        return res.status(400).json({ error: 'User ID is required' });
      }

      // Check if user settings exist
      const existingSettings = await db
        .select()
        .from(userOtherSettings)
        .where(eq(userOtherSettings.userId, userId))
        .limit(1);

      if (existingSettings.length === 0) {
        // Create new settings
        await db.insert(userOtherSettings).values({
          userId,
          ...settings,
          updatedAt: new Date()
        });
      } else {
        // Update existing settings
        await db
          .update(userOtherSettings)
          .set({
            ...settings,
            updatedAt: new Date()
          })
          .where(eq(userOtherSettings.userId, userId));
      }

      res.json({ success: true });
    } catch (error) {
      console.error('Error updating user settings:', error);
      res.status(500).json({ error: 'Failed to update settings' });
    }
  });

  // =======================
  // CHAT THREAD API ROUTES
  // =======================

  // Helper function to check subscription limits for freelancer contact
  // Uses storage interface for consistent data access
  const checkContactLimits = async (userId: string) => {
    // Get user's subscription using storage interface
    const subscription = await storage.getUserActiveSubscription(userId);

    // Default limits for different plans
    const planLimits = {
      free: { threadsPerDay: 2, messagesPerDay: 10 },
      basic: { threadsPerDay: 10, messagesPerDay: 100 },
      premium: { threadsPerDay: -1, messagesPerDay: -1 }, // unlimited
      pro: { threadsPerDay: -1, messagesPerDay: -1 } // unlimited
    };

    const plan = subscription?.planName || 'free';
    const limits = planLimits[plan as keyof typeof planLimits] || planLimits.free;

    // Check today's usage using storage interface
    const threadsToday = await storage.getTodayThreadCount(userId);
    const messagesToday = await storage.getTodayMessageCount(userId);

    return {
      canCreateThread: limits.threadsPerDay === -1 || threadsToday < limits.threadsPerDay,
      canSendMessage: limits.messagesPerDay === -1 || messagesToday < limits.messagesPerDay,
      plan,
      usage: {
        threadsToday,
        messagesToday
      },
      limits
    };
  };


  // Create or get chat thread
  app.post('/api/chat/threads', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Validate request body using Zod schema
      const validatedData = insertChatThreadSchema.omit({ id: true, createdAt: true, updatedAt: true }).parse(req.body);
      const { freelancerId, customerId, projectId } = validatedData;
      
      // Verify user is either the freelancer or customer (use profile ID)
      if (req.user!.profile.id !== freelancerId && req.user!.profile.id !== customerId) {
        return res.status(403).json({ success: false, error: 'Not authorized to create this thread' });
      }

      // Check subscription limits for customers contacting freelancers
      if (req.user!.profile.id === customerId) {
        const limits = await checkContactLimits(req.user!.profile.id); // Use profile ID for consistent ID domain
        if (!limits.canCreateThread) {
          return res.status(429).json({ 
            success: false, 
            error: 'Daily thread limit reached. Please upgrade your plan for more contacts.',
            limits: limits.limits,
            usage: limits.usage
          });
        }
      }

      // Use storage interface to get or create thread
      const thread = await storage.getOrCreateChatThread(freelancerId, customerId, projectId);
      
      res.json({ success: true, data: thread });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Create chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to create chat thread' });
    }
  });

  // Get user's chat threads
  app.get('/api/chat/threads', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      // Use profile ID for consistent user identification
      const threads = await storage.getChatThreadsByUser(req.user!.profile.id);
      
      // Get thread previews with last message and participant info
      const threadsWithDetails = await Promise.all(threads.map(async (thread) => {
        const messages = await storage.getMessagesByThread(thread.id, { limit: 1 });
        const participants = await storage.getChatParticipantsByThread(thread.id);
        
        return {
          ...thread,
          lastMessage: messages[0] || null,
          participants
        };
      }));

      res.json({ success: true, data: threadsWithDetails });
    } catch (error) {
      console.error('Get chat threads error:', error);
      res.status(500).json({ success: false, error: 'Failed to get chat threads' });
    }
  });

  // Send message to thread
  app.post('/api/chat/threads/:threadId/messages', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body using Zod schema
      const validatedData = insertMessageSchema.omit({ 
        id: true, 
        createdAt: true, 
        updatedAt: true, 
        senderId: true, 
        threadId: true 
      }).parse(req.body);
      
      const { content, fileType } = validatedData;

      if (!content?.trim()) {
        return res.status(400).json({ success: false, error: 'Message content is required' });
      }

      // Verify user is a participant in this thread
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to send messages in this thread' });
      }

      // Check subscription limits using profile ID for consistent ID domain
      const limits = await checkContactLimits(req.user!.profile.id);
      if (!limits.canSendMessage) {
        return res.status(429).json({ 
          success: false, 
          error: 'Daily message limit reached. Please upgrade your plan.',
          limits: limits.limits,
          usage: limits.usage
        });
      }

      // Create message using storage interface
      const message = await storage.createMessage({
        senderId: req.user!.profile.id,
        threadId,
        content: content.trim(),
        fileType: fileType || null
      });

      // Broadcast to thread participants via WebSocket
      try {
        for (const participant of participants) {
          if (participant.userId !== req.user!.profile.id) {
            const userWs = (global as any).wsClients?.get(participant.userId);
            if (userWs && userWs.readyState === 1) {
              userWs.send(JSON.stringify({
                type: 'thread_message',
                threadId,
                message,
                sender: {
                  id: req.user!.profile.id,
                  name: req.user!.profile.name,
                  avatarUrl: req.user!.profile.avatarUrl
                }
              }));
            }
          }
        }
      } catch (wsError) {
        console.log('WebSocket broadcast failed:', wsError);
      }

      res.json({ success: true, data: message });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Send thread message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send message' });
    }
  });

  // Get thread messages with pagination
  app.get('/api/chat/threads/:threadId/messages', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      const { limit = 50, before } = req.query;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view this thread' });
      }

      const messages = await storage.getMessagesByThread(threadId, {
        limit: parseInt(limit as string),
        before: before as string
      });

      res.json({ success: true, data: messages });
    } catch (error) {
      console.error('Get thread messages error:', error);
      res.status(500).json({ success: false, error: 'Failed to get thread messages' });
    }
  });

  // Add participant to thread (admin or thread creator only)
  app.post('/api/chat/threads/:threadId/participants', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body using Zod schema
      const validatedData = insertChatParticipantSchema.omit({ 
        id: true, 
        createdAt: true, 
        threadId: true 
      }).parse(req.body);
      
      const { userId, role = 'member' } = validatedData;

      // Check if thread exists
      const thread = await storage.getChatThreadById(threadId);
      if (!thread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      // Verify requester is already a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant && req.user!.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Not authorized to add participants' });
      }

      const participant = await storage.createChatParticipant({
        threadId,
        userId,
        role: role as 'admin' | 'member'
      });

      res.json({ success: true, data: participant });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Add participant error:', error);
      res.status(500).json({ success: false, error: 'Failed to add participant' });
    }
  });

  // Get thread participants
  app.get('/api/chat/threads/:threadId/participants', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view participants' });
      }

      res.json({ success: true, data: participants });
    } catch (error) {
      console.error('Get participants error:', error);
      res.status(500).json({ success: false, error: 'Failed to get participants' });
    }
  });

  // Get chat thread by ID
  app.get('/api/chat/threads/:threadId', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;

      // Verify user is a participant
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant) {
        return res.status(403).json({ success: false, error: 'Not authorized to view this thread' });
      }

      const thread = await storage.getChatThreadById(threadId);
      if (!thread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      res.json({ success: true, data: { ...thread, participants } });
    } catch (error) {
      console.error('Get chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to get chat thread' });
    }
  });

  // Update thread status (for admins)
  app.patch('/api/chat/threads/:threadId', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { threadId } = req.params;
      
      // Validate request body - allow partial updates for status and subject
      const updateSchema = z.object({
        status: z.string().optional(),
        subject: z.string().optional()
      });
      
      const validatedData = updateSchema.parse(req.body);
      const { status, subject } = validatedData;

      // Only admins or participants can update thread
      const participants = await storage.getChatParticipantsByThread(threadId);
      const isParticipant = participants.some(p => p.userId === req.user!.profile.id);
      
      if (!isParticipant && req.user!.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Not authorized to update this thread' });
      }

      const updates: any = {};
      if (status) updates.status = status;
      if (subject) updates.subject = subject;

      const updatedThread = await storage.updateChatThread(threadId, updates);
      if (!updatedThread) {
        return res.status(404).json({ success: false, error: 'Thread not found' });
      }

      res.json({ success: true, data: updatedThread });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ success: false, error: 'Invalid request data', details: error.errors });
      }
      console.error('Update chat thread error:', error);
      res.status(500).json({ success: false, error: 'Failed to update chat thread' });
    }
  });

  // =======================
  // TASKS CRUD API Routes
  // =======================

  // Get all tasks for a user
  app.get('/api/tasks/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      const { status } = req.query;

      // Convert userId to UUID format
      const userUuid = await getUserUuidByTextId(userId);
      if (!userUuid) {
        return res.status(404).json({ success: false, error: 'User not found' });
      }

      let query = db
        .select()
        .from(tasks)
        .where(eq(tasks.userId, userUuid))
        .orderBy(desc(tasks.createdAt));

      // Filter by status if provided
      if (status && status !== 'all') {
        query = query.where(and(
          eq(tasks.userId, userUuid),
          eq(tasks.status, status as any)
        ));
      }

      const userTasks = await query;
      res.json({ success: true, data: userTasks });
    } catch (error) {
      console.error('Error fetching tasks:', error);
      res.status(500).json({ error: 'Failed to fetch tasks' });
    }
  });

  // Create a new task
  app.post('/api/tasks', async (req, res) => {
    try {
      const { userId, title, description, subject, dueDate, status = 'todo', priority = 'medium', tags = [] } = req.body;

      if (!userId || !title || !subject || !dueDate) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, title, subject, dueDate'
        });
      }

      const newTask = await db
        .insert(tasks)
        .values({
          userId,
          title,
          description,
          subject,
          dueDate: new Date(dueDate),
          status,
          priority,
          tags
        })
        .returning();

      res.json({ 
        success: true, 
        data: newTask[0],
        message: 'Task created successfully'
      });
    } catch (error) {
      console.error('Error creating task:', error);
      res.status(500).json({ error: 'Failed to create task' });
    }
  });

  // Update a task
  app.put('/api/tasks/:taskId', async (req, res) => {
    try {
      const { taskId } = req.params;
      const { userId, title, description, subject, dueDate, status, priority, tags, progress, commentsCount } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (description !== undefined) updateData.description = description;
      if (subject !== undefined) updateData.subject = subject;
      if (dueDate !== undefined) updateData.dueDate = new Date(dueDate);
      if (status !== undefined) updateData.status = status;
      if (priority !== undefined) updateData.priority = priority;
      if (tags !== undefined) updateData.tags = tags;
      if (progress !== undefined) updateData.progress = progress;
      if (commentsCount !== undefined) updateData.commentsCount = commentsCount;

      const updatedTask = await db
        .update(tasks)
        .set(updateData)
        .where(and(
          eq(tasks.id, taskId),
          eq(tasks.userId, userId)
        ))
        .returning();

      if (updatedTask.length === 0) {
        return res.status(404).json({ error: 'Task not found or not authorized' });
      }

      res.json({ 
        success: true, 
        data: updatedTask[0],
        message: 'Task updated successfully'
      });
    } catch (error) {
      console.error('Error updating task:', error);
      res.status(500).json({ error: 'Failed to update task' });
    }
  });

  // Delete a task
  app.delete('/api/tasks/:taskId', async (req, res) => {
    try {
      const { taskId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const deletedTask = await db
        .delete(tasks)
        .where(and(
          eq(tasks.id, taskId),
          eq(tasks.userId, userId)
        ))
        .returning();

      if (deletedTask.length === 0) {
        return res.status(404).json({ error: 'Task not found or not authorized' });
      }

      res.json({ 
        success: true, 
        message: 'Task deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting task:', error);
      res.status(500).json({ error: 'Failed to delete task' });
    }
  });

  // =======================
  // STUDY NOTES CRUD API Routes
  // =======================

  // Get all notes for a user
  app.get('/api/notes/:userId', async (req, res) => {
    try {
      const { userId } = req.params;

      const userNotes = await db
        .select()
        .from(studyNotes)
        .where(eq(studyNotes.userId, userId))
        .orderBy(desc(studyNotes.updatedAt));

      res.json({ success: true, data: userNotes });
    } catch (error) {
      console.error('Error fetching notes:', error);
      res.status(500).json({ error: 'Failed to fetch notes' });
    }
  });

  // Create a new note
  app.post('/api/notes', async (req, res) => {
    try {
      const { userId, title, content, subject, color = '#42fa76' } = req.body;

      if (!userId || !title || !content || !subject) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, title, content, subject'
        });
      }

      const newNote = await db
        .insert(studyNotes)
        .values({
          userId,
          title,
          content,
          subject,
          color
        })
        .returning();

      res.status(201).json({ 
        success: true, 
        data: newNote[0],
        message: 'Note created successfully'
      });
    } catch (error) {
      console.error('Error creating note:', error);
      res.status(500).json({ error: 'Failed to create note' });
    }
  });

  // Update an existing note
  app.put('/api/notes/:noteId', async (req, res) => {
    try {
      const { noteId } = req.params;
      const { userId, title, content, subject, color } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (content !== undefined) updateData.content = content;
      if (subject !== undefined) updateData.subject = subject;
      if (color !== undefined) updateData.color = color;

      const updatedNote = await db
        .update(studyNotes)
        .set(updateData)
        .where(and(
          eq(studyNotes.id, noteId),
          eq(studyNotes.userId, userId)
        ))
        .returning();

      if (updatedNote.length === 0) {
        return res.status(404).json({ error: 'Note not found or not authorized' });
      }

      res.json({ 
        success: true, 
        data: updatedNote[0],
        message: 'Note updated successfully'
      });
    } catch (error) {
      console.error('Error updating note:', error);
      res.status(500).json({ error: 'Failed to update note' });
    }
  });

  // Delete a note
  app.delete('/api/notes/:noteId', async (req, res) => {
    try {
      const { noteId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      const deletedNote = await db
        .delete(studyNotes)
        .where(and(
          eq(studyNotes.id, noteId),
          eq(studyNotes.userId, userId)
        ))
        .returning();

      if (deletedNote.length === 0) {
        return res.status(404).json({ error: 'Note not found or not authorized' });
      }

      res.json({ 
        success: true, 
        message: 'Note deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting note:', error);
      res.status(500).json({ error: 'Failed to delete note' });
    }
  });

  // =======================
  // ANNOUNCEMENTS API Routes
  // =======================

  // Get announcements for a student (based on their grade and subjects)
  app.get('/api/announcements/:userId', async (req, res) => {
    try {
      const { userId } = req.params; // This is the text ID like "T2509P002"

      // Convert text userId to UUID
      const userUuid = await getUserUuidByTextId(userId);
      if (!userUuid) {
        return res.json({ 
          success: true, 
          data: [] 
        });
      }

      // Get student profile to determine grade
      const [userProfile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userUuid));

      if (!userProfile) {
        // If no profile, return empty announcements (user needs to complete setup)
        return res.json({ 
          success: true, 
          data: [] 
        });
      }

      // Fetch announcements that target this student
      const userAnnouncements = await db
        .select()
        .from(announcements)
        .where(and(
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ))
        .orderBy(desc(announcements.createdAt));

      // Check which announcements the user has read
      const readAnnouncements = await db
        .select({ announcementId: announcementReads.announcementId })
        .from(announcementReads)
        .where(eq(announcementReads.userId, userUuid));

      const readAnnouncementIds = new Set(readAnnouncements.map(r => r.announcementId));

      const announcementsWithReadStatus = userAnnouncements.map(announcement => ({
        ...announcement,
        authorId: announcement.teacherId,
        authorName: 'EduFiliova Support',
        authorRole: 'admin',
        type: 'general',
        publishedAt: announcement.createdAt,
        isRead: readAnnouncementIds.has(announcement.id)
      }));

      res.json({ 
        success: true, 
        data: announcementsWithReadStatus 
      });
    } catch (error) {
      console.error('Error fetching announcements:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch announcements' 
      });
    }
  });

  // Mark announcement as read
  app.post('/api/announcements/:announcementId/read', async (req, res) => {
    try {
      const { announcementId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({
          success: false,
          error: 'User ID is required'
        });
      }

      // Check if already read
      const existingRead = await db
        .select()
        .from(announcementReads)
        .where(and(
          eq(announcementReads.announcementId, announcementId),
          eq(announcementReads.userId, userId)
        ));

      if (existingRead.length === 0) {
        // Mark as read
        await db
          .insert(announcementReads)
          .values({
            announcementId,
            userId
          });
      }

      res.json({ 
        success: true, 
        message: 'Announcement marked as read' 
      });
    } catch (error) {
      console.error('Error marking announcement as read:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to mark announcement as read' 
      });
    }
  });

  // Create announcement (Teachers/Admins only)
  app.post('/api/announcements', async (req, res) => {
    try {
      const { 
        teacherId, 
        title, 
        content, 
        priority = 'normal',
        targetAudience = 'all',
        targetGrade,
        targetStudentIds = [],
        expiresAt
      } = req.body;

      if (!teacherId || !title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: teacherId, title, content'
        });
      }

      // Convert teacherId to UUID format if needed
      const teacherUuid = await getUserUuidByTextId(teacherId);
      if (!teacherUuid) {
        return res.status(404).json({
          success: false,
          error: 'Teacher not found'
        });
      }

      // Get author info
      const [author] = await db
        .select({
          name: profiles.name,
          role: profiles.role
        })
        .from(profiles)
        .where(eq(profiles.userId, teacherUuid));

      if (!author) {
        return res.status(404).json({
          success: false,
          error: 'Author not found'
        });
      }

      // Check if user is teacher or admin
      if (!['teacher', 'admin'].includes(author.role)) {
        return res.status(403).json({
          success: false,
          error: 'Only teachers and admins can create announcements'
        });
      }

      const newAnnouncement = await db
        .insert(announcements)
        .values({
          teacherId: teacherUuid,
          title,
          content,
          priority,
          targetAudience,
          targetGrade: targetGrade ? parseInt(targetGrade.toString()) : null,
          targetStudentIds,
          expiresAt: expiresAt ? new Date(expiresAt) : null
        })
        .returning();

      // Broadcast to connected WebSocket clients
      const announcementData = {
        type: 'new_announcement',
        data: newAnnouncement[0]
      };

      // Send to all connected students
      wsClients.forEach((client, clientId) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify(announcementData));
        }
      });

      res.status(201).json({ 
        success: true, 
        data: newAnnouncement[0],
        message: 'Announcement created successfully'
      });
    } catch (error) {
      console.error('Error creating announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to create announcement' 
      });
    }
  });

  // Get unread announcements count
  app.get('/api/announcements/:userId/unread-count', async (req, res) => {
    try {
      const { userId } = req.params;

      // Get student profile to determine grade
      const [userProfile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId));

      if (!userProfile) {
        // If no profile, return zero unread count
        return res.json({ 
          success: true, 
          unreadCount: 0 
        });
      }

      // Count announcements that target this student
      const [totalCount] = await db
        .select({ count: count() })
        .from(announcements)
        .where(and(
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ));

      // Count read announcements
      const [readCount] = await db
        .select({ count: count() })
        .from(announcementReads)
        .innerJoin(announcements, eq(announcementReads.announcementId, announcements.id))
        .where(and(
          eq(announcementReads.userId, userId),
          eq(announcements.isActive, true),
          or(
            eq(announcements.targetAudience, 'all'),
            eq(announcements.targetGrade, userProfile.grade)
          )
        ));

      const unreadCount = (totalCount?.count || 0) - (readCount?.count || 0);

      res.json({ 
        success: true, 
        unreadCount 
      });
    } catch (error) {
      console.error('Error fetching unread announcements count:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch unread count' 
      });
    }
  });

  // Admin Routes for Announcements Management
  // Get all announcements for admin dashboard
  app.get('/api/admin/announcements', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const allAnnouncements = await db
        .select()
        .from(announcements)
        .orderBy(desc(announcements.createdAt));

      res.json({ 
        success: true, 
        data: allAnnouncements 
      });
    } catch (error) {
      console.error('Error fetching admin announcements:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch announcements' 
      });
    }
  });

  // Update announcement (admin only)
  app.put('/api/admin/announcements/:id', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;
      const { title, content, priority, targetAudience, targetGrade, isActive } = req.body;

      if (!title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Title and content are required'
        });
      }

      const updatedAnnouncement = await db
        .update(announcements)
        .set({
          title,
          content,
          priority: priority || 'normal',
          targetAudience: targetAudience || 'all',
          targetGrade: targetAudience === 'grade_specific' ? targetGrade : null,
          isActive: isActive !== undefined ? isActive : true,
          updatedAt: new Date()
        })
        .where(eq(announcements.id, id))
        .returning();

      if (updatedAnnouncement.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Announcement not found'
        });
      }

      res.json({ 
        success: true, 
        data: updatedAnnouncement[0],
        message: 'Announcement updated successfully'
      });
    } catch (error) {
      console.error('Error updating announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update announcement' 
      });
    }
  });

  // Delete announcement (admin only)
  app.delete('/api/admin/announcements/:id', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;

      const deletedAnnouncement = await db
        .delete(announcements)
        .where(eq(announcements.id, id))
        .returning();

      if (deletedAnnouncement.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Announcement not found'
        });
      }

      res.json({ 
        success: true, 
        message: 'Announcement deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting announcement:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to delete announcement' 
      });
    }
  });


  // ============================================
  // BLOG POSTS ROUTES
  // ============================================
  
  // Get all blog posts (admin)
  app.get('/api/admin/blog-posts', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const allPosts = await db
        .select()
        .from(blogPosts)
        .orderBy(desc(blogPosts.createdAt));

      res.json(allPosts);
    } catch (error) {
      console.error('Error fetching admin blog posts:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog posts' 
      });
    }
  });

  // Create blog post (admin)
  app.post('/api/admin/blog-posts', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { title, excerpt, content, category, coverImage, isPublished } = req.body;

      if (!title || !content) {
        return res.status(400).json({ 
          success: false, 
          error: 'Title and content are required' 
        });
      }

      // Generate slug from title
      const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

      // Check if slug already exists
      const [existing] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.slug, slug))
        .limit(1);

      if (existing) {
        return res.status(400).json({ 
          success: false, 
          error: 'A blog post with this title already exists' 
        });
      }

      // Get user profile for author info
      const [profile] = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (!profile) {
        return res.status(400).json({ 
          success: false, 
          error: 'User profile not found' 
        });
      }

      // Create the blog post
      const [newPost] = await db
        .insert(blogPosts)
        .values({
          title,
          slug,
          excerpt: excerpt || '',
          content,
          category: category || 'General',
          coverImage: coverImage || null,
          authorId: user.id,
          authorName: profile.name,
          authorAvatar: profile.avatarUrl || null,
          isPublished: isPublished || false,
          publishedAt: isPublished ? new Date() : null,
          createdAt: new Date(),
          updatedAt: new Date()
        })
        .returning();

      res.json({ 
        success: true, 
        data: newPost, 
        message: 'Blog post created successfully' 
      });
    } catch (error) {
      console.error('Error creating blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to create blog post' 
      });
    }
  });

  // Update blog post (admin)
  app.put('/api/admin/blog-posts/:id', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;
      const { title, excerpt, content, category, coverImage, isPublished } = req.body;

      if (!title || !content) {
        return res.status(400).json({ 
          success: false, 
          error: 'Title and content are required' 
        });
      }

      // Check if post exists
      const [existingPost] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)))
        .limit(1);

      if (!existingPost) {
        return res.status(404).json({ 
          success: false, 
          error: 'Blog post not found' 
        });
      }

      // Generate new slug if title changed
      const slug = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');

      // Check if new slug conflicts with another post
      if (slug !== existingPost.slug) {
        const [conflicting] = await db
          .select()
          .from(blogPosts)
          .where(eq(blogPosts.slug, slug))
          .limit(1);

        if (conflicting) {
          return res.status(400).json({ 
            success: false, 
            error: 'A blog post with this title already exists' 
          });
        }
      }

      // Update the blog post
      const [updatedPost] = await db
        .update(blogPosts)
        .set({
          title,
          slug,
          excerpt: excerpt || '',
          content,
          category: category || 'General',
          coverImage: coverImage || null,
          isPublished: isPublished || false,
          publishedAt: isPublished && !existingPost.isPublished ? new Date() : existingPost.publishedAt,
          updatedAt: new Date()
        })
        .where(eq(blogPosts.id, parseInt(id)))
        .returning();

      res.json({ 
        success: true, 
        data: updatedPost, 
        message: 'Blog post updated successfully' 
      });
    } catch (error) {
      console.error('Error updating blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update blog post' 
      });
    }
  });

  // Delete blog post (admin)
  app.delete('/api/admin/blog-posts/:id', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          error: 'Admin access required'
        });
      }

      const { id } = req.params;

      // Check if post exists
      const [existingPost] = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)))
        .limit(1);

      if (!existingPost) {
        return res.status(404).json({ 
          success: false, 
          error: 'Blog post not found' 
        });
      }

      // Delete the blog post
      await db
        .delete(blogPosts)
        .where(eq(blogPosts.id, parseInt(id)));

      res.json({ 
        success: true, 
        message: 'Blog post deleted successfully' 
      });
    } catch (error) {
      console.error('Error deleting blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to delete blog post' 
      });
    }
  });

  // Get all published blog posts (public)
  app.get('/api/blog-posts', async (req, res) => {
    try {
      const publishedPosts = await db
        .select()
        .from(blogPosts)
        .where(eq(blogPosts.isPublished, true))
        .orderBy(desc(blogPosts.publishedAt));

      res.json(publishedPosts);
    } catch (error) {
      console.error('Error fetching blog posts:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog posts' 
      });
    }
  });

  // Get single blog post by slug (public)
  app.get('/api/blog-posts/:slug', async (req, res) => {
    try {
      const { slug } = req.params;

      const [post] = await db
        .select()
        .from(blogPosts)
        .where(and(
          eq(blogPosts.slug, slug),
          eq(blogPosts.isPublished, true)
        ))
        .limit(1);

      if (!post) {
        return res.status(404).json({
          success: false,
          error: 'Blog post not found'
        });
      }

      res.json(post);
    } catch (error) {
      console.error('Error fetching blog post:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch blog post' 
      });
    }
  });

  // Get unread messages count (including group messages)
  app.get('/api/messages/:userId/unread-count', async (req, res) => {
    try {
      const { userId } = req.params; // This is the text-based user ID like "HJOR2AC54I"

      // Use existing helper function to convert text user ID to profile UUID
      const profileUuid = await getUserUuidByUserId(userId);
      
      if (!profileUuid) {
        return res.status(404).json({ 
          success: false, 
          error: 'User not found' 
        });
      }

      // Count total direct messages sent to this user (as receiver) using profile.id
      const [totalDirectCount] = await db
        .select({ count: count() })
        .from(messages)
        .where(and(
          eq(messages.receiverId, profileUuid),
          isNull(messages.groupId) // Only direct messages
        ));

      // Count read direct messages (messages this user has read)
      const [readDirectCount] = await db
        .select({ count: count() })
        .from(messages)
        .where(and(
          eq(messages.receiverId, profileUuid),
          isNull(messages.groupId), // Only direct messages
          isNotNull(messages.readAt)
        ));

      // Get all groups the user is a member of
      const userGroups = await db
        .select({ groupId: communityGroupMembers.groupId })
        .from(communityGroupMembers)
        .where(eq(communityGroupMembers.userId, profileUuid));

      let groupUnreadCount = 0;
      
      // Count unread group messages for each group
      for (const group of userGroups) {
        const [totalGroupCount] = await db
          .select({ count: count() })
          .from(messages)
          .where(and(
            eq(messages.groupId, group.groupId),
            ne(messages.senderId, profileUuid) // Don't count user's own messages
          ));

        // For group messages, we need to implement a separate read tracking system
        // For now, we'll count all group messages as unread except user's own
        // TODO: Implement proper group message read tracking
        groupUnreadCount += totalGroupCount?.count || 0;
      }

      const directUnreadCount = (totalDirectCount?.count || 0) - (readDirectCount?.count || 0);
      const totalUnreadCount = directUnreadCount + groupUnreadCount;

      res.json({ 
        success: true, 
        unreadCount: totalUnreadCount,
        directUnreadCount,
        groupUnreadCount
      });
    } catch (error) {
      console.error('Error fetching unread messages count:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch unread messages count' 
      });
    }
  });

  // Temporary in-memory storage for payment methods and profiles while DB is having issues
  const paymentMethodsStorage = new Map();
  const profileStorage = new Map();

  // Payment methods endpoints
  app.get('/api/payment-methods', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const user = req.user as any;
      
      try {
        // Try to fetch from database first
        const userPaymentMethods = await db
          .select()
          .from(paymentMethods)
          .where(eq(paymentMethods.userId, user.id))
          .orderBy(desc(paymentMethods.isDefault), desc(paymentMethods.createdAt));
        
        res.json(userPaymentMethods);
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        res.json(userMethods);
      }
    } catch (error) {
      console.error('Error fetching payment methods:', error);
      res.status(500).json({ error: 'Failed to fetch payment methods' });
    }
  });

  app.post('/api/payment-methods', requireAuth, async (req, res) => {
    try {
      const { userId, displayName, cardNumber, expiryDate, cvv, cardholderName, isDefault } = req.body;
      
      // Validate required fields
      if (!userId || !displayName || !cardNumber || !expiryDate || !cardholderName) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }
      
      const newPaymentMethod = {
        id: `pm_${Date.now()}`, // Generate a temporary ID
        userId,
        type: 'stripe_card',
        displayName,
        lastFour: cardNumber.slice(-4),
        expiryDate,
        cardholderName,
        isDefault: isDefault || false,
        isVerified: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      try {
        // Try to save to database first
        if (isDefault) {
          await db
            .update(paymentMethods)
            .set({ isDefault: false })
            .where(eq(paymentMethods.userId, userId));
        }
        
        const [insertedPaymentMethod] = await db
          .insert(paymentMethods)
          .values({
            userId,
            type: 'stripe_card',
            displayName,
            lastFour: cardNumber.slice(-4),
            expiryDate,
            cardholderName,
            isDefault: isDefault || false,
            isVerified: true
          })
          .returning();
        
        res.json({ 
          success: true, 
          data: insertedPaymentMethod,
          message: 'Payment method added successfully'
        });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(userId) || [];
        
        // If this is set as default, unset all other defaults
        if (isDefault) {
          userMethods.forEach(method => method.isDefault = false);
        }
        
        userMethods.push(newPaymentMethod);
        paymentMethodsStorage.set(userId, userMethods);
        
        res.json({ 
          success: true, 
          data: newPaymentMethod,
          message: 'Payment method added successfully'
        });
      }
    } catch (error) {
      console.error('Error adding payment method:', error);
      res.status(500).json({ error: 'Failed to add payment method' });
    }
  });

  app.delete('/api/payment-methods/:methodId', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const { methodId } = req.params;
      const user = req.user as any;
      
      try {
        // Try to delete from database first
        await db
          .delete(paymentMethods)
          .where(and(
            eq(paymentMethods.id, methodId),
            eq(paymentMethods.userId, user.id)
          ));
        
        res.json({ success: true, message: 'Payment method deleted successfully' });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for payment methods');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        const updatedMethods = userMethods.filter(method => method.id !== methodId);
        paymentMethodsStorage.set(user.id, updatedMethods);
        
        res.json({ success: true, message: 'Payment method deleted successfully' });
      }
    } catch (error) {
      console.error('Error deleting payment method:', error);
      res.status(500).json({ error: 'Failed to delete payment method' });
    }
  });

  app.put('/api/payment-methods/:methodId/set-default', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const { methodId } = req.params;
      const user = req.user as any;
      
      try {
        // Try database first
        await db
          .update(paymentMethods)
          .set({ isDefault: false })
          .where(eq(paymentMethods.userId, user.id));
        
        await db
          .update(paymentMethods)
          .set({ isDefault: true })
          .where(and(
            eq(paymentMethods.id, methodId),
            eq(paymentMethods.userId, user.id)
          ));
        
        res.json({ success: true, message: 'Default payment method updated successfully' });
      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for setting default payment method');
        const userMethods = paymentMethodsStorage.get(user.id) || [];
        
        // Unset all defaults first
        userMethods.forEach(method => method.isDefault = false);
        
        // Set the selected method as default
        const targetMethod = userMethods.find(method => method.id === methodId);
        if (targetMethod) {
          targetMethod.isDefault = true;
          paymentMethodsStorage.set(user.id, userMethods);
          res.json({ success: true, message: 'Default payment method updated successfully' });
        } else {
          res.status(404).json({ error: 'Payment method not found' });
        }
      }
    } catch (error) {
      console.error('Error setting default payment method:', error);
      res.status(500).json({ error: 'Failed to set default payment method' });
    }
  });

  // Stripe SetupIntent endpoint for adding payment methods
  app.post('/api/payment-methods/setup-intent', requireAuth, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          error: 'Payment system not available' 
        });
      }

      const user = req.user as any;
      let customerId = user.profile?.stripeCustomerId;

      // Create Stripe customer if doesn't exist
      if (!customerId) {
        const customer = await stripe.customers.create({
          email: user.email,
          metadata: {
            userId: user.id,
          },
        });
        customerId = customer.id;

        // Update profile with Stripe customer ID
        await db
          .update(profiles)
          .set({ stripeCustomerId: customerId })
          .where(eq(profiles.userId, user.id));
      }

      // Create SetupIntent
      const setupIntent = await stripe.setupIntents.create({
        customer: customerId,
        payment_method_types: ['card'],
      });

      res.json({ clientSecret: setupIntent.client_secret });
    } catch (error: any) {
      console.error('Error creating setup intent:', error);
      res.status(500).json({ error: 'Failed to create setup intent' });
    }
  });

  // Manual sync endpoint for development (webhooks don't work locally)
  app.post('/api/payment-methods/sync', requireAuth, async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: 'Stripe not configured' });
      }

      const user = req.user as any;
      
      // Fetch the Stripe customer ID from the database
      const [userProfile] = await db
        .select({ stripeCustomerId: profiles.stripeCustomerId })
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      const customerId = userProfile?.stripeCustomerId;

      if (!customerId) {
        return res.status(400).json({ error: 'No Stripe customer ID found. Please contact support.' });
      }

      // Get all payment methods from Stripe for this customer
      const stripeMethods = await stripe.paymentMethods.list({
        customer: customerId,
        type: 'card',
      });

      if (stripeMethods.data.length === 0) {
        return res.json({ success: true, synced: 0 });
      }

      let syncedCount = 0;

      for (const paymentMethod of stripeMethods.data) {
        // Check if this payment method already exists in our database
        const [existing] = await db
          .select()
          .from(paymentMethods)
          .where(eq(paymentMethods.stripePaymentMethodId, paymentMethod.id))
          .limit(1);

        if (!existing) {
          // Check if this is the first payment method (make it default)
          const existingMethods = await db
            .select()
            .from(paymentMethods)
            .where(eq(paymentMethods.userId, user.id));

          const isFirstMethod = existingMethods.length === 0;

          // Save new payment method to database
          await db.insert(paymentMethods).values({
            userId: user.id,
            stripePaymentMethodId: paymentMethod.id,
            type: 'stripe_card',
            displayName: `${paymentMethod.card?.brand?.toUpperCase() || 'Card'} ****${paymentMethod.card?.last4}`,
            lastFour: paymentMethod.card?.last4 || '',
            expiryDate: `${paymentMethod.card?.exp_month}/${paymentMethod.card?.exp_year}`,
            cardholderName: paymentMethod.billing_details?.name || '',
            isDefault: isFirstMethod,
            isVerified: true,
          });

          syncedCount++;
        }
      }

      res.json({ success: true, synced: syncedCount });
    } catch (error: any) {
      console.error('Error syncing payment methods:', error);
      res.status(500).json({ error: 'Failed to sync payment methods' });
    }
  });

  // Stripe webhook to handle payment method attachment
  app.post('/api/webhooks/stripe', express.raw({ type: 'application/json' }), async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).send('Stripe not configured');
      }

      const sig = req.headers['stripe-signature'] as string;
      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

      if (!webhookSecret) {
        console.log('Warning: STRIPE_WEBHOOK_SECRET not configured, skipping signature verification');
        // In production, you should always verify the signature
      }

      let event;
      try {
        if (webhookSecret) {
          event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
        } else {
          event = JSON.parse(req.body.toString());
        }
      } catch (err: any) {
        console.error('Webhook signature verification failed:', err.message);
        return res.status(400).send(`Webhook Error: ${err.message}`);
      }

      // Handle the event
      if (event.type === 'setup_intent.succeeded') {
        const setupIntent = event.data.object as any;
        const customerId = setupIntent.customer;
        const paymentMethodId = setupIntent.payment_method;

        // Get payment method details from Stripe
        const paymentMethod = await stripe.paymentMethods.retrieve(paymentMethodId);
        
        // Find user by Stripe customer ID
        const [userProfile] = await db
          .select()
          .from(profiles)
          .where(eq(profiles.stripeCustomerId, customerId))
          .limit(1);

        if (userProfile) {
          // Check if this is the first payment method (make it default)
          const existingMethods = await db
            .select()
            .from(paymentMethods)
            .where(eq(paymentMethods.userId, userProfile.userId));

          const isFirstMethod = existingMethods.length === 0;

          // Unset all other defaults if this is being set as default
          if (isFirstMethod) {
            await db
              .update(paymentMethods)
              .set({ isDefault: false })
              .where(eq(paymentMethods.userId, userProfile.userId));
          }

          // Save payment method to database
          await db.insert(paymentMethods).values({
            userId: userProfile.userId,
            stripePaymentMethodId: paymentMethodId,
            type: 'stripe_card',
            displayName: `${paymentMethod.card?.brand?.toUpperCase() || 'Card'} ****${paymentMethod.card?.last4}`,
            lastFour: paymentMethod.card?.last4 || '',
            expiryDate: `${paymentMethod.card?.exp_month}/${paymentMethod.card?.exp_year}`,
            cardholderName: paymentMethod.billing_details?.name || '',
            isDefault: isFirstMethod,
            isVerified: true,
          });
        }
      }

      res.json({ received: true });
    } catch (error: any) {
      console.error('Webhook error:', error);
      res.status(500).send('Webhook handler failed');
    }
  });

  // Stripe Checkout Session Route
  app.post('/api/create-checkout-session', async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { plan, userId, countryCode } = req.body;

      if (!plan || !userId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: plan, userId'
        });
      }

      // Define plan pricing
      const planPrices = {
        primary_basic: 4.99,
        high_school_basic: 6.99,
        college_course: 9.99
      };

      const amount = planPrices[plan as keyof typeof planPrices] || 4.99;

      // Create checkout session
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ['card'],
        line_items: [{
          price_data: {
            currency: 'usd',
            product_data: {
              name: `EduFiliova ${plan.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())} Plan`,
              description: 'Unlimited access to educational content and premium features'
            },
            unit_amount: Math.round(amount * 100), // Convert to cents
            recurring: {
              interval: 'month'
            }
          },
          quantity: 1,
        }],
        mode: 'subscription',
        success_url: `${process.env.BASE_URL || 'http://localhost:5000'}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.BASE_URL || 'http://localhost:5000'}/student-dashboard`,
        metadata: {
          userId,
          plan,
          countryCode: countryCode || 'US'
        }
      });

      res.json({
        success: true,
        checkoutUrl: session.url,
        sessionId: session.id
      });

    } catch (error: any) {
      console.error('Stripe checkout session error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create checkout session'
      });
    }
  });

  // Stripe Payment Routes

  // Paystack Payment Routes
  app.post('/api/courses/paystack/initialize', requireAuth, async (req, res) => {
    try {
      const { courseId, amount, email } = req.body;
      const user = (req as AuthenticatedRequest).user;

      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      const paystackSecretKey = process.env.PAYSTACK_SECRET_KEY;
      if (!paystackSecretKey) {
        return res.status(500).json({ error: 'Paystack not configured' });
      }

      // Initialize Paystack transaction
      const response = await fetch('https://api.paystack.co/transaction/initialize', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${paystackSecretKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email: email || user.email,
          amount: amount, // Amount in kobo (cents)
          currency: 'USD',
          metadata: {
            courseId,
            userId: user.id,
            type: 'course_purchase'
          },
          callback_url: `${process.env.BASE_URL || 'http://localhost:5000'}/api/courses/paystack/callback`
        })
      });

      const data = await response.json();

      if (data.status) {
        res.json({ 
          success: true, 
          authorization_url: data.data.authorization_url,
          access_code: data.data.access_code,
          reference: data.data.reference
        });
      } else {
        res.status(400).json({ error: data.message || 'Failed to initialize payment' });
      }
    } catch (error) {
      console.error('Paystack initialization error:', error);
      res.status(500).json({ error: 'Failed to initialize Paystack payment' });
    }
  });

  // Paystack callback handler
  app.get('/api/courses/paystack/callback', async (req, res) => {
    try {
      const { reference } = req.query;

      if (!reference) {
        return res.redirect('/?payment=failed');
      }

      const paystackSecretKey = process.env.PAYSTACK_SECRET_KEY;
      if (!paystackSecretKey) {
        return res.redirect('/?payment=error');
      }

      // Verify transaction
      const response = await fetch(`https://api.paystack.co/transaction/verify/${reference}`, {
        headers: {
          'Authorization': `Bearer ${paystackSecretKey}`
        }
      });

      const data = await response.json();

      if (data.status && data.data.status === 'success') {
        const { courseId, userId } = data.data.metadata;
        const amount = data.data.amount / 100; // Convert from kobo to dollars

        // Create or update purchase record
        await db
          .insert(coursePurchases)
          .values({
            userId,
            courseId,
            amount: amount.toString(),
            currency: 'USD',
            paymentIntentId: reference as string,
            paymentStatus: 'completed',
            purchasedAt: new Date()
          })
          .onConflictDoUpdate({
            target: [coursePurchases.userId, coursePurchases.courseId],
            set: {
              paymentStatus: 'completed',
              purchasedAt: new Date()
            }
          });

        // Auto-enroll user
        const existingEnrollment = await db
          .select()
          .from(courseEnrollments)
          .where(and(
            eq(courseEnrollments.userId, userId),
            eq(courseEnrollments.courseId, courseId)
          ))
          .limit(1);

        if (existingEnrollment.length === 0) {
          await db.insert(courseEnrollments).values({
            userId,
            courseId,
            enrolledAt: new Date(),
            progress: 0,
          });
        }

        res.redirect(`/course-detail-${courseId}?payment=success`);
      } else {
        res.redirect('/?payment=failed');
      }
    } catch (error) {
      console.error('Paystack callback error:', error);
      res.redirect('/?payment=error');
    }
  });
  app.post('/api/create-payment-intent', async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { amount, planName, billingCycle, subscriptionTier, gradeLevel, userId, planId, planType } = req.body;

      // Validate based on plan type
      if (planType === 'freelancer') {
        if (!planId) {
          return res.status(400).json({
            success: false,
            error: 'planId is required for freelancer subscriptions'
          });
        }
      }

      if (!amount || !planName || !userId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: amount, planName, userId'
        });
      }

      // Get user's country to determine currency
      let userCountry = 'United States';
      let currency = 'usd';
      let convertedAmount = amount;

      // Only fetch profile for authenticated users, not guests
      if (userId && userId !== 'guest') {
        try {
          const userProfile = await db
            .select()
            .from(profiles)
            .where(eq(profiles.userId, userId))
            .limit(1);

          if (userProfile.length > 0 && userProfile[0].country) {
            userCountry = userProfile[0].country;
            
            // Get country code for currency conversion
            const countryCode = getCountryCodeFromName(userCountry);
            
            // List of currencies supported by Stripe
            const stripeSupportedCurrencies = [
              'usd', 'aed', 'afn', 'all', 'amd', 'ang', 'aoa', 'ars', 'aud', 'awg', 'azn', 'bam', 'bbd', 
              'bdt', 'bgn', 'bhd', 'bif', 'bmd', 'bnd', 'bob', 'brl', 'bsd', 'bwp', 'byn', 'bzd', 'cad', 
              'cdf', 'chf', 'clp', 'cny', 'cop', 'crc', 'cve', 'czk', 'djf', 'dkk', 'dop', 'dzd', 'egp', 
              'etb', 'eur', 'fjd', 'fkp', 'gbp', 'gel', 'gip', 'gmd', 'gnf', 'gtq', 'gyd', 'hkd', 'hnl', 
              'hrk', 'htg', 'huf', 'idr', 'ils', 'inr', 'isk', 'jmd', 'jod', 'jpy', 'kes', 'kgs', 'khr', 
              'kmf', 'krw', 'kwd', 'kyd', 'kzt', 'lak', 'lbp', 'lkr', 'lrd', 'lsl', 'mad', 'mdl', 'mga', 
              'mkd', 'mmk', 'mnt', 'mop', 'mur', 'mvr', 'mwk', 'mxn', 'myr', 'mzn', 'nad', 'ngn', 'nio', 
              'nok', 'npr', 'nzd', 'omr', 'pab', 'pen', 'pgk', 'php', 'pkr', 'pln', 'pyg', 'qar', 'ron', 
              'rsd', 'rub', 'rwf', 'sar', 'sbd', 'scr', 'sek', 'sgd', 'shp', 'sle', 'sos', 'srd', 'std', 
              'szl', 'thb', 'tjs', 'tnd', 'top', 'try', 'ttd', 'twd', 'tzs', 'uah', 'ugx', 'uyu', 'uzs', 
              'vnd', 'vuv', 'wst', 'xaf', 'xcd', 'xcg', 'xof', 'xpf', 'yer', 'zar', 'zmw', 'usdc', 'btn', 
              'ghs', 'eek', 'lvl', 'svc', 'vef', 'ltl', 'sll', 'mro'
            ];

            // Map country code to currency (use USD for unsupported currencies)
            const countryToCurrency: { [key: string]: string } = {
              'US': 'usd', 'CA': 'cad', 'GB': 'gbp', 'EU': 'eur', 'DE': 'eur', 'FR': 'eur', 'ES': 'eur', 'IT': 'eur',
              'AU': 'aud', 'NZ': 'nzd', 'JP': 'jpy', 'CN': 'cny', 'IN': 'inr', 'BR': 'brl', 'MX': 'mxn',
              'ZA': 'zar', 'NG': 'ngn', 'KE': 'kes', 'GH': 'ghs', 'EG': 'egp', 'MA': 'mad',
              'RU': 'rub', 'KR': 'krw', 'TH': 'thb', 'VN': 'vnd', 'ID': 'idr', 'MY': 'myr', 'PH': 'php', 'SG': 'sgd',
              'AR': 'ars', 'CL': 'clp', 'CO': 'cop', 'PE': 'pen', 'UY': 'uyu', 'VE': 'usd', // VES not supported, use USD
              'TR': 'try', 'SA': 'sar', 'AE': 'aed', 'IL': 'ils', 'JO': 'jod', 'LB': 'lbp',
              'PL': 'pln', 'CZ': 'czk', 'HU': 'huf', 'RO': 'ron', 'BG': 'bgn', 'HR': 'hrk',
              'NO': 'nok', 'SE': 'sek', 'DK': 'dkk', 'FI': 'eur', 'IS': 'isk',
              'CH': 'chf', 'AT': 'eur', 'BE': 'eur', 'NL': 'eur', 'LU': 'eur', 'IE': 'eur', 'PT': 'eur'
            };

            const proposedCurrency = countryToCurrency[countryCode] || 'usd';
            
            // Ensure the currency is supported by Stripe, fallback to USD if not
            currency = stripeSupportedCurrencies.includes(proposedCurrency) ? proposedCurrency : 'usd';
            
            // If currency is not USD, fetch exchange rate and convert amount
            if (currency !== 'usd') {
              try {
                const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
                const data = await response.json();
                const rate = data.rates[currency.toUpperCase()] || 1;
                convertedAmount = amount * rate;
              } catch (exchangeError) {
                console.log('Exchange rate fetch failed, using USD:', exchangeError);
                currency = 'usd';
                convertedAmount = amount;
              }
            }
          }
        } catch (profileError) {
          console.log('Profile fetch failed, using default USD:', profileError);
        }
      }

      // Create payment intent with user's currency
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(convertedAmount * 100), // Convert to cents/smallest unit
        currency: currency.toLowerCase(),
        metadata: {
          planName,
          billingCycle,
          subscriptionTier: subscriptionTier || '',
          gradeLevel: gradeLevel?.toString() || '',
          planId: planId || '',
          planType: planType || 'student',
          userId,
          originalUSDAmount: amount.toString(),
          userCountry,
          conversionRate: (convertedAmount / amount).toString()
        }

      });
      res.json({
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        currency: currency.toUpperCase(),
        convertedAmount,
        originalAmount: amount
      });

    } catch (error: any) {
      console.error('Stripe payment intent error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create payment intent'
      });
    }
  });

  // Handle successful payments and update user plan
  app.post('/api/confirm-payment', async (req, res) => {
    try {
      const { paymentIntentId, userId } = req.body;

      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { planName, billingCycle, subscriptionTier, gradeLevel } = paymentIntent.metadata;

      // SECURITY: Validate grade-based subscription metadata
      const allowedTiers = ['elementary', 'high_school', 'college_university'];
      const allowedCycles = ['monthly', 'yearly'];
      
      if (!subscriptionTier || !allowedTiers.includes(subscriptionTier)) {
        console.error('Invalid subscription tier in payment metadata:', subscriptionTier);
        return res.status(400).json({
          success: false,
          error: 'Invalid subscription tier'
        });
      }
      
      if (!billingCycle || !allowedCycles.includes(billingCycle)) {
        console.error('Invalid billing cycle in payment metadata:', billingCycle);
        return res.status(400).json({
          success: false,
          error: 'Invalid billing cycle'
        });
      }

      // Calculate plan expiry date based on billing cycle
      const now = new Date();
      let planExpiry;
      let planKey;
      
      switch (billingCycle) {
        case 'monthly':
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
          break;
        case 'yearly':
          planExpiry = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year
          break;
        default:
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // Default to monthly
      }

      // Grade level for profile update
      const gradeNumber = gradeLevel ? parseInt(gradeLevel) : null;

      // Update user's plan in database with grade-based subscription
      try {
        const updateData: any = {
          subscriptionTier: subscriptionTier,
          planExpiry: planExpiry,
          verificationBadge: 'blue',
          lastPricingShown: new Date(),
          updatedAt: new Date()
        };
        
        // Update grade level if provided
        if (gradeNumber !== null) {
          updateData.grade = gradeNumber;
          // Set gradeLevel enum value based on gradeNumber
          if (gradeNumber >= 1 && gradeNumber <= 12) {
            updateData.gradeLevel = gradeNumber.toString();
          } else if (gradeNumber === 13) {
            updateData.gradeLevel = 'college';
          } else if (gradeNumber >= 14) {
            updateData.gradeLevel = 'university';
          }
        }
        
        await db
          .update(profiles)
          .set(updateData)
          .where(eq(profiles.userId, userId));

        res.json({
          success: true,
          message: 'Payment confirmed and plan updated',
          planName,
          billingCycle
        });

      } catch (dbError) {
        console.error('Database error updating plan:', dbError);
        res.status(500).json({
          success: false,
          error: 'Payment successful but failed to update plan'
        });
      }

    } catch (error: any) {
      console.error('Payment confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm payment'
      });
    }
  });

  // Confirm Freelancer Subscription Payment
  app.post('/api/confirm-freelancer-subscription', async (req, res) => {
    try {
      const { paymentIntentId, userId } = req.body;

      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { planId, planType, billingCycle } = paymentIntent.metadata;

      // Validate this is a freelancer plan payment
      if (planType !== 'freelancer') {
        return res.status(400).json({
          success: false,
          error: 'Invalid plan type'
        });
      }

      // Calculate plan expiry date based on billing cycle
      const now = new Date();
      let planExpiry;
      
      switch (billingCycle) {
        case 'monthly':
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 30 days
          break;
        case 'yearly':
          planExpiry = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000); // 1 year
          break;
        case 'lifetime':
          planExpiry = new Date(now.getTime() + 100 * 365 * 24 * 60 * 60 * 1000); // 100 years (lifetime)
          break;
        default:
          planExpiry = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // Default to monthly
      }

      // Fetch plan details to get the badge color
      const [planDetails] = await db
        .select()
        .from(freelancerPricingPlans)
        .where(eq(freelancerPricingPlans.planId, planId))
        .limit(1);

      if (!planDetails) {
        return res.status(400).json({
          success: false,
          error: 'Invalid plan ID'
        });
      }

      // Map badge color to verification badge enum
      // blue -> blue, green -> green, orange -> blue (Elite plan gets blue badge)
      const badgeMapping: Record<string, 'none' | 'green' | 'blue'> = {
        'blue': 'blue',
        'green': 'green',
        'orange': 'blue' // Elite plan gets blue badge
      };
      
      const verificationBadge = badgeMapping[planDetails.badgeColor] || 'none';

      // Update user's freelancer subscription in database
      try {
        await db
          .update(profiles)
          .set({
            legacyPlan: planId,
            planExpiry: planExpiry,
            verificationBadge: verificationBadge,
            updatedAt: new Date()
          })
          .where(eq(profiles.userId, userId));

        res.json({
          success: true,
          message: 'Freelancer subscription confirmed',
          planId,
          billingCycle,
          expiry: planExpiry,
          badgeAwarded: verificationBadge
        });

      } catch (dbError) {
        console.error('Database error updating freelancer subscription:', dbError);
        res.status(500).json({
          success: false,
          error: 'Payment successful but failed to update subscription'
        });
      }

    } catch (error: any) {
      console.error('Freelancer subscription confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm subscription'
      });
    }
  });

  // Process wallet payment
  app.post('/api/process-wallet-payment', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      
      if (!userId) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      const { amount, orderId, planName, billingCycle, bannerId, type } = req.body;

      if (!amount || amount <= 0) {
        return res.status(400).json({
          success: false,
          error: 'Invalid amount'
        });
      }

      // Get user's shop customer record for wallet
      const customer = await storage.getShopCustomerByUserId(userId);
      
      if (!customer) {
        return res.status(404).json({
          success: false,
          error: 'Customer wallet not found'
        });
      }

      const walletBalance = parseFloat(customer.walletBalance);
      
      if (walletBalance < amount) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient wallet balance'
        });
      }

      // Deduct amount from wallet
      const newBalance = walletBalance - amount;
      
      await db
        .update(shopCustomers)
        .set({
          walletBalance: newBalance.toFixed(2),
          updatedAt: new Date()
        })
        .where(eq(shopCustomers.id, customer.id));

      // Create transaction record
      const transactionDescription = orderId 
        ? `Order payment #${orderId.substring(0, 8)}` 
        : bannerId 
        ? `Banner ad payment #${bannerId.substring(0, 8)}`
        : `${planName || 'Subscription'} - ${billingCycle || 'monthly'}`;

      await db
        .insert(shopTransactions)
        .values({
          customerId: customer.id,
          amount: (-amount).toFixed(2), // Negative for deduction
          type: 'purchase',
          description: transactionDescription,
          status: 'completed',
          referenceId: orderId || bannerId || `wallet-${Date.now()}`
        });

      // If this is an order payment, update the order
      if (orderId) {
        await db
          .update(orders)
          .set({
            status: 'paid',
            paymentMethod: 'wallet',
            completedAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(orders.id, orderId));
      }

      // If this is a banner ad payment, update the banner status to pending
      if (bannerId) {
        await db
          .update(adsBanners)
          .set({
            status: 'pending',
            updatedAt: new Date()
          })
          .where(eq(adsBanners.id, bannerId));
      }

      res.json({
        success: true,
        message: 'Payment processed successfully',
        newBalance: newBalance.toFixed(2)
      });

    } catch (error: any) {
      console.error('Wallet payment error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process wallet payment'
      });
    }
  });

  // Calculate pro-rated upgrade cost
  app.post('/api/calculate-upgrade-cost', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { targetTier, billingCycle } = req.body;

      if (!userId || !targetTier || !billingCycle) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      // Get current subscription details
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'User profile not found'
        });
      }

      const profile = userProfile[0];
      const currentTier = profile.subscriptionTier;
      const planExpiry = profile.planExpiry;

      if (!currentTier || !planExpiry) {
        return res.status(400).json({
          success: false,
          error: 'No active subscription found'
        });
      }

      // Import GRADE_SUBSCRIPTION_PLANS
      const { GRADE_SUBSCRIPTION_PLANS } = await import('@shared/schema');
      
      // Get current and target plan details
      const currentPlan = GRADE_SUBSCRIPTION_PLANS[currentTier as keyof typeof GRADE_SUBSCRIPTION_PLANS];
      const targetPlan = GRADE_SUBSCRIPTION_PLANS[targetTier as keyof typeof GRADE_SUBSCRIPTION_PLANS];

      if (!currentPlan || !targetPlan) {
        return res.status(400).json({
          success: false,
          error: 'Invalid subscription tier'
        });
      }

      // Calculate remaining days
      const now = new Date();
      const expiryDate = new Date(planExpiry);
      const daysRemaining = Math.max(0, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));

      // Determine billing period length
      const currentBillingCycle = billingCycle as 'monthly' | 'yearly';
      const daysInPeriod = currentBillingCycle === 'monthly' ? 30 : 365;

      // Calculate pro-rated credit from current plan
      const currentPlanPrice = currentPlan.pricing[currentBillingCycle];
      const dailyRate = currentPlanPrice / daysInPeriod;
      const credit = dailyRate * daysRemaining;

      // Calculate target plan cost
      const targetPlanPrice = targetPlan.pricing[currentBillingCycle];

      // Calculate upgrade cost (what they need to pay)
      const upgradeCost = Math.max(0, targetPlanPrice - credit);

      res.json({
        success: true,
        data: {
          currentTier,
          targetTier,
          daysRemaining,
          credit: parseFloat(credit.toFixed(2)),
          targetPlanPrice: parseFloat(targetPlanPrice.toFixed(2)),
          upgradeCost: parseFloat(upgradeCost.toFixed(2)),
          billingCycle: currentBillingCycle,
          expiryDate: expiryDate.toISOString()
        }
      });
    } catch (error: any) {
      console.error('Calculate upgrade cost error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to calculate upgrade cost'
      });
    }
  });

  // Process pro-rated subscription upgrade
  app.post('/api/upgrade-subscription', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      const { targetTier, billingCycle, paymentIntentId } = req.body;

      if (!userId || !targetTier || !billingCycle || !paymentIntentId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({
          success: false,
          error: 'Payment system not available'
        });
      }

      // Verify payment
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      // Get current subscription
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'User profile not found'
        });
      }

      const profile = userProfile[0];
      const planExpiry = profile.planExpiry;

      if (!planExpiry) {
        return res.status(400).json({
          success: false,
          error: 'No active subscription to upgrade'
        });
      }

      // Calculate new expiry date (keep remaining days)
      const now = new Date();
      const expiryDate = new Date(planExpiry);
      const daysRemaining = Math.max(0, Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)));
      
      // New expiry is current time + days remaining
      const newExpiry = new Date();
      newExpiry.setDate(newExpiry.getDate() + daysRemaining);

      // Update user's subscription
      await db.update(profiles)
        .set({
          subscriptionTier: targetTier,
          planExpiry: newExpiry,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      res.json({
        success: true,
        message: 'Subscription upgraded successfully',
        data: {
          newTier: targetTier,
          newExpiry: newExpiry.toISOString(),
          daysRemaining
        }
      });
    } catch (error: any) {
      console.error('Upgrade subscription error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to upgrade subscription'
      });
    }
  });

  // Create Zod schemas for guest order validation
  const guestCartItemSchema = z.object({
    productId: z.string().uuid(),
    quantity: z.number().int().min(1).max(100),
    productName: z.string().min(1).max(200),
    productType: z.enum(['digital', 'physical']),
    priceAtAdd: z.string().regex(/^\d+(\.\d{1,2})?$/).transform(str => parseFloat(str)) // Validate price format
  });

  const guestOrderRequestSchema = z.object({
    orderId: z.string().min(1, 'Order ID is required'),
    currency: z.string().default('USD'),
    userId: z.string().optional(),
    // For guest orders, require cart items to calculate server-side totals
    guestCartItems: z.array(guestCartItemSchema).min(1).max(50).optional(), // Max 50 items per order
    guestEmail: z.string().email().optional() // Guest email for receipts
  });

  // Cart/Order Payment Intent - Secure implementation for authenticated and guest users  
  app.post('/api/create-order-payment-intent', async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Input validation using comprehensive Zod schema
      const validationResult = guestOrderRequestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.errors
        });
      }

      const { orderId, currency, userId, guestCartItems, guestEmail } = validationResult.data;

      // Determine if this is a guest or authenticated user order
      let order = null;
      let isGuestOrder = false;
      let authenticatedUser = null;
      
      // Check for authentication first
      const authHeader = req.headers.authorization;
      const sessionId = authHeader?.replace('Bearer ', '') || req.headers['x-session-id'] as string;
      
      if (sessionId) {
        // Validate session for authenticated users
        try {
          const session = await db.select()
            .from(userLoginSessions)
            .where(and(
              eq(userLoginSessions.sessionId, sessionId),
              eq(userLoginSessions.isActive, true),
              gt(userLoginSessions.expiresAt, new Date())
            ))
            .limit(1);

          if (session.length > 0) {
            const userProfile = await db.select({
              id: users.id,
              userId: users.userId,
              email: users.email,
              role: profiles.role
            })
            .from(users)
            .innerJoin(profiles, eq(users.id, profiles.userId))
            .where(eq(users.id, session[0].userId))
            .limit(1);

            if (userProfile.length > 0) {
              authenticatedUser = userProfile[0];
            }
          }
        } catch (authError) {
          console.error('Auth validation error:', authError);
          // Continue as guest if auth fails
        }
      }

      // Handle guest orders
      if (!authenticatedUser && (orderId.startsWith('guest-') || userId === 'guest')) {
        isGuestOrder = true;
        
        if (!guestCartItems || guestCartItems.length === 0) {
          return res.status(400).json({
            success: false,
            error: 'Cart items are required for guest orders'
          });
        }

        if (!guestEmail) {
          return res.status(400).json({
            success: false,
            error: 'Email is required for guest orders'
          });
        }

        // Calculate server-side total from cart items - NEVER trust client amounts
        let calculatedTotal = 0;
        const validatedItems = [];
        
        for (const item of guestCartItems) {
          // Validate product exists and get current price
          const [product] = await db
            .select({
              id: products.id,
              name: products.name,
              price: products.price,
              type: products.type,
              status: products.status,
              stock: products.stock
            })
            .from(products)
            .where(and(
              eq(products.id, item.productId),
              eq(products.status, 'approved') // Only allow approved products
            ))
            .limit(1);

          if (!product) {
            return res.status(400).json({
              success: false,
              error: `Product not found or unavailable: ${item.productName}`
            });
          }

          // Check stock for physical products
          if (product.type === 'physical' && product.stock && product.stock < item.quantity) {
            return res.status(400).json({
              success: false,
              error: `Insufficient stock for ${product.name}. Available: ${product.stock}, Requested: ${item.quantity}`
            });
          }

          // Use current product price, not client-provided price for security
          const currentPrice = parseFloat(product.price);
          const itemTotal = currentPrice * item.quantity;
          calculatedTotal += itemTotal;

          validatedItems.push({
            ...item,
            priceAtAdd: currentPrice, // Use server-verified price
            productName: product.name, // Use server product name
            productType: product.type // Use server product type
          });
        }

        // Create temporary order object with server-calculated total
        order = {
          id: orderId,
          totalAmount: calculatedTotal.toFixed(2),
          currency: currency || 'USD',
          status: 'pending',
          items: validatedItems,
          guestEmail
        };
      } 
      // Handle authenticated user orders
      else if (authenticatedUser) {
        // For authenticated users, verify order exists and belongs to user
        console.log('ðŸ” Looking up order:', { orderId, userId: authenticatedUser.id });
        
        // Retry logic to handle database replication lag
        let dbOrder = null;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (!dbOrder && retryCount < maxRetries) {
          const [foundOrder] = await db
            .select()
            .from(orders)
            .where(and(
              eq(orders.id, orderId),
              eq(orders.userId, authenticatedUser.id),
              eq(orders.status, 'pending')
            ))
            .limit(1);
          
          if (foundOrder) {
            dbOrder = foundOrder;
          } else if (retryCount < maxRetries - 1) {
            // Wait 100ms before retrying
            await new Promise(resolve => setTimeout(resolve, 100));
            retryCount++;
          } else {
            break;
          }
        }

        console.log('ðŸ” Order lookup result:', dbOrder ? 'Found' : `Not found after ${retryCount + 1} attempts`);
        
        if (!dbOrder) {
          // Debug: Check if order exists with different userId
          const [anyOrder] = await db
            .select()
            .from(orders)
            .where(eq(orders.id, orderId))
            .limit(1);
          
          console.log('ðŸ” Order exists with any userId?', anyOrder ? `Yes (userId: ${anyOrder.userId}, status: ${anyOrder.status})` : 'No');
          
          return res.status(404).json({
            success: false,
            error: 'Order not found, already processed, or access denied'
          });
        }
        
        order = dbOrder;
      } else {
        // Neither authenticated nor valid guest order
        return res.status(401).json({
          success: false,
          error: 'Authentication required for user orders, or invalid guest order format'
        });
      }

      // Create payment intent using server-calculated amount (never trust client amount)
      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(parseFloat(order.totalAmount) * 100), // Convert to cents
        currency: (order.currency || 'USD').toLowerCase(),
        metadata: {
          orderId: order.id,
          orderNumber: `${isGuestOrder ? 'GUEST' : 'ORDER'}-${Date.now()}`,
          userId: authenticatedUser?.id || 'guest',
          userEmail: authenticatedUser?.email || (isGuestOrder ? (order as any).guestEmail : ''),
          type: 'order_payment',
          isGuestOrder: isGuestOrder.toString(),
          itemCount: isGuestOrder ? ((order as any).items?.length || 0).toString() : '1'
        }
      });

      res.json({
        success: true,
        clientSecret: paymentIntent.client_secret,
        paymentIntentId: paymentIntent.id,
        currency: order.currency || 'USD',
        amount: order.totalAmount,
        isGuestOrder,
        calculatedFromItems: isGuestOrder // Indicate if total was server-calculated
      });

    } catch (error: any) {
      console.error('Order payment intent error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create payment intent'
      });
    }
  });

  // Get Payment Success Details - Retrieve payment information for success page
  app.get('/api/payment-success/:sessionId', async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      const { sessionId } = req.params;

      if (!sessionId) {
        return res.status(400).json({
          success: false,
          error: 'Session ID is required'
        });
      }

      // Retrieve payment intent from Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(sessionId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      // Return payment details
      res.json({
        success: true,
        paymentIntent: {
          id: paymentIntent.id,
          amount: paymentIntent.amount,
          currency: paymentIntent.currency,
          status: paymentIntent.status,
          metadata: paymentIntent.metadata
        }
      });

    } catch (error: any) {
      console.error('Payment success retrieval error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to retrieve payment details'
      });
    }
  });

  // Helper function to check and update download limits
  async function checkDownloadLimits(userId: string, productIds: string[]): Promise<{ canDownload: boolean; reason?: string; limitType?: string }> {
    try {
      // Get user's customer record
      const customer = await storage.getShopCustomerByUserId(userId);
      if (!customer) {
        return { canDownload: true }; // No customer record, allow (guest or first-time)
      }

      // Get membership
      const membership = await storage.getShopMembershipByCustomerId(customer.id);
      if (!membership) {
        return { canDownload: true }; // No membership, allow
      }

      // Get plan details
      const [planDetails] = await db
        .select()
        .from(shopMembershipPlans)
        .where(eq(shopMembershipPlans.planId, membership.plan))
        .limit(1);

      if (!planDetails) {
        return { canDownload: true }; // No plan details, allow
      }

      // Get product details to check if free or paid
      const productDetails = await db
        .select({
          id: products.id,
          price: products.price,
          type: products.type
        })
        .from(products)
        .where(inArray(products.id, productIds));

      const hasPaidProducts = productDetails.some(p => parseFloat(p.price) > 0);
      const now = new Date();

      // Check if daily reset is needed
      const lastDailyReset = membership.lastDailyResetDate ? new Date(membership.lastDailyResetDate) : new Date(0);
      const daysSinceReset = Math.floor((now.getTime() - lastDailyReset.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysSinceReset >= 1) {
        // Reset daily counter
        await db
          .update(shopMemberships)
          .set({
            dailyDownloadsUsed: 0,
            lastDailyResetDate: now
          })
          .where(eq(shopMemberships.id, membership.id));
        membership.dailyDownloadsUsed = 0;
      }

      // Check if monthly reset is needed
      const lastMonthlyReset = membership.lastMonthlyResetDate ? new Date(membership.lastMonthlyResetDate) : new Date(0);
      const monthsSinceReset = (now.getFullYear() - lastMonthlyReset.getFullYear()) * 12 + (now.getMonth() - lastMonthlyReset.getMonth());
      
      if (monthsSinceReset >= 1) {
        // Reset monthly counter
        await db
          .update(shopMemberships)
          .set({
            monthlyPaidDownloadsUsed: 0,
            lastMonthlyResetDate: now
          })
          .where(eq(shopMemberships.id, membership.id));
        membership.monthlyPaidDownloadsUsed = 0;
      }

      // Check limits only for paid products (free products are unlimited)
      if (hasPaidProducts) {
        // Check daily limit for paid products
        if (planDetails.dailyDownloadLimit !== null) {
          const currentDailyUsed = membership.dailyDownloadsUsed || 0;
          if (currentDailyUsed >= planDetails.dailyDownloadLimit) {
            return { 
              canDownload: false, 
              reason: `Daily download limit reached (${planDetails.dailyDownloadLimit}/day). Resets tomorrow.`,
              limitType: 'daily'
            };
          }
        }


        // Free plan cannot download paid products
        if (planDetails.monthlyPaidDownloadLimit === 0) {
          return {
            canDownload: false,
            reason: 'Free plan members cannot download paid products. Please upgrade your membership.',
            limitType: 'plan'
          };
        }

        // Check monthly limit for paid products
        if (planDetails.monthlyPaidDownloadLimit !== null) {
          const currentMonthlyUsed = membership.monthlyPaidDownloadsUsed || 0;
          if (currentMonthlyUsed >= planDetails.monthlyPaidDownloadLimit) {
            return {
              canDownload: false,
              reason: `Monthly paid product download limit reached (${planDetails.monthlyPaidDownloadLimit}/month). Resets next month.`,
              limitType: 'monthly'
            };
          }
        }
      }

      // All checks passed, increment counters (only for paid products)
      const dailyIncrement = hasPaidProducts ? 1 : 0;
      const monthlyIncrement = hasPaidProducts ? 1 : 0;

      await db
        .update(shopMemberships)
        .set({
          dailyDownloadsUsed: (membership.dailyDownloadsUsed || 0) + dailyIncrement,
          monthlyPaidDownloadsUsed: (membership.monthlyPaidDownloadsUsed || 0) + monthlyIncrement
        })
        .where(eq(shopMemberships.id, membership.id));

      return { canDownload: true };
    } catch (error) {
      console.error('Error checking download limits:', error);
      return { canDownload: true }; // On error, allow download to not block users
    }
  }

  // Helper function to generate download tokens for digital products
  async function generateDownloadTokensForOrder(orderId: string, buyerUserId: string | null) {
    try {
      // Get order items with product details
      const items = await db
        .select({
          orderItemId: orderItems.id,
          productId: orderItems.productId,
          product: products
        })
        .from(orderItems)
        .leftJoin(products, eq(orderItems.productId, products.id))
        .where(eq(orderItems.orderId, orderId));

      // Filter digital products
      const digitalProducts = items.filter(item => item.product?.type === 'digital');
      
      if (digitalProducts.length === 0) {
        return { hasDigitalProducts: false, tokens: [] };
      }

      // Generate tokens for each digital product
      const tokens = [];
      const now = new Date();
      const expiresAt = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000); // 1 month from now

      for (const item of digitalProducts) {
        if (!item.product) continue;
        
        // Generate secure token
        const crypto = await import('crypto');
        const downloadToken = crypto.randomBytes(32).toString('hex');

        // Create download record - downloadedAt is null until actual download occurs
        const [downloadRecord] = await db
          .insert(downloads)
          .values({
            userId: buyerUserId || '00000000-0000-0000-0000-000000000000', // Use null UUID for guests
            productId: item.productId,
            orderId: orderId,
            downloadToken: downloadToken,
            expiresAt: expiresAt,
            isExpired: false
            // downloadedAt will be set when user actually downloads
          })
          .returning();

        tokens.push({
          productId: item.productId,
          productName: item.product.name,
          downloadToken: downloadToken,
          expiresAt: expiresAt
        });
      }

      // Update order with digital fulfillment status and expiration
      await db
        .update(orders)
        .set({
          digitalFulfillmentStatus: 'pending',
          downloadLinksExpiresAt: expiresAt,
          updatedAt: now
        })
        .where(eq(orders.id, orderId));

      return { hasDigitalProducts: true, tokens, expiresAt };
    } catch (error) {
      console.error('Error generating download tokens:', error);
      // Bubble up the error instead of swallowing it
      throw new Error(`Failed to generate download tokens: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  // Confirm Order Payment - Secure implementation for both authenticated and guest users
  app.post('/api/confirm-order-payment', async (req, res) => {
    try {
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ 
          success: false, 
          error: 'Payment system not available' 
        });
      }

      // Input validation using Zod
      const requestSchema = z.object({
        paymentIntentId: z.string().min(1, 'Payment Intent ID is required'),
        orderId: z.string().min(1, 'Order ID is required').optional() // Optional since we can get from payment intent metadata
      });

      const validationResult = requestSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Invalid request data',
          details: validationResult.error.errors
        });
      }

      const { paymentIntentId } = validationResult.data;

      // Retrieve payment intent to verify it succeeded
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
      
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not completed'
        });
      }

      const { orderId, type, isGuestOrder, userId, userEmail } = paymentIntent.metadata;

      if (type !== 'order_payment') {
        return res.status(400).json({
          success: false,
          error: 'Invalid payment type'
        });
      }

      if (!orderId) {
        return res.status(400).json({
          success: false,
          error: 'Order ID missing from payment intent metadata'
        });
      }

      const isGuest = isGuestOrder === 'true';

      // Handle guest orders
      if (isGuest) {
        // For guest orders, update existing order (created via /guest-checkout endpoint)
        try {
          // Find existing guest order by order ID or create from payment intent metadata
          let existingOrder = null;
          
          if (orderId) {
            // Try to find existing order by ID for guest orders created via /guest-checkout
            const orderResults = await db
              .select()
              .from(orders)
              .where(and(
                eq(orders.id, orderId),
                isNull(orders.userId), // Guest orders have null userId
                isNotNull(orders.guestEmail) // And non-null guestEmail
              ))
              .limit(1);
            
            existingOrder = orderResults[0] || null;
          }
          
          // Check if already processed by payment intent ID
          const duplicateCheck = await db
            .select()
            .from(orders)
            .where(eq(orders.paymentIntentId, paymentIntentId))
            .limit(1);

          if (duplicateCheck.length > 0) {
            return res.json({
              success: true,
              message: 'Order already processed',
              order: duplicateCheck[0],
              alreadyProcessed: true
            });
          }

          if (existingOrder) {
            // Update existing guest order created via /guest-checkout
            const [updatedOrder] = await db
              .update(orders)
              .set({
                status: 'paid',
                paymentIntentId: paymentIntentId,
                completedAt: new Date(),
                updatedAt: new Date()
              })
              .where(eq(orders.id, existingOrder.id))
              .returning();

            console.log('âœ… Guest order confirmed:', {
              orderId: updatedOrder.id,
              guestEmail: updatedOrder.guestEmail,
              amount: updatedOrder.totalAmount,
              paymentIntentId
            });

            // Generate download tokens for digital products
            const downloadTokens = await generateDownloadTokensForOrder(updatedOrder.id, null);

            // Send email notification for digital products
            if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
              try {
                const { emailService } = await import('./utils/email.js');
                const emailSent = await emailService.sendDigitalProductPurchaseEmail(updatedOrder.guestEmail!, {
                  orderId: updatedOrder.id,
                  totalPrice: parseFloat(updatedOrder.totalAmount),
                  items: downloadTokens.tokens.map(t => ({
                    name: t.productName,
                    downloadToken: t.downloadToken,
                    expiresAt: t.expiresAt
                  }))
                });

                // Only update status if email was actually sent
                if (emailSent) {
                  await db
                    .update(orders)
                    .set({
                      downloadEmailSent: true,
                      downloadEmailSentAt: new Date(),
                      digitalFulfillmentStatus: 'sent',
                      updatedAt: new Date()
                    })
                    .where(eq(orders.id, updatedOrder.id));

                  console.log('âœ… Digital product email sent to:', updatedOrder.guestEmail);
                } else {
                  console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
                }
              } catch (emailError) {
                console.error('âŒ Failed to send digital product email:', emailError);
                // Don't fail the order, just log the error
              }
            }

            res.json({
              success: true,
              message: 'Guest payment confirmed and order completed',
              order: updatedOrder,
              downloadTokens: downloadTokens.tokens,
              hasDigitalProducts: downloadTokens.hasDigitalProducts,
              isGuestOrder: true
            });
          } else {
            // Fallback: Create new guest order (for legacy guest payments)
            const [newOrder] = await db
              .insert(orders)
              .values({
                userId: null, // Guest orders have null userId
                guestEmail: userEmail, // Store guest email
                totalAmount: (paymentIntent.amount / 100).toFixed(2), // Convert from cents
                currency: paymentIntent.currency.toUpperCase(),
                status: 'paid',
                paymentIntentId: paymentIntentId,
                paymentMethod: 'stripe',
                customerNotes: `Guest order - Email: ${userEmail}`,
                completedAt: new Date()
              })
              .returning();

            console.log('âœ… Guest order created and completed:', {
              orderId: newOrder.id,
              guestEmail: newOrder.guestEmail,
              amount: newOrder.totalAmount,
              paymentIntentId
            });

            // Generate download tokens for digital products
            const downloadTokens = await generateDownloadTokensForOrder(newOrder.id, null);

            // Send email notification for digital products
            if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
              try {
                const { emailService } = await import('./utils/email.js');
                const emailSent = await emailService.sendDigitalProductPurchaseEmail(newOrder.guestEmail!, {
                  orderId: newOrder.id,
                  totalPrice: parseFloat(newOrder.totalAmount),
                  items: downloadTokens.tokens.map(t => ({
                    name: t.productName,
                    downloadToken: t.downloadToken,
                    expiresAt: t.expiresAt
                  }))
                });

                // Only update status if email was actually sent
                if (emailSent) {
                  await db
                    .update(orders)
                    .set({
                      downloadEmailSent: true,
                      downloadEmailSentAt: new Date(),
                      digitalFulfillmentStatus: 'sent',
                      updatedAt: new Date()
                    })
                    .where(eq(orders.id, newOrder.id));

                  console.log('âœ… Digital product email sent to:', newOrder.guestEmail);
                } else {
                  console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
                }
              } catch (emailError) {
                console.error('âŒ Failed to send digital product email:', emailError);
              }
            }

            res.json({
              success: true,
              message: 'Guest payment confirmed and order completed',
              order: newOrder,
              downloadTokens: downloadTokens.tokens,
              hasDigitalProducts: downloadTokens.hasDigitalProducts,
              isGuestOrder: true
            });
          }

        } catch (guestError) {
          console.error('Guest order confirmation error:', guestError);
          return res.status(500).json({
            success: false,
            error: 'Payment successful but failed to confirm guest order'
          });
        }
      } 
      // Handle authenticated user orders
      else {
        // Get authentication for regular users
        const authHeader = req.headers.authorization;
        const sessionId = authHeader?.replace('Bearer ', '') || req.headers['x-session-id'] as string;
        
        if (!sessionId) {
          return res.status(401).json({
            success: false,
            error: 'Authentication required for user orders'
          });
        }

        // Validate session
        const session = await db.select()
          .from(userLoginSessions)
          .where(and(
            eq(userLoginSessions.sessionId, sessionId),
            eq(userLoginSessions.isActive, true),
            gt(userLoginSessions.expiresAt, new Date())
          ))
          .limit(1);

        if (session.length === 0) {
          return res.status(401).json({
            success: false,
            error: 'Invalid or expired session'
          });
        }

        const authenticatedUserId = session[0].userId;

        // Additional security: verify the order belongs to the authenticated user
        const [existingOrder] = await db
          .select()
          .from(orders)
          .where(and(
            eq(orders.id, orderId),
            eq(orders.userId, authenticatedUserId)
          ))
          .limit(1);

        if (!existingOrder) {
          return res.status(404).json({
            success: false,
            error: 'Order not found or access denied'
          });
        }

        // Verify payment intent metadata matches our order and authenticated user
        if (paymentIntent.metadata.orderId !== orderId || paymentIntent.metadata.userId !== authenticatedUserId) {
          return res.status(400).json({
            success: false,
            error: 'Payment intent does not match order details or authenticated user'
          });
        }

        // Double-check payment amount matches order amount for security
        const expectedAmountInCents = Math.round(parseFloat(existingOrder.totalAmount) * 100);
        if (paymentIntent.amount !== expectedAmountInCents) {
          return res.status(400).json({
            success: false,
            error: 'Payment amount does not match order total'
          });
        }

        // Update existing order
        const [updatedOrder] = await db
          .update(orders)
          .set({
            status: 'paid' as const,
            paymentIntentId: paymentIntentId,
            completedAt: new Date(),
            updatedAt: new Date()
          })
          .where(and(
            eq(orders.id, orderId),
            eq(orders.userId, authenticatedUserId)
          ))
          .returning();

        if (!updatedOrder) {
          return res.status(404).json({
            success: false,
            error: 'Failed to update order status'
          });
        }

        // ===== CRITICAL FIX: Create shopPurchases entries so purchases appear in dashboard =====
        try {
          // Get or create shop customer
          let [shopCustomer] = await db
            .select()
            .from(shopCustomers)
            .where(eq(shopCustomers.userId, authenticatedUserId))
            .limit(1);

          if (!shopCustomer) {
            // Create shop customer if doesn't exist
            const [user] = await db
              .select()
              .from(users)
              .where(eq(users.id, authenticatedUserId))
              .limit(1);

            if (user) {
              [shopCustomer] = await db
                .insert(shopCustomers)
                .values({
                  userId: authenticatedUserId,
                  fullName: user.fullName || user.email,
                  email: user.email,
                  accountType: 'free'
                })
                .returning();
            }
          }

          if (shopCustomer) {
            // Get order items to create shop purchases
            const items = await db
              .select({
                orderItem: orderItems,
                product: products
              })
              .from(orderItems)
              .leftJoin(products, eq(orderItems.productId, products.id))
              .where(eq(orderItems.orderId, updatedOrder.id));

            // Create shop purchase entry for each item
            for (const item of items) {
              if (item.product) {
                await db.insert(shopPurchases).values({
                  customerId: shopCustomer.id,
                  itemName: item.product.name,
                  itemType: item.product.type || 'digital',
                  downloadUrl: item.product.fileUrl || '',
                  thumbnailUrl: item.product.images?.[0] || null,
                  price: item.orderItem.unitPrice,
                  orderId: updatedOrder.id,
                  status: 'completed'
                });
              }
            }

            console.log('âœ… Created shop purchase records for order:', updatedOrder.id);
          }
        } catch (purchaseError) {
          console.error('Failed to create shop purchases (non-critical):', purchaseError);
          // Don't fail the payment confirmation, but log the error
        }
        // ===== END CRITICAL FIX =====

        // NOTE: Download limits are now checked at download time, not at purchase time
        // A user who pays for a product should always be able to access their purchase
        // regardless of their download limits at the time of payment confirmation

        // Generate download tokens for digital products
        const downloadTokens = await generateDownloadTokensForOrder(updatedOrder.id, authenticatedUserId);

        // Send email notification for digital products
        if (downloadTokens.hasDigitalProducts && downloadTokens.tokens.length > 0) {
          try {
            // Get user email
            const [user] = await db
              .select()
              .from(users)
              .where(eq(users.id, authenticatedUserId))
              .limit(1);

            if (user?.email) {
              const { emailService } = await import('./utils/email.js');
              const emailSent = await emailService.sendDigitalProductPurchaseEmail(user.email, {
                orderId: updatedOrder.id,
                customerName: user.fullName || undefined,
                totalPrice: parseFloat(updatedOrder.totalAmount),
                items: downloadTokens.tokens.map(t => ({
                  name: t.productName,
                  downloadToken: t.downloadToken,
                  expiresAt: t.expiresAt
                }))
              });

              // Only update status if email was actually sent
              if (emailSent) {
                await db
                  .update(orders)
                  .set({
                    downloadEmailSent: true,
                    downloadEmailSentAt: new Date(),
                    digitalFulfillmentStatus: 'sent',
                    updatedAt: new Date()
                  })
                  .where(eq(orders.id, updatedOrder.id));

                console.log('âœ… Digital product email sent to:', user.email);
              } else {
                console.warn('âš ï¸ Email service not configured or failed, keeping fulfillment status as pending');
              }
            }
          } catch (emailError) {
            console.error('âŒ Failed to send digital product email:', emailError);
          }
        }

        res.json({
          success: true,
          message: 'Payment confirmed and order completed',
          order: updatedOrder,
          downloadTokens: downloadTokens.tokens,
          hasDigitalProducts: downloadTokens.hasDigitalProducts,
          isGuestOrder: false
        });
      }

    } catch (error: any) {
      console.error('Order payment confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm payment'
      });
    }
  });

  // ============================================
  // TRANSACTION MANAGEMENT API ENDPOINTS
  // ============================================

  // Get user balance
  app.get('/api/transactions/balance/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      const userBalance = await db
        .select()
        .from(userBalances)
        .where(eq(userBalances.userId, userId))
        .limit(1);

      if (userBalance.length === 0) {
        // Create initial balance if doesn't exist
        const [newBalance] = await db
          .insert(userBalances)
          .values({
            userId: userId,
            availableBalance: '0.00',
            totalEarnings: '0.00',
            totalWithdrawn: '0.00',
            pendingPayouts: '0.00'
          })
          .returning();

        return res.json({
          success: true,
          balance: newBalance
        });
      }

      res.json({
        success: true,
        balance: userBalance[0]
      });

    } catch (error) {
      console.error('Error fetching user balance:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch balance'
      });
    }
  });

  // Get user transactions with filters
  app.get('/api/transactions/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      const { type, status, method, page = 1, limit = 10 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select()
        .from(transactions)
        .where(eq(transactions.userId, userId));

      // Apply filters
      if (type) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.type, type as string)));
      }
      if (status) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.status, status as string)));
      }
      if (method) {
        query = query.where(and(eq(transactions.userId, userId), eq(transactions.method, method as string)));
      }

      const userTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count for pagination
      const totalCountResult = await db
        .select({ count: count() })
        .from(transactions)
        .where(eq(transactions.userId, userId));

      res.json({
        success: true,
        transactions: userTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });

    } catch (error) {
      console.error('Error fetching transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Request payout
  app.post('/api/transactions/request-payout', async (req, res) => {
    try {
      const { userId, amount, payoutAccountId, description } = req.body;

      if (!userId || !amount || !payoutAccountId) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: userId, amount, payoutAccountId'
        });
      }

      // Check user balance
      const userBalance = await db
        .select()
        .from(userBalances)
        .where(eq(userBalances.userId, userId))
        .limit(1);

      if (userBalance.length === 0 || Number(userBalance[0].availableBalance) < Number(amount)) {
        return res.status(400).json({
          success: false,
          error: 'Insufficient balance'
        });
      }

      // Check payout account exists and is verified
      const payoutAccount = await db
        .select()
        .from(payoutAccounts)
        .where(and(
          eq(payoutAccounts.id, payoutAccountId),
          eq(payoutAccounts.userId, userId),
          eq(payoutAccounts.isVerified, true)
        ))
        .limit(1);

      if (payoutAccount.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Payout account not found or not verified'
        });
      }

      // Create payout transaction
      const [newTransaction] = await db
        .insert(transactions)
        .values({
          userId: userId,
          type: 'debit',
          amount: amount.toString(),
          status: 'pending',
          method: payoutAccount[0].type,
          description: description || `Payout to ${payoutAccount[0].accountName}`,
          payoutAccountId: payoutAccountId
        })
        .returning();

      // Update pending payouts
      await db
        .update(userBalances)
        .set({
          pendingPayouts: sql`${userBalances.pendingPayouts} + ${amount}`,
          lastUpdated: new Date()
        })
        .where(eq(userBalances.userId, userId));

      res.json({
        success: true,
        transaction: newTransaction,
        message: 'Payout request submitted successfully'
      });

    } catch (error) {
      console.error('Error requesting payout:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to request payout'
      });
    }
  });

  // Get user payout accounts
  app.get('/api/payout-accounts/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      const accounts = await db
        .select({
          id: payoutAccounts.id,
          type: payoutAccounts.type,
          accountName: payoutAccounts.accountName,
          isVerified: payoutAccounts.isVerified,
          isDefault: payoutAccounts.isDefault,
          createdAt: payoutAccounts.createdAt,
          // Mask sensitive details
          details: sql`jsonb_build_object(
            'masked', true,
            'type', ${payoutAccounts.type}
          )`
        })
        .from(payoutAccounts)
        .where(eq(payoutAccounts.userId, userId))
        .orderBy(desc(payoutAccounts.isDefault), desc(payoutAccounts.createdAt));

      res.json({
        success: true,
        accounts: accounts
      });

    } catch (error) {
      console.error('Error fetching payout accounts:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch payout accounts'
      });
    }
  });

  // Add payout account
  app.post('/api/payout-accounts', async (req, res) => {
    try {
      // Validate request body using Zod schema
      const validationResult = insertPayoutAccountSchema.safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: validationResult.error.issues.map(issue => ({
            field: issue.path.join('.'),
            message: issue.message
          }))
        });
      }

      const { userId, type, accountName, details, isDefault } = validationResult.data;

      // If setting as default, remove default from other accounts
      if (isDefault) {
        await db
          .update(payoutAccounts)
          .set({ isDefault: false })
          .where(eq(payoutAccounts.userId, userId));
      }

      const [newAccount] = await db
        .insert(payoutAccounts)
        .values({
          userId: userId,
          type: type,
          accountName: accountName,
          details: details,
          isDefault: isDefault || false,
          isVerified: false // Admin needs to verify
        })
        .returning();

      res.json({
        success: true,
        account: {
          ...newAccount,
          details: { masked: true, type: newAccount.type } // Mask in response
        },
        message: 'Payout account added successfully. Pending admin verification.'
      });

    } catch (error) {
      console.error('Error adding payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to add payout account'
      });
    }
  });

  // Set default payout account
  app.put('/api/payout-accounts/:accountId/set-default', async (req, res) => {
    try {
      const { accountId } = req.params;
      const { userId } = req.body;

      // First, get the account to verify ownership
      const account = await db
        .select()
        .from(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId))
        .limit(1);

      if (account.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Payout account not found'
        });
      }

      // Verify ownership (if userId is provided)
      if (userId && account[0].userId !== userId) {
        return res.status(403).json({
          success: false,
          error: 'Unauthorized access to payout account'
        });
      }

      // Remove default from all user's accounts
      await db
        .update(payoutAccounts)
        .set({ isDefault: false })
        .where(eq(payoutAccounts.userId, account[0].userId));

      // Set this account as default
      await db
        .update(payoutAccounts)
        .set({ isDefault: true })
        .where(eq(payoutAccounts.id, accountId));

      res.json({
        success: true,
        message: 'Default payout account updated successfully'
      });

    } catch (error) {
      console.error('Error setting default payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to set default payout account'
      });
    }
  });

  // Delete payout account
  app.delete('/api/payout-accounts/:accountId', async (req, res) => {
    try {
      const { accountId } = req.params;
      const { userId } = req.body;

      // First, get the account to verify ownership
      const account = await db
        .select()
        .from(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId))
        .limit(1);

      if (account.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Payout account not found'
        });
      }

      // Verify ownership (if userId is provided)
      if (userId && account[0].userId !== userId) {
        return res.status(403).json({
          success: false,
          error: 'Unauthorized access to payout account'
        });
      }

      // Check if there are pending transactions using this account
      const pendingTransactions = await db
        .select()
        .from(transactions)
        .where(and(
          eq(transactions.payoutAccountId, accountId),
          eq(transactions.status, 'pending')
        ))
        .limit(1);

      if (pendingTransactions.length > 0) {
        return res.status(400).json({
          success: false,
          error: 'Cannot delete account with pending transactions'
        });
      }

      // Delete the account
      await db
        .delete(payoutAccounts)
        .where(eq(payoutAccounts.id, accountId));

      res.json({
        success: true,
        message: 'Payout account deleted successfully'
      });

    } catch (error) {
      console.error('Error deleting payout account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete payout account'
      });
    }
  });

  // Admin: Get all transactions with filters

  app.get('/api/admin/transactions', requireAdmin, async (req, res) => {
    try {
      const { status, method, userId, page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: transactions.id,
          userId: transactions.userId,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt,
          processedAt: transactions.processedAt,
          adminNotes: transactions.adminNotes,
          // Join with user profile for user name
          userName: profiles.name,
          userEmail: profiles.email
        })
        .from(transactions)
        .leftJoin(profiles, eq(transactions.userId, profiles.userId));

      // Apply filters
      const conditions = [];
      if (status) conditions.push(eq(transactions.status, status as string));
      if (method) conditions.push(eq(transactions.method, method as string));
      if (userId) conditions.push(eq(transactions.userId, userId as string));

      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }

      const allTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count
      const totalCountResult = await db
        .select({ count: count() })
        .from(transactions);

      res.json({
        success: true,
        transactions: allTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });

    } catch (error) {
      console.error('Error fetching admin transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Admin: Approve/decline payout
  app.patch('/api/admin/transactions/:id/approve', requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { action, adminNotes, adminId } = req.body; // action: 'approve' or 'decline'

      if (!action || !adminId) {
        return res.status(400).json({
          success: false,
          error: 'Missing action or adminId'
        });
      }

      // Get transaction details
      const transaction = await db
        .select()
        .from(transactions)
        .where(eq(transactions.id, id))
        .limit(1);

      if (transaction.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Transaction not found'
        });
      }

      const tx = transaction[0];
      
      if (tx.status !== 'pending') {
        return res.status(400).json({
          success: false,
          error: 'Transaction is not pending'
        });
      }

      const newStatus = action === 'approve' ? 'completed' : 'failed';
      
      // Update transaction
      await db
        .update(transactions)
        .set({
          status: newStatus,
          processedBy: adminId,
          processedAt: new Date(),
          adminNotes: adminNotes || null
        })
        .where(eq(transactions.id, id));

      // Process actual payout if approved and method is PayPal
      let paypalPayoutId = null;
      if (action === 'approve' && tx.method === 'paypal') {
        try {
          // Get payout account details
          const payoutAccount = await db
            .select()
            .from(payoutAccounts)
            .where(eq(payoutAccounts.id, tx.payoutAccountId!))
            .limit(1);

          if (payoutAccount.length > 0) {
            const accountDetails = payoutAccount[0].details as any;
            
            // Create PayPal payout
            const request = new paypal.payouts.PayoutsPostRequest();
            request.requestBody({
              sender_batch_header: {
                sender_batch_id: `payout_${tx.id}_${Date.now()}`,
                email_subject: "You have a payout from EduFiliova!",
                email_message: "You have received a payout from your EduFiliova earnings."
              },
              items: [
                {
                  recipient_type: "EMAIL",
                  amount: {
                    value: tx.amount,
                    currency: "USD"
                  },
                  receiver: accountDetails.email,
                  note: tx.description,
                  sender_item_id: tx.id
                }
              ]
            });

            const client = paypalClient();
            const response = await client.execute(request);
            
            if (response.statusCode === 201) {
              paypalPayoutId = response.result.batch_header.payout_batch_id;
              console.log('âœ… PayPal payout processed:', paypalPayoutId);
            } else {
              throw new Error('PayPal payout failed');
            }
          }
        } catch (paypalError) {
          console.error('PayPal payout error:', paypalError);
          // Continue with the transaction but log the error
          // In production, you might want to set status to 'failed' and notify admin
        }
      }

      // Update transaction with PayPal payout ID if applicable
      await db
        .update(transactions)
        .set({
          status: newStatus,
          processedBy: adminId,
          processedAt: new Date(),
          adminNotes: adminNotes || null,
          paypalPayoutId: paypalPayoutId
        })
        .where(eq(transactions.id, id));

      // Update user balance
      if (action === 'approve') {
        // Deduct from available balance and pending payouts
        await db
          .update(userBalances)
          .set({
            availableBalance: sql`${userBalances.availableBalance} - ${tx.amount}`,
            totalWithdrawn: sql`${userBalances.totalWithdrawn} + ${tx.amount}`,
            pendingPayouts: sql`${userBalances.pendingPayouts} - ${tx.amount}`,
            lastUpdated: new Date()
          })
          .where(eq(userBalances.userId, tx.userId));
      } else {
        // Just remove from pending payouts
        await db
          .update(userBalances)
          .set({
            pendingPayouts: sql`${userBalances.pendingPayouts} - ${tx.amount}`,
            lastUpdated: new Date()
          })
          .where(eq(userBalances.userId, tx.userId));
      }

      res.json({
        success: true,
        message: `Payout ${action}d successfully`
      });

    } catch (error) {
      console.error('Error processing payout:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to process payout'
      });
    }
  });


  // Admin: Get transaction statistics for dashboard
  app.get('/api/admin/stats-test', requireAdmin, async (req, res) => {
    try {
      // Run all queries in parallel for better performance
      const [
        totalTransactionsResult,
        pendingPayoutsResult,
        totalVolumeResult,
        activeUsersResult,
        completedOrdersResult,
        topFreelancersResult,
        recentTransactionsResult,
        creatorEarningsResult
      ] = await Promise.all([
        // Total transactions count
        db.select({ count: count() }).from(transactions),
        
        // Pending payouts count (debit transactions that are pending)
        db.select({ count: count() })
          .from(transactions)
          .where(and(
            eq(transactions.type, 'debit'),
            eq(transactions.status, 'pending')
          )),
        
        // Total volume (sum of all transaction amounts)
        db.select({ total: sql<string>`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0)` })
          .from(transactions),
        
        // Active users (distinct users with transactions)
        db.selectDistinct({ userId: transactions.userId }).from(transactions),
        
        // Completed orders for revenue calculation
        db.select({ 
          total: sql<string>`COALESCE(SUM(CAST(${orders.totalAmount} AS DECIMAL)), 0)` 
        })
          .from(orders)
          .where(eq(orders.status, 'paid')),
        
        // Top freelancers by earnings
        db.select({
          userId: transactions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          totalEarnings: sql<string>`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0)`,
          transactionCount: count()
        })
          .from(transactions)
          .leftJoin(profiles, eq(transactions.userId, profiles.userId))
          .where(and(
            eq(transactions.type, 'credit'),
            eq(transactions.status, 'completed')
          ))
          .groupBy(transactions.userId, profiles.name, profiles.email)
          .orderBy(sql`COALESCE(SUM(CAST(${transactions.amount} AS DECIMAL)), 0) DESC`)
          .limit(10),
        
        // Recent transactions
        db.select({
          id: transactions.id,
          userId: transactions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt
        })
          .from(transactions)
          .leftJoin(profiles, eq(transactions.userId, profiles.userId))
          .orderBy(desc(transactions.createdAt))
          .limit(20),
        
        // Get creator earnings summary for commission calculation
        db.select({
          platformCommission: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.platformCommission} AS DECIMAL)), 0)`,
          creatorAmount: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.creatorAmount} AS DECIMAL)), 0)`,
          grossAmount: sql<string>`COALESCE(SUM(CAST(${creatorEarningEvents.grossAmount} AS DECIMAL)), 0)`
        })
          .from(creatorEarningEvents)
          .where(eq(creatorEarningEvents.status, 'available'))
      ]);

      // Convert strings to numbers
      const totalTransactions = Number(totalTransactionsResult[0]?.count || 0);
      const pendingPayouts = Number(pendingPayoutsResult[0]?.count || 0);
      const totalVolume = parseFloat(totalVolumeResult[0]?.total || '0');
      const activeUsers = activeUsersResult.length;
      const totalRevenue = parseFloat(completedOrdersResult[0]?.total || '0');
      
      // Calculate commission from creator earnings or fallback to order-based calculation
      let platformCommission = 0;
      let freelancerEarnings = 0;
      
      if (creatorEarningsResult.length > 0 && parseFloat(creatorEarningsResult[0].grossAmount) > 0) {
        // Use creator earning events for accurate commission tracking
        platformCommission = parseFloat(creatorEarningsResult[0].platformCommission || '0');
        freelancerEarnings = parseFloat(creatorEarningsResult[0].creatorAmount || '0');
      } else {
        // Fallback: calculate 35% commission from total revenue
        platformCommission = totalRevenue * 0.35;
        freelancerEarnings = totalRevenue * 0.65;
      }

      // Format top freelancers
      const topFreelancers = topFreelancersResult.map(f => ({
        userId: f.userId,
        name: f.userName || 'Unknown User',
        email: f.userEmail || 'No email',
        totalEarnings: parseFloat(f.totalEarnings || '0'),
        transactionCount: Number(f.transactionCount || 0)
      }));

      res.json({
        success: true,
        stats: {
          totalTransactions,
          pendingPayouts,
          totalVolume,
          activeUsers,
          totalRevenue,
          platformCommission,
          freelancerEarnings,
          topFreelancers,
          recentTransactions: recentTransactionsResult
        }
      });

    } catch (error) {
      console.error('Error fetching admin stats:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch statistics'
      });
    }
  });

  // Admin: Get transactions with pagination and filters (test endpoint)
  app.get('/api/admin/transactions-test', requireAdmin, async (req, res) => {
    try {
      const { status, method, userId, page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: transactions.id,
          userId: transactions.userId,
          type: transactions.type,
          amount: transactions.amount,
          status: transactions.status,
          method: transactions.method,
          description: transactions.description,
          createdAt: transactions.createdAt,
          processedAt: transactions.processedAt,
          adminNotes: transactions.adminNotes,
          userName: profiles.name,
          userEmail: profiles.email
        })
        .from(transactions)
        .leftJoin(profiles, eq(transactions.userId, profiles.userId));

      // Apply filters
      const conditions = [];
      if (status && status !== 'all') conditions.push(eq(transactions.status, status as string));
      if (method && method !== 'all') conditions.push(eq(transactions.method, method as string));
      if (userId) conditions.push(eq(transactions.userId, userId as string));

      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }

      const allTransactions = await query
        .orderBy(desc(transactions.createdAt))
        .limit(Number(limit))
        .offset(offset);

      // Get total count for pagination
      let countQuery = db.select({ count: count() }).from(transactions);
      if (conditions.length > 0) {
        countQuery = countQuery.where(and(...conditions));
      }
      const totalCountResult = await countQuery;

      res.json({
        success: true,
        transactions: allTransactions,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: Number(totalCountResult[0]?.count || 0),
          totalPages: Math.ceil(Number(totalCountResult[0]?.count || 0) / Number(limit))
        }
      });

    } catch (error) {
      console.error('Error fetching admin transactions:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch transactions'
      });
    }
  });

  // Admin: Get all payout accounts for verification
  // Admin: Get all payout accounts for verification
  app.get('/api/admin/payout-accounts', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { status = 'all', page = 1, limit = 20 } = req.query;
      
      const offset = (Number(page) - 1) * Number(limit);
      
      let query = db
        .select({
          id: payoutAccounts.id,
          userId: payoutAccounts.userId,
          type: payoutAccounts.type,
          accountName: payoutAccounts.accountName,
          isVerified: payoutAccounts.isVerified,
          isDefault: payoutAccounts.isDefault,
          createdAt: payoutAccounts.createdAt,
          verifiedAt: payoutAccounts.verifiedAt,
          // Join with user profile for user info
          userName: profiles.name,
          userEmail: profiles.email,
          // Show unmasked details for admin review
          details: payoutAccounts.details
        })
        .from(payoutAccounts)
        .leftJoin(profiles, eq(payoutAccounts.userId, profiles.userId));
      
      // Apply status filter
      if (status === 'pending') {
        query = query.where(eq(payoutAccounts.isVerified, false));
      } else if (status === 'verified') {
        query = query.where(eq(payoutAccounts.isVerified, true));
      }
      
      const allAccounts = await query
        .orderBy(desc(payoutAccounts.createdAt))
        .limit(Number(limit))
        .offset(offset);
      
      // Get total count
      const totalCountQuery = db
        .select({ count: count() })
        .from(payoutAccounts);
        
      if (status === 'pending') {
        totalCountQuery.where(eq(payoutAccounts.isVerified, false));
      } else if (status === 'verified') {
        totalCountQuery.where(eq(payoutAccounts.isVerified, true));
      }
      
      const totalCountResult = await totalCountQuery;
      
      res.json({
        success: true,
        accounts: allAccounts,
        pagination: {
          page: Number(page),
          limit: Number(limit),
          total: totalCountResult[0].count,
          totalPages: Math.ceil(totalCountResult[0].count / Number(limit))
        }
      });
      
    } catch (error) {
      console.error('Error fetching admin payout accounts:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch payout accounts'
      });
    }
  });

  // Admin: Verify payout account
  app.patch('/api/admin/payout-accounts/:id/verify', requireAuth, requireAdmin, async (req, res) => {
    console.log('ðŸš€ ENDPOINT HIT: /api/admin/payout-accounts/:id/verify');
    const { id } = req.params;
    const { action } = req.body; // action can be 'approve' or 'decline'
    
    try {
      const adminUserId = req.user?.userId || req.user?.id; // For logging purposes
      const adminId = req.user?.id; // UUID for database

      console.log('ðŸ” Payment approval request received:', {
        accountId: id,
        action: action,
        adminUserId: adminUserId,
        adminId: adminId,
        userFromReq: req.user,
        headers: {
          authorization: req.headers.authorization,
          sessionId: req.headers['x-session-id']
        },
        body: req.body,
        method: req.method
      });

      if (!action) {
        console.log('âŒ No action provided');
        return res.status(400).json({
          success: false,
          error: 'Action is required'
        });
      }

      if (!adminId) {
        console.log('âŒ No admin ID found');
        return res.status(401).json({
          success: false,
          error: 'Admin ID not found'
        });
      }

      if (action === 'approve') {
        console.log('âœ… Attempting to approve payout account:', id);
        await db
          .update(payoutAccounts)
          .set({
            isVerified: true,
            verifiedAt: new Date(),
            verifiedBy: adminId
          })
          .where(eq(payoutAccounts.id, id));
        
        console.log('âœ… Payout account approved successfully');
        
        res.json({
          success: true,
          message: 'Payout account approved successfully'
        });
      } else if (action === 'decline') {
        console.log('âŒ Attempting to decline payout account:', id);
        
        // Get the account details before deletion for notification
        const accountToDecline = await db
          .select()
          .from(payoutAccounts)
          .where(eq(payoutAccounts.id, id))
          .limit(1);
        
        if (accountToDecline.length > 0) {
          const account = accountToDecline[0];
          
          // Insert a notification for the user about the decline
          try {
            await db.insert(moderationLogs).values({
              moderatorId: adminId,
              actionType: 'account_declined',
              targetType: 'payout_account',
              targetId: id,
              reason: `Payment method declined: ${account.accountName} (${account.type})`,
              details: {
                accountName: account.accountName,
                accountType: account.type,
                userId: account.userId,
                declinedAt: new Date().toISOString(),
                message: 'Your payment method was declined for verification. Please check the details and try again, or contact support if you need assistance.'
              },
              originalContent: JSON.stringify(account)
            });
            console.log('ðŸ“§ Decline notification sent to user');
          } catch (notifyError) {
            console.error('Error creating decline notification:', notifyError);
          }
        }
        
        // For declined accounts, we delete them
        await db
          .delete(payoutAccounts)
          .where(eq(payoutAccounts.id, id));
          
        console.log('âŒ Payout account declined and removed successfully');
        res.json({
          success: true,
          message: 'Payout account declined and removed'
        });
      } else {
        console.log('âŒ Invalid action provided:', action);
        res.status(400).json({
          success: false,
          error: 'Invalid action. Use "approve" or "decline"'
        });
      }

    } catch (error) {
      console.error('Error processing payout account:', {
        error: error instanceof Error ? error.message : 'Unknown error',
        accountId: id,
        action: req.body.action,
        adminUserId: req.user?.userId || req.user?.id,
        stack: error instanceof Error ? error.stack : undefined
      });
      res.status(500).json({
        success: false,
        error: 'Failed to process payout account'
      });
    }
  });

  // Get user notifications for authenticated user
  app.get('/api/notifications', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);

      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      const userNotifications = await db
        .select({
          id: notifications.id,
          title: notifications.title,
          content: notifications.message,
          type: notifications.type,
          isRead: notifications.isRead,
          createdAt: notifications.createdAt,
          actionUrl: notifications.actionUrl,
          metadata: notifications.metadata,
        })
        .from(notifications)
        .where(eq(notifications.userId, user.id))
        .orderBy(desc(notifications.createdAt))
        .limit(50);

      return res.json(userNotifications);

    } catch (error) {
      console.error('Error fetching notifications:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to fetch notifications'
      });
    }
  });

  // Get user notifications (including account decline notifications)
  app.get('/api/notifications/:userId', async (req, res) => {
    try {
      const { userId } = req.params;
      
      // Fetch notifications from the notifications table
      const userNotifications = await db
        .select({
          id: notifications.id,
          title: notifications.title,
          content: notifications.message,
          message: notifications.message,
          type: notifications.type,
          isRead: notifications.isRead,
          actionUrl: notifications.actionUrl,
          metadata: notifications.metadata,
          createdAt: notifications.createdAt,
        })
        .from(notifications)
        .where(eq(notifications.userId, userId))
        .orderBy(desc(notifications.createdAt))
        .limit(50);

      res.json({
        success: true,
        notifications: userNotifications
      });

    } catch (error) {
      console.error('Error fetching notifications:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch notifications'
      });
    }
  });

  // Mark notification as read
  app.put('/api/notifications/:notificationId/read', async (req, res) => {
    try {
      const { notificationId } = req.params;
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);

      if (!user) {
        return res.status(401).json({
          success: false,
          error: 'Authentication required'
        });
      }

      // Update notification to mark as read
      const [updatedNotification] = await db
        .update(notifications)
        .set({ isRead: true })
        .where(and(
          eq(notifications.id, notificationId),
          eq(notifications.userId, user.id)
        ))
        .returning();

      if (!updatedNotification) {
        return res.status(404).json({
          success: false,
          error: 'Notification not found'
        });
      }

      return res.json({
        success: true,
        notification: updatedNotification
      });

    } catch (error) {
      console.error('Error marking notification as read:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to mark notification as read'
      });
    }
  });


  // Credit user account (for earnings)
  app.post('/api/transactions/credit', async (req, res) => {
    try {
      const { userId, amount, description, reference } = req.body;

      if (!userId || !amount || !description) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields'
        });
      }

      // Create credit transaction
      const [newTransaction] = await db
        .insert(transactions)
        .values({
          userId: userId,
          type: 'credit',
          amount: amount.toString(),
          status: 'completed',
          description: description,
          reference: reference || null
        })
        .returning();

      // Update user balance
      await db
        .update(userBalances)
        .set({
          availableBalance: sql`${userBalances.availableBalance} + ${amount}`,
          totalEarnings: sql`${userBalances.totalEarnings} + ${amount}`,
          lastUpdated: new Date()
        })
        .where(eq(userBalances.userId, userId));

      res.json({
        success: true,
        transaction: newTransaction,
        message: 'Account credited successfully'
      });

    } catch (error) {
      console.error('Error crediting account:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to credit account'
      });
    }
  });

  // ============================================
  // BANK DATA MANAGEMENT ENDPOINTS
  // ============================================

  // Get banks by country
  app.get('/api/banks/:countryCode', async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      try {
        const countryBanks = await db
          .select({
            id: banks.id,
            bankName: banks.bankName,
            bankCode: banks.bankCode,
            swiftCode: banks.swiftCode
          })
          .from(banks)
          .where(and(
            eq(banks.countryCode, countryCode.toUpperCase()),
            eq(banks.isActive, true)
          ))
          .orderBy(asc(banks.bankName));

        res.json({
          success: true,
          banks: countryBanks,
          count: countryBanks.length
        });
      } catch (dbError) {
        // Return empty array if table doesn't exist yet
        res.json({
          success: true,
          banks: [],
          count: 0,
          message: 'Banks table not yet created'
        });
      }

    } catch (error) {
      console.error('Error fetching banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch banks'
      });
    }
  });

  // Temporary public endpoint for development seeding
  app.post('/api/seed-banks-dev', async (req, res) => {
    try {
      console.log('ðŸ¦ Starting comprehensive bank seeding process...');
      const bankData = [
        // United States
        { countryCode: 'US', bankName: 'Bank of America', bankCode: '026009593', swiftCode: 'BOFAUS3N' },
        { countryCode: 'US', bankName: 'JPMorgan Chase Bank', bankCode: '021000021', swiftCode: 'CHASUS33' },
        { countryCode: 'US', bankName: 'Wells Fargo Bank', bankCode: '121000248', swiftCode: 'WFBIUS6S' },
        { countryCode: 'US', bankName: 'Citibank', bankCode: '021000089', swiftCode: 'CITIUS33' },
        { countryCode: 'US', bankName: 'U.S. Bank', bankCode: '091000022', swiftCode: 'USBKUS44' },
        { countryCode: 'US', bankName: 'PNC Bank', bankCode: '043000096', swiftCode: 'PNCCUS33' },
        { countryCode: 'US', bankName: 'Capital One Bank', bankCode: '051405515', swiftCode: 'HIBKUS44' },
        { countryCode: 'US', bankName: 'Goldman Sachs Bank', bankCode: '124071889', swiftCode: 'GSBNUSC1' },
        { countryCode: 'US', bankName: 'Morgan Stanley Bank', bankCode: '102000021', swiftCode: 'MSBUS3NS' },
        { countryCode: 'US', bankName: 'American Express Bank', bankCode: '074914003', swiftCode: 'AECBUSNY' },
        
        // United Kingdom
        { countryCode: 'GB', bankName: 'Barclays Bank', bankCode: '20-00-00', swiftCode: 'BARCGB22' },
        { countryCode: 'GB', bankName: 'HSBC Bank', bankCode: '40-05-15', swiftCode: 'HBUKGB4B' },
        { countryCode: 'GB', bankName: 'Lloyds Bank', bankCode: '30-00-02', swiftCode: 'LOYDGB21' },
        { countryCode: 'GB', bankName: 'NatWest Bank', bankCode: '60-00-01', swiftCode: 'NWBKGB2L' },
        { countryCode: 'GB', bankName: 'Santander UK', bankCode: '09-01-26', swiftCode: 'ABBYGB2L' },
        { countryCode: 'GB', bankName: 'Halifax', bankCode: '11-01-01', swiftCode: 'HLFXGB21' },
        { countryCode: 'GB', bankName: 'TSB Bank', bankCode: '77-71-99', swiftCode: 'TSBUS44' },
        { countryCode: 'GB', bankName: 'Monzo Bank', bankCode: '04-00-04', swiftCode: 'MONZGB2L' },
        { countryCode: 'GB', bankName: 'Starling Bank', bankCode: '60-83-71', swiftCode: 'SRLGGB2L' },
        
        // Canada
        { countryCode: 'CA', bankName: 'Royal Bank of Canada', bankCode: '003', swiftCode: 'ROYCCAT2' },
        { countryCode: 'CA', bankName: 'Toronto-Dominion Bank', bankCode: '004', swiftCode: 'TDOMCATTTOR' },
        { countryCode: 'CA', bankName: 'Bank of Nova Scotia', bankCode: '002', swiftCode: 'NOSCCATT' },
        { countryCode: 'CA', bankName: 'Bank of Montreal', bankCode: '001', swiftCode: 'BOFMCAM2' },
        { countryCode: 'CA', bankName: 'Canadian Imperial Bank of Commerce', bankCode: '010', swiftCode: 'CIBCCATT' },
        { countryCode: 'CA', bankName: 'National Bank of Canada', bankCode: '006', swiftCode: 'BNDCCAMMINT' },
        { countryCode: 'CA', bankName: 'Canadian Western Bank', bankCode: '030', swiftCode: 'CWBKCATT' },
        
        // Australia
        { countryCode: 'AU', bankName: 'Commonwealth Bank of Australia', bankCode: '062-000', swiftCode: 'CTBAAU2S' },
        { countryCode: 'AU', bankName: 'Australia and New Zealand Banking Group', bankCode: '013-006', swiftCode: 'ANZBAU3M' },
        { countryCode: 'AU', bankName: 'Westpac Banking Corporation', bankCode: '732-001', swiftCode: 'WPACAU2S' },
        { countryCode: 'AU', bankName: 'National Australia Bank', bankCode: '083-004', swiftCode: 'NATAAU33' },
        { countryCode: 'AU', bankName: 'Bendigo Bank', bankCode: '633-000', swiftCode: 'BENDAU3B' },
        { countryCode: 'AU', bankName: 'Bank of Queensland', bankCode: '124-001', swiftCode: 'BOQLAU4B' },
        
        // Germany
        { countryCode: 'DE', bankName: 'Deutsche Bank', bankCode: '10070000', swiftCode: 'DEUTDEFF' },
        { countryCode: 'DE', bankName: 'Commerzbank', bankCode: '76040061', swiftCode: 'COBADEFF' },
        { countryCode: 'DE', bankName: 'UniCredit Bank', bankCode: '70020270', swiftCode: 'HYVEDEMMXXX' },
        { countryCode: 'DE', bankName: 'DZ Bank', bankCode: '50060400', swiftCode: 'GENODEFF' },
        { countryCode: 'DE', bankName: 'KfW', bankCode: '50120383', swiftCode: 'KFWIDEFF' },
        { countryCode: 'DE', bankName: 'Sparkasse', bankCode: '50050222', swiftCode: 'HELADEF1' },
        
        // France
        { countryCode: 'FR', bankName: 'BNP Paribas', bankCode: '30004', swiftCode: 'BNPAFRPP' },
        { countryCode: 'FR', bankName: 'CrÃ©dit Agricole', bankCode: '31589', swiftCode: 'AGRIFRPP' },
        { countryCode: 'FR', bankName: 'SociÃ©tÃ© GÃ©nÃ©rale', bankCode: '30003', swiftCode: 'SOGEFRPP' },
        { countryCode: 'FR', bankName: 'CrÃ©dit Lyonnais', bankCode: '30002', swiftCode: 'LYONFRPP' },
        { countryCode: 'FR', bankName: 'Banque Populaire', bankCode: '10707', swiftCode: 'CCBPFRPPSTR' },
        { countryCode: 'FR', bankName: 'Caisse d\'Epargne', bankCode: '10751', swiftCode: 'CEPAFRPP751' },
        
        // Spain
        { countryCode: 'ES', bankName: 'Banco Santander', bankCode: '0049', swiftCode: 'BSCHESMMXXX' },
        { countryCode: 'ES', bankName: 'BBVA', bankCode: '0182', swiftCode: 'BBVAESMM' },
        { countryCode: 'ES', bankName: 'CaixaBank', bankCode: '2100', swiftCode: 'CAIXESBBXXX' },
        { countryCode: 'ES', bankName: 'Banco Sabadell', bankCode: '0081', swiftCode: 'BSABESBB' },
        { countryCode: 'ES', bankName: 'Bankinter', bankCode: '0128', swiftCode: 'BKBKESMMXXX' },
        
        // Italy
        { countryCode: 'IT', bankName: 'Intesa Sanpaolo', bankCode: '03069', swiftCode: 'BCITITMM' },
        { countryCode: 'IT', bankName: 'UniCredit', bankCode: '02008', swiftCode: 'UNCRITMM' },
        { countryCode: 'IT', bankName: 'Banco BPM', bankCode: '05034', swiftCode: 'BAPPIT21' },
        { countryCode: 'IT', bankName: 'Monte dei Paschi di Siena', bankCode: '01030', swiftCode: 'PASCITM1' },
        { countryCode: 'IT', bankName: 'Mediobanca', bankCode: '03062', swiftCode: 'MEDBITMMXXX' },
        
        // Netherlands
        { countryCode: 'NL', bankName: 'ING Bank', bankCode: 'INGB', swiftCode: 'INGBNL2A' },
        { countryCode: 'NL', bankName: 'Rabobank', bankCode: 'RABO', swiftCode: 'RABONL2U' },
        { countryCode: 'NL', bankName: 'ABN AMRO Bank', bankCode: 'ABNA', swiftCode: 'ABNANL2A' },
        { countryCode: 'NL', bankName: 'de Volksbank', bankCode: 'ASNB', swiftCode: 'ASNBNL21' },
        { countryCode: 'NL', bankName: 'Triodos Bank', bankCode: 'TRIO', swiftCode: 'TRIONL2U' },
        
        // Switzerland
        { countryCode: 'CH', bankName: 'UBS', bankCode: '273', swiftCode: 'UBSWCHZH80A' },
        { countryCode: 'CH', bankName: 'Credit Suisse', bankCode: '4835', swiftCode: 'CRESCHZZ80A' },
        { countryCode: 'CH', bankName: 'PostFinance', bankCode: '09000', swiftCode: 'POFICHBEXXX' },
        { countryCode: 'CH', bankName: 'Raiffeisen', bankCode: '80808', swiftCode: 'RAIFCH22' },
        { countryCode: 'CH', bankName: 'ZÃ¼rcher Kantonalbank', bankCode: '700', swiftCode: 'ZKBKCHZZ80A' },
        
        // Japan
        { countryCode: 'JP', bankName: 'Mitsubishi UFJ Financial Group', bankCode: '0005', swiftCode: 'BOTKJPJT' },
        { countryCode: 'JP', bankName: 'Sumitomo Mitsui Banking Corporation', bankCode: '0009', swiftCode: 'SMBCJPJT' },
        { countryCode: 'JP', bankName: 'Mizuho Bank', bankCode: '0001', swiftCode: 'MHBKJPJT' },
        { countryCode: 'JP', bankName: 'Japan Post Bank', bankCode: '9900', swiftCode: 'JPPSJPJ1' },
        { countryCode: 'JP', bankName: 'Resona Bank', bankCode: '0010', swiftCode: 'DIWAJPJT' },
        { countryCode: 'JP', bankName: 'Sumitomo Mitsui Trust Bank', bankCode: '0294', swiftCode: 'SMTCJPJT' },
        
        // China
        { countryCode: 'CN', bankName: 'Industrial and Commercial Bank of China', bankCode: '102100099996', swiftCode: 'ICBKCNBJ' },
        { countryCode: 'CN', bankName: 'China Construction Bank', bankCode: '105100000017', swiftCode: 'PCBCCNBJ' },
        { countryCode: 'CN', bankName: 'Agricultural Bank of China', bankCode: '103100000026', swiftCode: 'ABOCCNBJ' },
        { countryCode: 'CN', bankName: 'Bank of China', bankCode: '104100000004', swiftCode: 'BKCHCNBJ' },
        { countryCode: 'CN', bankName: 'China Merchants Bank', bankCode: '308584000013', swiftCode: 'CMBCCNBS' },
        { countryCode: 'CN', bankName: 'China Minsheng Bank', bankCode: '305100000013', swiftCode: 'MSBCCNBJ' },
        
        // India
        { countryCode: 'IN', bankName: 'State Bank of India', bankCode: 'SBIN0000001', swiftCode: 'SBININBB' },
        { countryCode: 'IN', bankName: 'HDFC Bank', bankCode: 'HDFC0000001', swiftCode: 'HDFCINBB' },
        { countryCode: 'IN', bankName: 'ICICI Bank', bankCode: 'ICIC0000001', swiftCode: 'ICICINBB' },
        { countryCode: 'IN', bankName: 'Axis Bank', bankCode: 'UTIB0000001', swiftCode: 'AXISINBB' },
        { countryCode: 'IN', bankName: 'Kotak Mahindra Bank', bankCode: 'KKBK0000001', swiftCode: 'KKBKINBB' },
        { countryCode: 'IN', bankName: 'Punjab National Bank', bankCode: 'PUNB0000001', swiftCode: 'PUNBINBB' },
        { countryCode: 'IN', bankName: 'Bank of Baroda', bankCode: 'BARB0000001', swiftCode: 'BARBINBB' },
        { countryCode: 'IN', bankName: 'Union Bank of India', bankCode: 'UBIN0000001', swiftCode: 'UBININBB' },
        
        // Brazil
        { countryCode: 'BR', bankName: 'Banco do Brasil', bankCode: '001', swiftCode: 'BRASBRRJ' },
        { countryCode: 'BR', bankName: 'ItaÃº Unibanco', bankCode: '341', swiftCode: 'ITAUBRSP' },
        { countryCode: 'BR', bankName: 'Bradesco', bankCode: '237', swiftCode: 'BBDEBRSP' },
        { countryCode: 'BR', bankName: 'Caixa EconÃ´mica Federal', bankCode: '104', swiftCode: 'CEFXBRSP' },
        { countryCode: 'BR', bankName: 'Santander Brasil', bankCode: '033', swiftCode: 'BSCHBRSP' },
        { countryCode: 'BR', bankName: 'BTG Pactual', bankCode: '208', swiftCode: 'BTGPBRSP' },
        
        // Mexico
        { countryCode: 'MX', bankName: 'BBVA Mexico', bankCode: '012180002', swiftCode: 'BCMRMXMM' },
        { countryCode: 'MX', bankName: 'Santander Mexico', bankCode: '014180001', swiftCode: 'BMSXMXMM' },
        { countryCode: 'MX', bankName: 'Citibanamex', bankCode: '002180002', swiftCode: 'BNMXMXMM' },
        { countryCode: 'MX', bankName: 'Banorte', bankCode: '072180001', swiftCode: 'MENOMXMT' },
        { countryCode: 'MX', bankName: 'HSBC Mexico', bankCode: '021180001', swiftCode: 'BIMXMXMM' },
        
        // Argentina
        { countryCode: 'AR', bankName: 'Banco de la NaciÃ³n Argentina', bankCode: '011', swiftCode: 'NACNAR01' },
        { countryCode: 'AR', bankName: 'Banco Santander Rio', bankCode: '072', swiftCode: 'BSCHARBX' },
        { countryCode: 'AR', bankName: 'BBVA Argentina', bankCode: '017', swiftCode: 'BBVAARBX' },
        { countryCode: 'AR', bankName: 'Banco Macro', bankCode: '285', swiftCode: 'BMARBXAR' },
        { countryCode: 'AR', bankName: 'Banco Galicia', bankCode: '007', swiftCode: 'GABRARB1' },
        
        // South Africa
        { countryCode: 'ZA', bankName: 'Standard Bank', bankCode: '051001', swiftCode: 'SBZAZAJJ' },
        { countryCode: 'ZA', bankName: 'ABSA Bank', bankCode: '632005', swiftCode: 'ABSAZAJJ' },
        { countryCode: 'ZA', bankName: 'FirstRand Bank', bankCode: '250655', swiftCode: 'FIRNZAJJ' },
        { countryCode: 'ZA', bankName: 'Nedbank', bankCode: '198765', swiftCode: 'NEDSZAJJ' },
        { countryCode: 'ZA', bankName: 'Investec Bank', bankCode: '580105', swiftCode: 'IVESZAJJ' },
        { countryCode: 'ZA', bankName: 'Capitec Bank', bankCode: '470010', swiftCode: 'CABLZAJJ' },
        
        // Nigeria
        { countryCode: 'NG', bankName: 'First Bank of Nigeria', bankCode: '011', swiftCode: 'FBNINGLA' },
        { countryCode: 'NG', bankName: 'United Bank for Africa', bankCode: '033', swiftCode: 'UNAFNGLA' },
        { countryCode: 'NG', bankName: 'Access Bank', bankCode: '044', swiftCode: 'ABNGNGLA' },
        { countryCode: 'NG', bankName: 'Zenith Bank', bankCode: '057', swiftCode: 'ZEIBNGLA' },
        { countryCode: 'NG', bankName: 'Guaranty Trust Bank', bankCode: '058', swiftCode: 'GTBINGLA' },
        { countryCode: 'NG', bankName: 'Fidelity Bank', bankCode: '070', swiftCode: 'FIDTNGLA' },
        { countryCode: 'NG', bankName: 'Ecobank Nigeria', bankCode: '050', swiftCode: 'ECOCNGLA' },
        
        // Kenya
        { countryCode: 'KE', bankName: 'Kenya Commercial Bank', bankCode: '01', swiftCode: 'KCBLKENX' },
        { countryCode: 'KE', bankName: 'Equity Bank', bankCode: '68', swiftCode: 'EQBLKENA' },
        { countryCode: 'KE', bankName: 'Standard Chartered Bank Kenya', bankCode: '02', swiftCode: 'SCBLKENX' },
        { countryCode: 'KE', bankName: 'Cooperative Bank of Kenya', bankCode: '11', swiftCode: 'KCOOKENA' },
        { countryCode: 'KE', bankName: 'Barclays Bank Kenya', bankCode: '03', swiftCode: 'BARCKENX' },
        { countryCode: 'KE', bankName: 'NCBA Bank', bankCode: '07', swiftCode: 'CBAFKENX' },
        
        // Egypt
        { countryCode: 'EG', bankName: 'National Bank of Egypt', bankCode: '003', swiftCode: 'NBEGEGCX' },
        { countryCode: 'EG', bankName: 'Banque Misr', bankCode: '002', swiftCode: 'BMISEGCX' },
        { countryCode: 'EG', bankName: 'Commercial International Bank', bankCode: '030', swiftCode: 'CIBEEGCX' },
        { countryCode: 'EG', bankName: 'QNB ALAHLI', bankCode: '200', swiftCode: 'QNBAEGCX' },
        { countryCode: 'EG', bankName: 'HSBC Bank Egypt', bankCode: '135', swiftCode: 'HBUKEGCX' },
        
        // Morocco
        { countryCode: 'MA', bankName: 'Attijariwafa Bank', bankCode: '007', swiftCode: 'BCMAMAMC' },
        { countryCode: 'MA', bankName: 'Banque Populaire', bankCode: '025', swiftCode: 'BMCEMAMC' },
        { countryCode: 'MA', bankName: 'BMCE Bank', bankCode: '011', swiftCode: 'BMCEMAMC' },
        { countryCode: 'MA', bankName: 'CrÃ©dit du Maroc', bankCode: '175', swiftCode: 'CDMAMAMC' },
        { countryCode: 'MA', bankName: 'SociÃ©tÃ© GÃ©nÃ©rale Maroc', bankCode: '020', swiftCode: 'SOGEMAMCXXX' },
        
        // Ghana
        { countryCode: 'GH', bankName: 'Ghana Commercial Bank', bankCode: 'GCB', swiftCode: 'GHCBGHAC' },
        { countryCode: 'GH', bankName: 'Ecobank Ghana', bankCode: 'EBG', swiftCode: 'ECOCGHAC' },
        { countryCode: 'GH', bankName: 'Standard Chartered Bank Ghana', bankCode: 'SCB', swiftCode: 'SCBLGHAC' },
        { countryCode: 'GH', bankName: 'Barclays Bank Ghana', bankCode: 'BBG', swiftCode: 'BARCGHAC' },
        { countryCode: 'GH', bankName: 'Fidelity Bank Ghana', bankCode: 'FBL', swiftCode: 'FIDTGHAC' },
        
        // Zimbabwe  
        { countryCode: 'ZW', bankName: 'CBZ Bank', bankCode: 'CBZ', swiftCode: 'CBZWZWHA' },
        { countryCode: 'ZW', bankName: 'Stanbic Bank Zimbabwe', bankCode: 'STANBIC', swiftCode: 'SBICZWHA' },
        { countryCode: 'ZW', bankName: 'Standard Chartered Bank Zimbabwe', bankCode: 'STANCHART', swiftCode: 'SCBLZWHA' },
        { countryCode: 'ZW', bankName: 'FBC Bank', bankCode: 'FBC', swiftCode: 'FBCBZWHA' },
        { countryCode: 'ZW', bankName: 'CABS', bankCode: 'CABS', swiftCode: 'CABSZWHA' },
        
        // Singapore
        { countryCode: 'SG', bankName: 'DBS Bank', bankCode: '7171', swiftCode: 'DBSSSGSG' },
        { countryCode: 'SG', bankName: 'OCBC Bank', bankCode: '7339', swiftCode: 'OCBCSGSG' },
        { countryCode: 'SG', bankName: 'United Overseas Bank', bankCode: '7375', swiftCode: 'UOVBSGSG' },
        { countryCode: 'SG', bankName: 'Citibank Singapore', bankCode: '7214', swiftCode: 'CITISGSGGLO' },
        { countryCode: 'SG', bankName: 'Standard Chartered Singapore', bankCode: '7144', swiftCode: 'SCBLSGSG' },
        
        // Malaysia
        { countryCode: 'MY', bankName: 'Maybank', bankCode: 'MBB', swiftCode: 'MBBEMYKL' },
        { countryCode: 'MY', bankName: 'CIMB Bank', bankCode: 'CIMB', swiftCode: 'CIBBMYKL' },
        { countryCode: 'MY', bankName: 'Public Bank', bankCode: 'PBB', swiftCode: 'PBBEMYKL' },
        { countryCode: 'MY', bankName: 'RHB Bank', bankCode: 'RHB', swiftCode: 'RHBBMYKL' },
        { countryCode: 'MY', bankName: 'Hong Leong Bank', bankCode: 'HLB', swiftCode: 'HLBBMYKL' },
        
        // Thailand
        { countryCode: 'TH', bankName: 'Bangkok Bank', bankCode: '002', swiftCode: 'BKKBTHBK' },
        { countryCode: 'TH', bankName: 'Kasikornbank', bankCode: '004', swiftCode: 'KASITHBK' },
        { countryCode: 'TH', bankName: 'Krung Thai Bank', bankCode: '006', swiftCode: 'KRTHTHBK' },
        { countryCode: 'TH', bankName: 'Siam Commercial Bank', bankCode: '014', swiftCode: 'SICOTHBK' },
        { countryCode: 'TH', bankName: 'Bank of Ayudhya', bankCode: '025', swiftCode: 'AYUDTHBK' },
        
        // Indonesia
        { countryCode: 'ID', bankName: 'Bank Mandiri', bankCode: '008', swiftCode: 'BMRIIDJA' },
        { countryCode: 'ID', bankName: 'Bank Central Asia', bankCode: '014', swiftCode: 'CENAIDJA' },
        { countryCode: 'ID', bankName: 'Bank Rakyat Indonesia', bankCode: '002', swiftCode: 'BRINIDJA' },
        { countryCode: 'ID', bankName: 'Bank Negara Indonesia', bankCode: '009', swiftCode: 'BNINIDJA' },
        { countryCode: 'ID', bankName: 'CIMB Niaga', bankCode: '022', swiftCode: 'BNIAIDJA' },
        
        // Philippines
        { countryCode: 'PH', bankName: 'Banco de Oro', bankCode: 'BDO', swiftCode: 'BNORPHMM' },
        { countryCode: 'PH', bankName: 'Metropolitan Bank', bankCode: 'MBT', swiftCode: 'MBTCPHMM' },
        { countryCode: 'PH', bankName: 'Bank of the Philippine Islands', bankCode: 'BPI', swiftCode: 'BOPIPHMM' },
        { countryCode: 'PH', bankName: 'Land Bank of the Philippines', bankCode: 'LBP', swiftCode: 'TLBPPHMM' },
        { countryCode: 'PH', bankName: 'Philippine National Bank', bankCode: 'PNB', swiftCode: 'PNBMPHMM' },
        
        // Vietnam
        { countryCode: 'VN', bankName: 'Vietcombank', bankCode: '970436', swiftCode: 'BFTVVNVX' },
        { countryCode: 'VN', bankName: 'BIDV', bankCode: '970418', swiftCode: 'BIDVVNVX' },
        { countryCode: 'VN', bankName: 'VietinBank', bankCode: '970415', swiftCode: 'ICBVVNVX' },
        { countryCode: 'VN', bankName: 'Agribank', bankCode: '970405', swiftCode: 'VBAAVNVX' },
        { countryCode: 'VN', bankName: 'Techcombank', bankCode: '970407', swiftCode: 'VTCBVNVX' },
        
        // Europe - Additional Countries
        // Belgium
        { countryCode: 'BE', bankName: 'KBC Bank', bankCode: 'KBC', swiftCode: 'KREDBEBB' },
        { countryCode: 'BE', bankName: 'Belfius Bank', bankCode: 'BELFIUS', swiftCode: 'GKCCBEBB' },
        { countryCode: 'BE', bankName: 'ING Belgium', bankCode: 'ING', swiftCode: 'BBRUBEBB' },
        
        // Austria
        { countryCode: 'AT', bankName: 'Erste Bank', bankCode: '20111', swiftCode: 'GIBAATWW' },
        { countryCode: 'AT', bankName: 'Bank Austria', bankCode: '12000', swiftCode: 'BKAUATWW' },
        { countryCode: 'AT', bankName: 'Raiffeisen Bank', bankCode: '31000', swiftCode: 'RLNWATWW' },
        
        // Portugal
        { countryCode: 'PT', bankName: 'Banco Santander Portugal', bankCode: '0007', swiftCode: 'BSCHPTPL' },
        { countryCode: 'PT', bankName: 'Caixa Geral de DepÃ³sitos', bankCode: '0035', swiftCode: 'CGDIPTPL' },
        { countryCode: 'PT', bankName: 'Millennium BCP', bankCode: '0033', swiftCode: 'BCOMPTPL' },
        
        // Ireland
        { countryCode: 'IE', bankName: 'Bank of Ireland', bankCode: 'BOI', swiftCode: 'BOFIIE2D' },
        { countryCode: 'IE', bankName: 'AIB Bank', bankCode: 'AIB', swiftCode: 'AIBKIE2D' },
        { countryCode: 'IE', bankName: 'Ulster Bank Ireland', bankCode: 'UBI', swiftCode: 'ULSBIE2D' },
        
        // Poland
        { countryCode: 'PL', bankName: 'PKO Bank Polski', bankCode: '10201023', swiftCode: 'BPKOPLPW' },
        { countryCode: 'PL', bankName: 'Bank Pekao', bankCode: '12401020', swiftCode: 'PKOPPLPW' },
        { countryCode: 'PL', bankName: 'Santander Bank Polska', bankCode: '10901023', swiftCode: 'WBKPPLPP' },
        
        // Czech Republic
        { countryCode: 'CZ', bankName: 'ÄŒeskÃ¡ spoÅ™itelna', bankCode: '0800', swiftCode: 'GIBACZPX' },
        { countryCode: 'CZ', bankName: 'KomerÄnÃ­ banka', bankCode: '0100', swiftCode: 'KOMBCZPP' },
        { countryCode: 'CZ', bankName: 'ÄŒSOB Bank', bankCode: '0300', swiftCode: 'CEKOCZPP' },
        
        // Hungary
        { countryCode: 'HU', bankName: 'OTP Bank', bankCode: '11700024', swiftCode: 'OTPVHUHB' },
        { countryCode: 'HU', bankName: 'K&H Bank', bankCode: '10401007', swiftCode: 'OKHBHUHB' },
        { countryCode: 'HU', bankName: 'Erste Bank Hungary', bankCode: '11600006', swiftCode: 'GIBAHUHB' },
        
        // Romania
        { countryCode: 'RO', bankName: 'BCR Bank', bankCode: 'RNCB', swiftCode: 'RNCBROBU' },
        { countryCode: 'RO', bankName: 'BRD SociÃ©tÃ© GÃ©nÃ©rale', bankCode: 'BRDE', swiftCode: 'BRDEROBU' },
        { countryCode: 'RO', bankName: 'ING Bank Romania', bankCode: 'INGB', swiftCode: 'INGBROBU' },
        
        // Bulgaria
        { countryCode: 'BG', bankName: 'UniCredit Bulgaria', bankCode: 'UNCR', swiftCode: 'UNCRBGSF' },
        { countryCode: 'BG', bankName: 'DSK Bank', bankCode: 'DSK', swiftCode: 'BDSBBGSF' },
        { countryCode: 'BG', bankName: 'First Investment Bank', bankCode: 'FINV', swiftCode: 'FINVBGSF' },
        
        // Croatia
        { countryCode: 'HR', bankName: 'ZagrebaÄka banka', bankCode: '2360000', swiftCode: 'ZABAHR2X' },
        { countryCode: 'HR', bankName: 'Privredna banka Zagreb', bankCode: '2340009', swiftCode: 'PBZGHR2X' },
        { countryCode: 'HR', bankName: 'Erste Bank Croatia', bankCode: '2402008', swiftCode: 'ESBCHR22' },
        
        // Serbia
        { countryCode: 'RS', bankName: 'Komercijalna banka', bankCode: '205', swiftCode: 'KOBBRSBG' },
        { countryCode: 'RS', bankName: 'Banca Intesa', bankCode: '160', swiftCode: 'DBDBRSBG' },
        { countryCode: 'RS', bankName: 'Raiffeisen banka', bankCode: '265', swiftCode: 'RZBSRSBG' },
        
        // Nordic Countries
        // Sweden
        { countryCode: 'SE', bankName: 'Swedbank', bankCode: '8000', swiftCode: 'SWEDSESS' },
        { countryCode: 'SE', bankName: 'Handelsbanken', bankCode: '6000', swiftCode: 'HANDSESS' },
        { countryCode: 'SE', bankName: 'SEB Bank', bankCode: '5000', swiftCode: 'ESSESESS' },
        
        // Norway
        { countryCode: 'NO', bankName: 'DNB Bank', bankCode: '0200', swiftCode: 'DNBANOKKXXX' },
        { countryCode: 'NO', bankName: 'Nordea Bank Norge', bankCode: '6000', swiftCode: 'NDEANOKKXXX' },
        { countryCode: 'NO', bankName: 'Sparebank 1', bankCode: '8200', swiftCode: 'SPRONO22XXX' },
        
        // Denmark
        { countryCode: 'DK', bankName: 'Danske Bank', bankCode: '3000', swiftCode: 'DABADKKK' },
        { countryCode: 'DK', bankName: 'Nordea Denmark', bankCode: '2000', swiftCode: 'NDEADKKK' },
        { countryCode: 'DK', bankName: 'Jyske Bank', bankCode: '7000', swiftCode: 'JYBADKKK' },
        
        // Finland
        { countryCode: 'FI', bankName: 'Nordea Bank Finland', bankCode: '166030', swiftCode: 'NDEAFIHH' },
        { countryCode: 'FI', bankName: 'OP Corporate Bank', bankCode: '500000', swiftCode: 'OKOYFIHH' },
        { countryCode: 'FI', bankName: 'Danske Bank Finland', bankCode: '800000', swiftCode: 'DABAFIHH' },
        
        // Iceland
        { countryCode: 'IS', bankName: 'Landsbankinn', bankCode: '0111', swiftCode: 'NBIIISRE' },
        { countryCode: 'IS', bankName: 'Arion Bank', bankCode: '0116', swiftCode: 'KAUPIS22' },
        { countryCode: 'IS', bankName: 'Ãslandsbanki', bankCode: '0113', swiftCode: 'GLITISRE' },
        
        // Middle East
        // United Arab Emirates
        { countryCode: 'AE', bankName: 'Emirates NBD', bankCode: 'ENBD', swiftCode: 'EBILAEAD' },
        { countryCode: 'AE', bankName: 'First Abu Dhabi Bank', bankCode: 'FAB', swiftCode: 'NBADAEAD' },
        { countryCode: 'AE', bankName: 'Dubai Islamic Bank', bankCode: 'DIB', swiftCode: 'DUIBAEAD' },
        { countryCode: 'AE', bankName: 'ADCB Bank', bankCode: 'ADCB', swiftCode: 'ADCBAEAD' },
        
        // Saudi Arabia
        { countryCode: 'SA', bankName: 'Al Rajhi Bank', bankCode: '80', swiftCode: 'RJHISARI' },
        { countryCode: 'SA', bankName: 'National Commercial Bank', bankCode: '10', swiftCode: 'NCBKSAJE' },
        { countryCode: 'SA', bankName: 'Riyad Bank', bankCode: '20', swiftCode: 'RIBLSARI' },
        { countryCode: 'SA', bankName: 'Saudi British Bank', bankCode: '40', swiftCode: 'SABBSARI' },
        
        // Qatar
        { countryCode: 'QA', bankName: 'Qatar National Bank', bankCode: 'QNB', swiftCode: 'QNBKQAQA' },
        { countryCode: 'QA', bankName: 'Commercial Bank of Qatar', bankCode: 'CBQ', swiftCode: 'CBQAQAQA' },
        { countryCode: 'QA', bankName: 'Doha Bank', bankCode: 'DOHA', swiftCode: 'DOHBQAQA' },
        
        // Kuwait
        { countryCode: 'KW', bankName: 'National Bank of Kuwait', bankCode: 'NBK', swiftCode: 'NBOKKWKW' },
        { countryCode: 'KW', bankName: 'Kuwait Finance House', bankCode: 'KFH', swiftCode: 'KFHOKWKW' },
        { countryCode: 'KW', bankName: 'Gulf Bank Kuwait', bankCode: 'GBK', swiftCode: 'GULBKWKW' },
        
        // Israel
        { countryCode: 'IL', bankName: 'Bank Hapoalim', bankCode: '12', swiftCode: 'POALILIT' },
        { countryCode: 'IL', bankName: 'Bank Leumi', bankCode: '10', swiftCode: 'LUMIILITTLV' },
        { countryCode: 'IL', bankName: 'Discount Bank', bankCode: '11', swiftCode: 'IDBLILITTLV' },
        
        // Turkey
        { countryCode: 'TR', bankName: 'Ä°ÅŸ BankasÄ±', bankCode: '64', swiftCode: 'ISBKTRIS' },
        { countryCode: 'TR', bankName: 'Garanti BBVA', bankCode: '62', swiftCode: 'TGBATRIS' },
        { countryCode: 'TR', bankName: 'YapÄ± Kredi BankasÄ±', bankCode: '67', swiftCode: 'YAPITRIS' },
        
        // Asia-Pacific Additional
        // South Korea
        { countryCode: 'KR', bankName: 'KB Kookmin Bank', bankCode: '004', swiftCode: 'CZNBKRSE' },
        { countryCode: 'KR', bankName: 'Shinhan Bank', bankCode: '088', swiftCode: 'SHBKKRSE' },
        { countryCode: 'KR', bankName: 'Woori Bank', bankCode: '020', swiftCode: 'HVBKKRSE' },
        
        // Taiwan
        { countryCode: 'TW', bankName: 'Bank of Taiwan', bankCode: '004', swiftCode: 'BKTWTWTP' },
        { countryCode: 'TW', bankName: 'Cathay United Bank', bankCode: '013', swiftCode: 'CDCBTWTP' },
        { countryCode: 'TW', bankName: 'Fubon Bank', bankCode: '012', swiftCode: 'TPBKTWTP' },
        
        // Hong Kong
        { countryCode: 'HK', bankName: 'HSBC Hong Kong', bankCode: '004', swiftCode: 'HSBCHKHHHKH' },
        { countryCode: 'HK', bankName: 'Bank of China Hong Kong', bankCode: '012', swiftCode: 'BKCHHKHHXXX' },
        { countryCode: 'HK', bankName: 'Standard Chartered Hong Kong', bankCode: '003', swiftCode: 'SCBLHKHHXXX' },
        
        // New Zealand
        { countryCode: 'NZ', bankName: 'ANZ Bank New Zealand', bankCode: '01', swiftCode: 'ANZBNZ22' },
        { countryCode: 'NZ', bankName: 'ASB Bank', bankCode: '12', swiftCode: 'ASBBNZ2A' },
        { countryCode: 'NZ', bankName: 'Westpac New Zealand', bankCode: '03', swiftCode: 'WPACNZ2W' },
        
        // Bangladesh
        { countryCode: 'BD', bankName: 'Sonali Bank', bankCode: '000', swiftCode: 'SONBBD2D' },
        { countryCode: 'BD', bankName: 'Rupali Bank', bankCode: '001', swiftCode: 'RUBDDHKA' },
        { countryCode: 'BD', bankName: 'Dutch-Bangla Bank', bankCode: '205', swiftCode: 'DBBLBDDHXXX' },
        
        // Sri Lanka
        { countryCode: 'LK', bankName: 'Bank of Ceylon', bankCode: '7010', swiftCode: 'BCEYLKLX' },
        { countryCode: 'LK', bankName: 'Commercial Bank of Ceylon', bankCode: '7056', swiftCode: 'CCEYLKLX' },
        { countryCode: 'LK', bankName: 'Hatton National Bank', bankCode: '7083', swiftCode: 'HBLILKLX' },
        
        // Pakistan
        { countryCode: 'PK', bankName: 'Habib Bank Limited', bankCode: '014', swiftCode: 'HABBPKKA' },
        { countryCode: 'PK', bankName: 'United Bank Limited', bankCode: '006', swiftCode: 'UNILPKKA' },
        { countryCode: 'PK', bankName: 'MCB Bank', bankCode: '003', swiftCode: 'MUCBPKKA' },
        
        // Americas Additional
        // Chile
        { countryCode: 'CL', bankName: 'Banco de Chile', bankCode: '001', swiftCode: 'BCHICLRM' },
        { countryCode: 'CL', bankName: 'Banco Santander Chile', bankCode: '037', swiftCode: 'BSCHCLRM' },
        { countryCode: 'CL', bankName: 'BCI Bank', bankCode: '016', swiftCode: 'CREDCLRM' },
        
        // Colombia
        { countryCode: 'CO', bankName: 'Bancolombia', bankCode: '007', swiftCode: 'COLOCOBM' },
        { countryCode: 'CO', bankName: 'Banco de BogotÃ¡', bankCode: '001', swiftCode: 'BBOPCOBM' },
        { countryCode: 'CO', bankName: 'Davivienda', bankCode: '051', swiftCode: 'DAVICOBM' },
        
        // Peru
        { countryCode: 'PE', bankName: 'Banco de CrÃ©dito del PerÃº', bankCode: '002', swiftCode: 'BCPLPEPL' },
        { countryCode: 'PE', bankName: 'BBVA Continental', bankCode: '011', swiftCode: 'BCONPEPL' },
        { countryCode: 'PE', bankName: 'Scotiabank PerÃº', bankCode: '009', swiftCode: 'BSUDPEPL' },
        
        // Uruguay
        { countryCode: 'UY', bankName: 'Banco RepÃºblica', bankCode: '001', swiftCode: 'BROUUYMM' },
        { countryCode: 'UY', bankName: 'Banco Santander Uruguay', bankCode: '137', swiftCode: 'BSCHUYMMXXX' },
        { countryCode: 'UY', bankName: 'ItaÃº Uruguay', bankCode: '113', swiftCode: 'ITAUUYMMXXX' },
        
        // Ecuador
        { countryCode: 'EC', bankName: 'Banco Pichincha', bankCode: '001', swiftCode: 'PICHECEQ' },
        { countryCode: 'EC', bankName: 'Banco del PacÃ­fico', bankCode: '016', swiftCode: 'BPACECEQ' },
        { countryCode: 'EC', bankName: 'Produbanco', bankCode: '043', swiftCode: 'PRODECEQ' },
        
        // Venezuela
        { countryCode: 'VE', bankName: 'Banco de Venezuela', bankCode: '0102', swiftCode: 'BANVVECA' },
        { countryCode: 'VE', bankName: 'Mercantil Bank', bankCode: '0105', swiftCode: 'BAVEVECA' },
        { countryCode: 'VE', bankName: 'Banesco Bank', bankCode: '0134', swiftCode: 'BANEVECA' },
        
        // Africa Additional
        // Tunisia
        { countryCode: 'TN', bankName: 'SociÃ©tÃ© Tunisienne de Banque', bankCode: '008', swiftCode: 'STBKTNTT' },
        { countryCode: 'TN', bankName: 'Banque Nationale Agricole', bankCode: '004', swiftCode: 'BNATTNTT' },
        { countryCode: 'TN', bankName: 'Attijari Bank', bankCode: '020', swiftCode: 'BCMZTNTT' },
        
        // Algeria
        { countryCode: 'DZ', bankName: 'Banque Nationale d\'AlgÃ©rie', bankCode: '001', swiftCode: 'BNADDZAL' },
        { countryCode: 'DZ', bankName: 'CrÃ©dit Populaire d\'AlgÃ©rie', bankCode: '002', swiftCode: 'CPALDZAL' },
        { countryCode: 'DZ', bankName: 'Banque ExtÃ©rieure d\'AlgÃ©rie', bankCode: '003', swiftCode: 'BEALDZAL' },
        
        // Ethiopia
        { countryCode: 'ET', bankName: 'Commercial Bank of Ethiopia', bankCode: '001', swiftCode: 'CBETETAA' },
        { countryCode: 'ET', bankName: 'Dashen Bank', bankCode: '014', swiftCode: 'DASHETAA' },
        { countryCode: 'ET', bankName: 'Bank of Abyssinia', bankCode: '019', swiftCode: 'ABYSETAA' },
        
        // Tanzania
        { countryCode: 'TZ', bankName: 'CRDB Bank', bankCode: '154', swiftCode: 'CORUTZTZ' },
        { countryCode: 'TZ', bankName: 'NBC Bank', bankCode: '012', swiftCode: 'NLCBTZTZ' },
        { countryCode: 'TZ', bankName: 'Stanbic Bank Tanzania', bankCode: '040', swiftCode: 'SBICTZTZ' },
        
        // Uganda
        { countryCode: 'UG', bankName: 'Bank of Uganda', bankCode: '001', swiftCode: 'BOUGUNKA' },
        { countryCode: 'UG', bankName: 'Centenary Bank', bankCode: '320', swiftCode: 'CNTYUGKA' },
        { countryCode: 'UG', bankName: 'Stanbic Bank Uganda', bankCode: '224', swiftCode: 'SBICUGKA' },
        
        // Botswana
        { countryCode: 'BW', bankName: 'First National Bank Botswana', bankCode: '282', swiftCode: 'FIRNBWGX' },
        { countryCode: 'BW', bankName: 'Standard Chartered Bank Botswana', bankCode: '010', swiftCode: 'SCBLBWGX' },
        { countryCode: 'BW', bankName: 'Barclays Bank Botswana', bankCode: '030', swiftCode: 'BARCBWGX' },
        
        // Zambia
        { countryCode: 'ZM', bankName: 'Zanaco Bank', bankCode: '010330', swiftCode: 'ZANCZM22' },
        { countryCode: 'ZM', bankName: 'Stanbic Bank Zambia', bankCode: '040003', swiftCode: 'SBICZM22' },
        { countryCode: 'ZM', bankName: 'First Capital Bank', bankCode: '350001', swiftCode: 'FCBLZM22' },
        
        // Namibia
        { countryCode: 'NA', bankName: 'Bank Windhoek', bankCode: '483312', swiftCode: 'BWLINANX' },
        { countryCode: 'NA', bankName: 'First National Bank Namibia', bankCode: '281479', swiftCode: 'FIRNNANX' },
        { countryCode: 'NA', bankName: 'Standard Bank Namibia', bankCode: '087373', swiftCode: 'SBNMNANX' },
        
        // Mozambique
        { countryCode: 'MZ', bankName: 'Millennium BIM', bankCode: '008', swiftCode: 'BMOCMZMZ' },
        { countryCode: 'MZ', bankName: 'Standard Bank Mozambique', bankCode: '012', swiftCode: 'SBICMZMZ' },
        { countryCode: 'MZ', bankName: 'Barclays Mozambique', bankCode: '013', swiftCode: 'BARCMZMZ' },
        
        // Additional Asian Countries
        // Cambodia
        { countryCode: 'KH', bankName: 'ACLEDA Bank', bankCode: '001', swiftCode: 'ACLBKHHH' },
        { countryCode: 'KH', bankName: 'Canadia Bank', bankCode: '009', swiftCode: 'CADIKHHH' },
        { countryCode: 'KH', bankName: 'ANZ Royal Bank', bankCode: '020', swiftCode: 'ANZBKHPP' },
        
        // Laos
        { countryCode: 'LA', bankName: 'Banque pour le Commerce ExtÃ©rieur Lao', bankCode: '001', swiftCode: 'BCELLAOB' },
        { countryCode: 'LA', bankName: 'Lao Development Bank', bankCode: '003', swiftCode: 'LDBLLAOB' },
        { countryCode: 'LA', bankName: 'Joint Development Bank', bankCode: '004', swiftCode: 'JDBLLAOB' },
        
        // Myanmar
        { countryCode: 'MM', bankName: 'Myanmar Apex Bank', bankCode: '001', swiftCode: 'MABJMM2X' },
        { countryCode: 'MM', bankName: 'Kanbawza Bank', bankCode: '029', swiftCode: 'KBZAMM2X' },
        { countryCode: 'MM', bankName: 'CB Bank', bankCode: '035', swiftCode: 'CBCOMM2X' },
        
        // Pacific Islands
        // Fiji
        { countryCode: 'FJ', bankName: 'ANZ Bank Fiji', bankCode: '01', swiftCode: 'ANZBNZ22FJ' },
        { countryCode: 'FJ', bankName: 'Westpac Bank Fiji', bankCode: '03', swiftCode: 'WPACFJFJ' },
        { countryCode: 'FJ', bankName: 'Bank of South Pacific', bankCode: '05', swiftCode: 'BSPFFJFJ' },
        
        // Caribbean
        // Jamaica
        { countryCode: 'JM', bankName: 'Bank of Jamaica', bankCode: '001', swiftCode: 'BOJAâ€‹JMKGXXX' },
        { countryCode: 'JM', bankName: 'National Commercial Bank', bankCode: '002', swiftCode: 'JNCBJMKGXXX' },
        { countryCode: 'JM', bankName: 'Scotiabank Jamaica', bankCode: '004', swiftCode: 'NOSCJMKGXXX' },
        
        // Trinidad and Tobago
        { countryCode: 'TT', bankName: 'Republic Bank Trinidad', bankCode: '047', swiftCode: 'RBTTTT22XXX' },
        { countryCode: 'TT', bankName: 'First Citizens Bank', bankCode: '023', swiftCode: 'FCIBTTPS' },
        { countryCode: 'TT', bankName: 'Scotiabank Trinidad', bankCode: '045', swiftCode: 'NOSCTTTP' },
        
        // Additional European Countries
        // Luxembourg
        { countryCode: 'LU', bankName: 'Banque et Caisse d\'Epargne de l\'Etat', bankCode: '1111', swiftCode: 'BCEELULL' },
        { countryCode: 'LU', bankName: 'Banque Internationale Ã  Luxembourg', bankCode: '0010', swiftCode: 'BILLLULL' },
        { countryCode: 'LU', bankName: 'ING Luxembourg', bankCode: '0141', swiftCode: 'CELLLULL' },
        
        // Malta
        { countryCode: 'MT', bankName: 'Bank of Valletta', bankCode: 'BOV', swiftCode: 'VALLMTMT' },
        { countryCode: 'MT', bankName: 'HSBC Bank Malta', bankCode: 'HSBC', swiftCode: 'MMEBMTMT' },
        { countryCode: 'MT', bankName: 'APS Bank', bankCode: 'APS', swiftCode: 'APSRMTMT' },
        
        // Cyprus
        { countryCode: 'CY', bankName: 'Bank of Cyprus', bankCode: 'BOC', swiftCode: 'BCYPCY2N' },
        { countryCode: 'CY', bankName: 'Hellenic Bank', bankCode: 'HB', swiftCode: 'HEBACY2N' },
        { countryCode: 'CY', bankName: 'Alpha Bank Cyprus', bankCode: 'ALPHA', swiftCode: 'ALPHCY2N' },
        
        // Additional countries to ensure comprehensive coverage
        // Russia
        { countryCode: 'RU', bankName: 'Sberbank', bankCode: '044525225', swiftCode: 'SABRRUMM' },
        { countryCode: 'RU', bankName: 'VTB Bank', bankCode: '044525187', swiftCode: 'VTBRRUMM' },
        { countryCode: 'RU', bankName: 'Gazprombank', bankCode: '044525823', swiftCode: 'GAZPRUMM' },
        
        // Ukraine
        { countryCode: 'UA', bankName: 'PrivatBank', bankCode: '305299', swiftCode: 'PBANUA2X' },
        { countryCode: 'UA', bankName: 'Oschadbank', bankCode: '300012', swiftCode: 'OSBAAU2X' },
        { countryCode: 'UA', bankName: 'Raiffeisen Bank Aval', bankCode: '380805', swiftCode: 'AVALUAUKXXX' },
        
        // Kazakhstan
        { countryCode: 'KZ', bankName: 'Kaspi Bank', bankCode: 'KSPK', swiftCode: 'CASPKZKA' },
        { countryCode: 'KZ', bankName: 'Halyk Bank', bankCode: 'HSBK', swiftCode: 'HSBKKZKA' },
        { countryCode: 'KZ', bankName: 'Forte Bank', bankCode: 'IRTB', swiftCode: 'IRTYKZKA' },
        
        // Belarus
        { countryCode: 'BY', bankName: 'Belarusbank', bankCode: '153001001', swiftCode: 'UNBYBYMM' },
        { countryCode: 'BY', bankName: 'Alfa-Bank Belarus', bankCode: '270002351', swiftCode: 'ALFABY2X' },
        { countryCode: 'BY', bankName: 'Bank Dabrabyt', bankCode: '362000102', swiftCode: 'DABRBY22' },
        
        // Georgia
        { countryCode: 'GE', bankName: 'Bank of Georgia', bankCode: 'BAGAGE22', swiftCode: 'BAGAGE22' },
        { countryCode: 'GE', bankName: 'TBC Bank', bankCode: 'TBCBGE22', swiftCode: 'TBCBGE22' },
        { countryCode: 'GE', bankName: 'VTB Bank Georgia', bankCode: 'VTBGGE22', swiftCode: 'VTBGGE22' },
        
        // Armenia
        { countryCode: 'AM', bankName: 'ACBA Bank', bankCode: '044525761', swiftCode: 'ACBAAM22' },
        { countryCode: 'AM', bankName: 'Ameriabank', bankCode: '044525777', swiftCode: 'AMERAM22' },
        { countryCode: 'AM', bankName: 'VTB Bank Armenia', bankCode: '044525666', swiftCode: 'VTBRAM22' },
        
        // Azerbaijan
        { countryCode: 'AZ', bankName: 'International Bank of Azerbaijan', bankCode: '200037', swiftCode: 'NABZAZ2X' },
        { countryCode: 'AZ', bankName: 'Kapital Bank', bankCode: '200002', swiftCode: 'AIIBAZ2X' },
        { countryCode: 'AZ', bankName: 'AccessBank Azerbaijan', bankCode: '200051', swiftCode: 'ABAZAZ22' },
        
        // Nepal
        { countryCode: 'NP', bankName: 'Nepal Rastra Bank', bankCode: '001', swiftCode: 'NRBLNPKA' },
        { countryCode: 'NP', bankName: 'Nepal Investment Bank', bankCode: '017', swiftCode: 'NIBLNPKA' },
        { countryCode: 'NP', bankName: 'Himalayan Bank', bankCode: '026', swiftCode: 'HIMANPKA' },
        
        // Uzbekistan
        { countryCode: 'UZ', bankName: 'National Bank of Uzbekistan', bankCode: '00014', swiftCode: 'NBFAUZ22' },
        { countryCode: 'UZ', bankName: 'Kapitalbank', bankCode: '00381', swiftCode: 'KAPTUZ22' },
        { countryCode: 'UZ', bankName: 'Ipoteka-Bank', bankCode: '00822', swiftCode: 'IPOAUZ22' },
        
        // Mongolia
        { countryCode: 'MN', bankName: 'Trade and Development Bank of Mongolia', bankCode: '040000', swiftCode: 'TDBMMNUB' },
        { countryCode: 'MN', bankName: 'Khan Bank', bankCode: '150000', swiftCode: 'KHANMNUB' },
        { countryCode: 'MN', bankName: 'Golomt Bank', bankCode: '140000', swiftCode: 'GLOMMNUB' },
        
        // Moldova
        { countryCode: 'MD', bankName: 'MAIB Bank', bankCode: 'MAIB', swiftCode: 'AIBMMDCHI' },
        { countryCode: 'MD', bankName: 'Moldindconbank', bankCode: 'MICB', swiftCode: 'MOLDMDCH' },
        { countryCode: 'MD', bankName: 'Victoriabank', bankCode: 'VICT', swiftCode: 'VICBMDCH' },
        
        // Bosnia and Herzegovina
        { countryCode: 'BA', bankName: 'UniCredit Bank Banja Luka', bankCode: '1610', swiftCode: 'UNCRBA22' },
        { countryCode: 'BA', bankName: 'Raiffeisen Bank BiH', bankCode: '1330', swiftCode: 'RZBABA2S' },
        { countryCode: 'BA', bankName: 'Intesa Sanpaolo Banka BiH', bankCode: '1401', swiftCode: 'BSANBABA' },
        
        // North Macedonia
        { countryCode: 'MK', bankName: 'Komercijalna Banka', bankCode: '300', swiftCode: 'KOBMMK2X' },
        { countryCode: 'MK', bankName: 'Stopanska Banka', bankCode: '200', swiftCode: 'STBAMK22' },
        { countryCode: 'MK', bankName: 'NLB Tutunska Banka', bankCode: '270', swiftCode: 'TUTNMK22' },
        
        // Albania
        { countryCode: 'AL', bankName: 'Raiffeisen Bank Albania', bankCode: '20211', swiftCode: 'SGSBALTX' },
        { countryCode: 'AL', bankName: 'Intesa Sanpaolo Bank Albania', bankCode: '21241', swiftCode: 'BSANALTX' },
        { countryCode: 'AL', bankName: 'Union Bank', bankCode: '20802', swiftCode: 'UBNKALTX' },
        
        // Montenegro
        { countryCode: 'ME', bankName: 'Podgorica Bank', bankCode: '505', swiftCode: 'PGBAME2G' },
        { countryCode: 'ME', bankName: 'NLB Montenegrobanka', bankCode: '510', swiftCode: 'NLBAME2G' },
        { countryCode: 'ME', bankName: 'Hipotekarna Banka', bankCode: '520', swiftCode: 'HIPOME2G' },
        
        // Slovakia
        { countryCode: 'SK', bankName: 'SlovenskÃ¡ sporiteÄ¾Åˆa', bankCode: '0900', swiftCode: 'GIBASKBX' },
        { countryCode: 'SK', bankName: 'VÃšB Banka', bankCode: '0200', swiftCode: 'SUBASKBX' },
        { countryCode: 'SK', bankName: 'Tatra Banka', bankCode: '1100', swiftCode: 'TATRSKBX' },
        
        // Slovenia
        { countryCode: 'SI', bankName: 'Nova Ljubljanska Banka', bankCode: '02010', swiftCode: 'LJBASI2X' },
        { countryCode: 'SI', bankName: 'Nova KBM', bankCode: '04510', swiftCode: 'KBMASI2X' },
        { countryCode: 'SI', bankName: 'Abanka', bankCode: '05100', swiftCode: 'ABANSI2X' },
        
        // Lithuania
        { countryCode: 'LT', bankName: 'SEB bankas', bankCode: '70440', swiftCode: 'CBVILT2X' },
        { countryCode: 'LT', bankName: 'Swedbank', bankCode: '73000', swiftCode: 'HABALT22' },
        { countryCode: 'LT', bankName: 'Å iauliÅ³ bankas', bankCode: '71800', swiftCode: 'CBSBLT26' },
        
        // Latvia
        { countryCode: 'LV', bankName: 'Swedbank Latvia', bankCode: 'SWED', swiftCode: 'HABALV22' },
        { countryCode: 'LV', bankName: 'SEB banka', bankCode: 'UNLAV', swiftCode: 'UNLALV2X' },
        { countryCode: 'LV', bankName: 'Citadele banka', bankCode: 'PARX', swiftCode: 'PARXLV22' },
        
        // Estonia
        { countryCode: 'EE', bankName: 'Swedbank Estonia', bankCode: '22', swiftCode: 'HABAEE2X' },
        { countryCode: 'EE', bankName: 'SEB Pank', bankCode: '10', swiftCode: 'EEUHEE2X' },
        { countryCode: 'EE', bankName: 'LHV Pank', bankCode: '77', swiftCode: 'LHVBEE22' },
        
        // Kosovo
        { countryCode: 'XK', bankName: 'Raiffeisen Bank Kosovo', bankCode: 'RBKO', swiftCode: 'RBKOXKPR' },
        { countryCode: 'XK', bankName: 'ProCredit Bank Kosovo', bankCode: 'PCBK', swiftCode: 'BPKOXKPR' },
        { countryCode: 'XK', bankName: 'TEB Bank', bankCode: 'TEBK', swiftCode: 'TESBXKPR' },
        
        // Bahrain
        { countryCode: 'BH', bankName: 'National Bank of Bahrain', bankCode: 'NBBH', swiftCode: 'NBOFBHBM' },
        { countryCode: 'BH', bankName: 'Ahli United Bank', bankCode: 'AUBH', swiftCode: 'AUBHBHBM' },
        { countryCode: 'BH', bankName: 'Gulf International Bank', bankCode: 'GIBH', swiftCode: 'GULBBHBM' },
        
        // Oman
        { countryCode: 'OM', bankName: 'Bank Muscat', bankCode: 'BMAG', swiftCode: 'BMOMOMRU' },
        { countryCode: 'OM', bankName: 'National Bank of Oman', bankCode: 'NBOM', swiftCode: 'NBOMOMRU' },
        { countryCode: 'OM', bankName: 'HSBC Bank Oman', bankCode: 'HSBC', swiftCode: 'BBMEOMMU' },
        
        // Jordan
        { countryCode: 'JO', bankName: 'Arab Bank', bankCode: 'ARAB', swiftCode: 'ARABJOAX' },
        { countryCode: 'JO', bankName: 'Bank of Jordan', bankCode: 'BOJX', swiftCode: 'BJORJOAX' },
        { countryCode: 'JO', bankName: 'Jordan Islamic Bank', bankCode: 'JISB', swiftCode: 'JIIBJOAX' },
        
        // Lebanon
        { countryCode: 'LB', bankName: 'Banque du Liban', bankCode: '001', swiftCode: 'BDLBLBBX' },
        { countryCode: 'LB', bankName: 'Bank Audi', bankCode: '056', swiftCode: 'AUDILBBX' },
        { countryCode: 'LB', bankName: 'BLOM Bank', bankCode: '006', swiftCode: 'BLOMLBBX' },
        
        // Central Asian Additional
        { countryCode: 'KG', bankName: 'RSK Bank', bankCode: '440001', swiftCode: 'RSKBKGBK' },
        { countryCode: 'KG', bankName: 'Optima Bank', bankCode: '440004', swiftCode: 'OPINKG22' },
        { countryCode: 'KG', bankName: 'Kyrgyz Investment Credit Bank', bankCode: '440009', swiftCode: 'KICBKGBK' },
        
        { countryCode: 'TJ', bankName: 'Orienbank', bankCode: '350101001', swiftCode: 'ORINTJRT' },
        { countryCode: 'TJ', bankName: 'Amonatbonk', bankCode: '350301001', swiftCode: 'AMOTTJRT' },
        { countryCode: 'TJ', bankName: 'Eskhata Bank', bankCode: '350401001', swiftCode: 'ESHTJRT' },
        
        { countryCode: 'TM', bankName: 'Vnesheconombank of Turkmenistan', bankCode: '042001', swiftCode: 'VNEBASHG' },
        { countryCode: 'TM', bankName: 'Halk Bank', bankCode: '042002', swiftCode: 'HALKASHG' },
        { countryCode: 'TM', bankName: 'Senagat Bank', bankCode: '042003', swiftCode: 'SENAASHG' },
        
        // Additional African Countries
        { countryCode: 'RW', bankName: 'Bank of Kigali', bankCode: 'BOKI', swiftCode: 'BKIGRWRW' },
        { countryCode: 'RW', bankName: 'Equity Bank Rwanda', bankCode: 'EQTY', swiftCode: 'EQBLRWRW' },
        { countryCode: 'RW', bankName: 'Cogebanque', bankCode: 'COGB', swiftCode: 'COGERW22' },
        
        { countryCode: 'MW', bankName: 'National Bank of Malawi', bankCode: '001', swiftCode: 'NATIMWMW' },
        { countryCode: 'MW', bankName: 'Standard Bank Malawi', bankCode: '003', swiftCode: 'SBICMWMW' },
        { countryCode: 'MW', bankName: 'FDH Bank', bankCode: '009', swiftCode: 'FDHLMWMW' },
        
        { countryCode: 'LS', bankName: 'Central Bank of Lesotho', bankCode: '001', swiftCode: 'CBLSLSMR' },
        { countryCode: 'LS', bankName: 'Nedbank Lesotho', bankCode: '025', swiftCode: 'NEDSLSMR' },
        { countryCode: 'LS', bankName: 'First National Bank Lesotho', bankCode: '301', swiftCode: 'FIRNLSMR' },
        
        { countryCode: 'SZ', bankName: 'Central Bank of Swaziland', bankCode: '001', swiftCode: 'CBSWSZMT' },
        { countryCode: 'SZ', bankName: 'Nedbank Swaziland', bankCode: '296', swiftCode: 'NEDSZSZMT' },
        { countryCode: 'SZ', bankName: 'First National Bank Swaziland', bankCode: '361', swiftCode: 'FIRNSZMT' },
        
        // Additional Latin American Countries
        { countryCode: 'PY', bankName: 'Banco Nacional de Fomento', bankCode: '001', swiftCode: 'BNFOPYPZ' },
        { countryCode: 'PY', bankName: 'Banco Continental', bankCode: '013', swiftCode: 'BCPYPZPZ' },
        { countryCode: 'PY', bankName: 'Banco ItaÃº Paraguay', bankCode: '017', swiftCode: 'ITAUPZPZ' },
        
        { countryCode: 'BO', bankName: 'Banco Central de Bolivia', bankCode: '001', swiftCode: 'BCBLBOCP' },
        { countryCode: 'BO', bankName: 'Banco Nacional de Bolivia', bankCode: '002', swiftCode: 'BNBOBOCP' },
        { countryCode: 'BO', bankName: 'Banco de CrÃ©dito de Bolivia', bankCode: '040', swiftCode: 'BCRBBOCP' },
        
        { countryCode: 'GY', bankName: 'Bank of Guyana', bankCode: '001', swiftCode: 'BOYAGY22' },
        { countryCode: 'GY', bankName: 'Republic Bank Guyana', bankCode: '002', swiftCode: 'RBTTGY22' },
        { countryCode: 'GY', bankName: 'Demerara Bank', bankCode: '003', swiftCode: 'DEMEGY22' },
        
        { countryCode: 'SR', bankName: 'Centrale Bank van Suriname', bankCode: '001', swiftCode: 'CBSRSRPA' },
        { countryCode: 'SR', bankName: 'Hakrinbank', bankCode: '002', swiftCode: 'HAKSRSRPA' },
        { countryCode: 'SR', bankName: 'De Surinaamsche Bank', bankCode: '003', swiftCode: 'DSBASRPA' },
        
        { countryCode: 'BZ', bankName: 'Central Bank of Belize', bankCode: '001', swiftCode: 'CBBZBZBZ' },
        { countryCode: 'BZ', bankName: 'Belize Bank', bankCode: '002', swiftCode: 'BELIBZBZ' },
        { countryCode: 'BZ', bankName: 'Heritage Bank', bankCode: '003', swiftCode: 'HERIBZBZ' },
        
        { countryCode: 'SV', bankName: 'Banco Central de Reserva', bankCode: '001', swiftCode: 'BCRESVSV' },
        { countryCode: 'SV', bankName: 'Banco AgrÃ­cola', bankCode: '103', swiftCode: 'AGRISVSV' },
        { countryCode: 'SV', bankName: 'Banco CuscatlÃ¡n', bankCode: '107', swiftCode: 'CUSCSVSV' },
        
        { countryCode: 'HN', bankName: 'Banco Central de Honduras', bankCode: '001', swiftCode: 'BCHOHNHN' },
        { countryCode: 'HN', bankName: 'Banco AtlÃ¡ntida', bankCode: '106', swiftCode: 'ATLAHN22' },
        { countryCode: 'HN', bankName: 'Banco de Occidente', bankCode: '165', swiftCode: 'BOCOHN22' },
        
        { countryCode: 'NI', bankName: 'Banco Central de Nicaragua', bankCode: '001', swiftCode: 'BCNININI' },
        { countryCode: 'NI', bankName: 'Banco de AmÃ©rica Central', bankCode: '106', swiftCode: 'BACNNI22' },
        { countryCode: 'NI', bankName: 'Banpro', bankCode: '171', swiftCode: 'BANPNI22' }
      ];

      console.log(`ðŸ“Š Preparing to seed ${bankData.length} banks from ${new Set(bankData.map(b => b.countryCode)).size} countries`);
      
      try {
        // Clear existing banks and reseed with comprehensive data
        await db.delete(banks);
        console.log('ðŸ—‘ï¸ Cleared existing bank data for comprehensive reseeding');

        // Insert bank data
        await db.insert(banks).values(bankData);

        console.log(`âœ… Successfully seeded ${bankData.length} comprehensive banks`);
        res.json({
          success: true,
          message: `Successfully seeded ${bankData.length} banks across multiple countries`,
          count: bankData.length
        });
      } catch (dbError) {
        res.json({
          success: true,
          message: 'Banks will be seeded once database schema is synced',
          pending: bankData.length
        });
      }

    } catch (error) {
      console.error('Error seeding banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to seed bank data'
      });
    }
  });

  // Get user's country from location (IP-based)
  app.get('/api/user/location', async (req, res) => {
    try {
      const clientIP = req.headers['x-forwarded-for'] || req.connection.remoteAddress || '0.0.0.0';
      
      // For development, return a default location
      if (clientIP === '127.0.0.1' || clientIP === '::1' || clientIP.includes('127.0.0.1')) {
        return res.json({
          success: true,
          country: 'US',
          countryName: 'United States'
        });
      }

      // In production, you would use an IP geolocation service
      // For now, return default US location
      res.json({
        success: true,
        country: 'US',
        countryName: 'United States'
      });

    } catch (error) {
      console.error('Error getting user location:', error);
      res.json({
        success: true,
        country: 'US',
        countryName: 'United States'
      });
    }
  });

  // Get all countries with available banks
  app.get('/api/countries/with-banks', async (req, res) => {
    try {
      try {
        // Get all countries and LEFT JOIN with banks to include countries without banks
        const allCountriesWithBanks = await db
          .select({
            countryCode: countries.code,
            countryName: countries.name,
            bankCount: count(banks.id),
          })
          .from(countries)
          .leftJoin(banks, and(
            eq(banks.countryCode, countries.code),
            eq(banks.isActive, true)
          ))
          .groupBy(countries.code, countries.name)
          .orderBy(asc(countries.name));

        // Comprehensive country names mapping for all 197+ countries
        const countryNames: { [key: string]: string } = {
          // Major economies
          'US': 'United States', 'GB': 'United Kingdom', 'CA': 'Canada', 'AU': 'Australia',
          'DE': 'Germany', 'FR': 'France', 'ES': 'Spain', 'IT': 'Italy', 'NL': 'Netherlands',
          'CH': 'Switzerland', 'JP': 'Japan', 'CN': 'China', 'IN': 'India', 'BR': 'Brazil',
          'MX': 'Mexico', 'AR': 'Argentina', 'ZA': 'South Africa', 'RU': 'Russia',
          
          // European Union countries
          'BE': 'Belgium', 'AT': 'Austria', 'PT': 'Portugal', 'IE': 'Ireland', 'PL': 'Poland',
          'CZ': 'Czech Republic', 'HU': 'Hungary', 'RO': 'Romania', 'BG': 'Bulgaria',
          'HR': 'Croatia', 'SK': 'Slovakia', 'SI': 'Slovenia', 'LT': 'Lithuania', 'LV': 'Latvia',
          'EE': 'Estonia', 'FI': 'Finland', 'SE': 'Sweden', 'DK': 'Denmark', 'NO': 'Norway',
          'IS': 'Iceland', 'LU': 'Luxembourg', 'MT': 'Malta', 'CY': 'Cyprus', 'GR': 'Greece',
          
          // Middle East & Gulf
          'AE': 'United Arab Emirates', 'SA': 'Saudi Arabia', 'QA': 'Qatar', 'KW': 'Kuwait',
          'BH': 'Bahrain', 'OM': 'Oman', 'IL': 'Israel', 'TR': 'Turkey', 'IR': 'Iran',
          'IQ': 'Iraq', 'JO': 'Jordan', 'LB': 'Lebanon', 'SY': 'Syria', 'YE': 'Yemen',
          
          // Asia-Pacific
          'KR': 'South Korea', 'TW': 'Taiwan', 'HK': 'Hong Kong', 'SG': 'Singapore',
          'MY': 'Malaysia', 'TH': 'Thailand', 'ID': 'Indonesia', 'PH': 'Philippines',
          'VN': 'Vietnam', 'BD': 'Bangladesh', 'LK': 'Sri Lanka', 'PK': 'Pakistan',
          'NZ': 'New Zealand', 'FJ': 'Fiji', 'KH': 'Cambodia', 'LA': 'Laos', 'MM': 'Myanmar',
          'NP': 'Nepal', 'BT': 'Bhutan', 'MN': 'Mongolia', 'UZ': 'Uzbekistan',
          'KZ': 'Kazakhstan', 'KG': 'Kyrgyzstan', 'TJ': 'Tajikistan', 'TM': 'Turkmenistan',
          'AF': 'Afghanistan', 'MV': 'Maldives', 'BN': 'Brunei',
          
          // Africa
          'NG': 'Nigeria', 'KE': 'Kenya', 'EG': 'Egypt', 'MA': 'Morocco', 'GH': 'Ghana',
          'ZW': 'Zimbabwe', 'TN': 'Tunisia', 'DZ': 'Algeria', 'ET': 'Ethiopia', 'TZ': 'Tanzania',
          'UG': 'Uganda', 'BW': 'Botswana', 'ZM': 'Zambia', 'NA': 'Namibia', 'MZ': 'Mozambique',
          'AO': 'Angola', 'SN': 'Senegal', 'CI': 'CÃ´te d\'Ivoire', 'ML': 'Mali', 'BF': 'Burkina Faso',
          'NE': 'Niger', 'TD': 'Chad', 'CF': 'Central African Republic', 'CM': 'Cameroon',
          'GA': 'Gabon', 'GQ': 'Equatorial Guinea', 'CG': 'Republic of the Congo',
          'CD': 'Democratic Republic of the Congo', 'RW': 'Rwanda', 'BI': 'Burundi',
          'SO': 'Somalia', 'DJ': 'Djibouti', 'ER': 'Eritrea', 'SD': 'Sudan', 'SS': 'South Sudan',
          'LY': 'Libya', 'MR': 'Mauritania', 'GM': 'Gambia', 'GW': 'Guinea-Bissau',
          'GN': 'Guinea', 'SL': 'Sierra Leone', 'LR': 'Liberia', 'BJ': 'Benin', 'TG': 'Togo',
          'MG': 'Madagascar', 'MW': 'Malawi', 'LS': 'Lesotho', 'SZ': 'Eswatini',
          'KM': 'Comoros', 'SC': 'Seychelles', 'MU': 'Mauritius', 'CV': 'Cape Verde',
          'ST': 'SÃ£o TomÃ© and PrÃ­ncipe',
          
          // Latin America & Caribbean
          'CL': 'Chile', 'CO': 'Colombia', 'PE': 'Peru', 'UY': 'Uruguay', 'EC': 'Ecuador',
          'VE': 'Venezuela', 'BO': 'Bolivia', 'PY': 'Paraguay', 'GY': 'Guyana', 'SR': 'Suriname',
          'GT': 'Guatemala', 'BZ': 'Belize', 'SV': 'El Salvador', 'HN': 'Honduras',
          'NI': 'Nicaragua', 'CR': 'Costa Rica', 'PA': 'Panama', 'CU': 'Cuba', 'JM': 'Jamaica',
          'HT': 'Haiti', 'DO': 'Dominican Republic', 'TT': 'Trinidad and Tobago',
          'BB': 'Barbados', 'GD': 'Grenada', 'LC': 'Saint Lucia', 'VC': 'Saint Vincent and the Grenadines',
          'DM': 'Dominica', 'AG': 'Antigua and Barbuda', 'KN': 'Saint Kitts and Nevis',
          'BS': 'Bahamas', 'BM': 'Bermuda', 'KY': 'Cayman Islands', 'TC': 'Turks and Caicos Islands',
          'VG': 'British Virgin Islands', 'VI': 'U.S. Virgin Islands', 'PR': 'Puerto Rico',
          'GP': 'Guadeloupe', 'MQ': 'Martinique', 'GF': 'French Guiana', 'AW': 'Aruba',
          'CW': 'CuraÃ§ao', 'SX': 'Sint Maarten', 'BQ': 'Caribbean Netherlands',
          
          // North America
          'GL': 'Greenland', 'PM': 'Saint Pierre and Miquelon',
          
          // Oceania
          'PG': 'Papua New Guinea', 'NC': 'New Caledonia', 'VU': 'Vanuatu', 'SB': 'Solomon Islands',
          'TO': 'Tonga', 'WS': 'Samoa', 'KI': 'Kiribati', 'TV': 'Tuvalu', 'NR': 'Nauru',
          'FM': 'Micronesia', 'MH': 'Marshall Islands', 'PW': 'Palau', 'CK': 'Cook Islands',
          'NU': 'Niue', 'TK': 'Tokelau', 'PF': 'French Polynesia', 'WF': 'Wallis and Futuna',
          'AS': 'American Samoa', 'GU': 'Guam', 'MP': 'Northern Mariana Islands',
          
          // Special territories
          'AD': 'Andorra', 'MC': 'Monaco', 'SM': 'San Marino', 'VA': 'Vatican City',
          'LI': 'Liechtenstein', 'GI': 'Gibraltar', 'JE': 'Jersey', 'GG': 'Guernsey',
          'IM': 'Isle of Man', 'FO': 'Faroe Islands', 'AX': 'Ã…land Islands',
          'SJ': 'Svalbard and Jan Mayen', 'BV': 'Bouvet Island', 'HM': 'Heard Island and McDonald Islands',
          'TF': 'French Southern Territories', 'IO': 'British Indian Ocean Territory',
          'CC': 'Cocos Islands', 'CX': 'Christmas Island', 'NF': 'Norfolk Island',
          'AQ': 'Antarctica', 'GS': 'South Georgia and the South Sandwich Islands',
          'FK': 'Falkland Islands', 'SH': 'Saint Helena', 'TA': 'Tristan da Cunha',
          'AC': 'Ascension Island', 'EH': 'Western Sahara', 'PS': 'Palestine',
          'XK': 'Kosovo', 'RS': 'Serbia', 'ME': 'Montenegro', 'MK': 'North Macedonia',
          'AL': 'Albania', 'BA': 'Bosnia and Herzegovina', 'MD': 'Moldova',
          'UA': 'Ukraine', 'BY': 'Belarus', 'GE': 'Georgia', 'AM': 'Armenia', 'AZ': 'Azerbaijan'
        };

        const enrichedCountries = allCountriesWithBanks.map(country => ({
          countryCode: country.countryCode,
          countryName: country.countryName,
          bankCount: country.bankCount || 0
        }));

        res.json({
          success: true,
          countries: enrichedCountries,
          total: enrichedCountries.length
        });
      } catch (dbError) {
        // Return comprehensive fallback data for all major countries
        const fallbackCountries = [
          // Major economies
          { countryCode: 'US', countryName: 'United States', bankCount: 10 },
          { countryCode: 'GB', countryName: 'United Kingdom', bankCount: 9 },
          { countryCode: 'CA', countryName: 'Canada', bankCount: 7 },
          { countryCode: 'AU', countryName: 'Australia', bankCount: 6 },
          { countryCode: 'DE', countryName: 'Germany', bankCount: 6 },
          { countryCode: 'FR', countryName: 'France', bankCount: 6 },
          { countryCode: 'IT', countryName: 'Italy', bankCount: 5 },
          { countryCode: 'ES', countryName: 'Spain', bankCount: 5 },
          { countryCode: 'NL', countryName: 'Netherlands', bankCount: 5 },
          { countryCode: 'CH', countryName: 'Switzerland', bankCount: 5 },
          { countryCode: 'JP', countryName: 'Japan', bankCount: 6 },
          { countryCode: 'CN', countryName: 'China', bankCount: 6 },
          { countryCode: 'IN', countryName: 'India', bankCount: 8 },
          { countryCode: 'BR', countryName: 'Brazil', bankCount: 6 },
          { countryCode: 'MX', countryName: 'Mexico', bankCount: 5 },
          { countryCode: 'AR', countryName: 'Argentina', bankCount: 5 },
          { countryCode: 'ZA', countryName: 'South Africa', bankCount: 6 },
          { countryCode: 'RU', countryName: 'Russia', bankCount: 4 },
          
          // Asia-Pacific
          { countryCode: 'KR', countryName: 'South Korea', bankCount: 4 },
          { countryCode: 'TW', countryName: 'Taiwan', bankCount: 4 },
          { countryCode: 'HK', countryName: 'Hong Kong', bankCount: 4 },
          { countryCode: 'SG', countryName: 'Singapore', bankCount: 5 },
          { countryCode: 'MY', countryName: 'Malaysia', bankCount: 5 },
          { countryCode: 'TH', countryName: 'Thailand', bankCount: 5 },
          { countryCode: 'ID', countryName: 'Indonesia', bankCount: 5 },
          { countryCode: 'PH', countryName: 'Philippines', bankCount: 5 },
          { countryCode: 'VN', countryName: 'Vietnam', bankCount: 5 },
          { countryCode: 'BD', countryName: 'Bangladesh', bankCount: 3 },
          { countryCode: 'LK', countryName: 'Sri Lanka', bankCount: 3 },
          { countryCode: 'PK', countryName: 'Pakistan', bankCount: 3 },
          { countryCode: 'NZ', countryName: 'New Zealand', bankCount: 4 },
          
          // Europe
          { countryCode: 'BE', countryName: 'Belgium', bankCount: 3 },
          { countryCode: 'AT', countryName: 'Austria', bankCount: 3 },
          { countryCode: 'PT', countryName: 'Portugal', bankCount: 3 },
          { countryCode: 'IE', countryName: 'Ireland', bankCount: 3 },
          { countryCode: 'PL', countryName: 'Poland', bankCount: 3 },
          { countryCode: 'CZ', countryName: 'Czech Republic', bankCount: 3 },
          { countryCode: 'HU', countryName: 'Hungary', bankCount: 3 },
          { countryCode: 'RO', countryName: 'Romania', bankCount: 3 },
          { countryCode: 'BG', countryName: 'Bulgaria', bankCount: 3 },
          { countryCode: 'HR', countryName: 'Croatia', bankCount: 3 },
          { countryCode: 'RS', countryName: 'Serbia', bankCount: 3 },
          { countryCode: 'SE', countryName: 'Sweden', bankCount: 3 },
          { countryCode: 'NO', countryName: 'Norway', bankCount: 3 },
          { countryCode: 'DK', countryName: 'Denmark', bankCount: 3 },
          { countryCode: 'FI', countryName: 'Finland', bankCount: 3 },
          { countryCode: 'IS', countryName: 'Iceland', bankCount: 3 },
          { countryCode: 'GR', countryName: 'Greece', bankCount: 3 },
          
          // Middle East & Gulf
          { countryCode: 'AE', countryName: 'United Arab Emirates', bankCount: 4 },
          { countryCode: 'SA', countryName: 'Saudi Arabia', bankCount: 4 },
          { countryCode: 'QA', countryName: 'Qatar', bankCount: 2 },
          { countryCode: 'KW', countryName: 'Kuwait', bankCount: 2 },
          { countryCode: 'BH', countryName: 'Bahrain', bankCount: 2 },
          { countryCode: 'OM', countryName: 'Oman', bankCount: 2 },
          { countryCode: 'IL', countryName: 'Israel', bankCount: 3 },
          { countryCode: 'TR', countryName: 'Turkey', bankCount: 4 },
          { countryCode: 'JO', countryName: 'Jordan', bankCount: 3 },
          { countryCode: 'LB', countryName: 'Lebanon', bankCount: 3 },
          
          // Africa
          { countryCode: 'NG', countryName: 'Nigeria', bankCount: 7 },
          { countryCode: 'KE', countryName: 'Kenya', bankCount: 6 },
          { countryCode: 'EG', countryName: 'Egypt', bankCount: 5 },
          { countryCode: 'MA', countryName: 'Morocco', bankCount: 5 },
          { countryCode: 'GH', countryName: 'Ghana', bankCount: 5 },
          { countryCode: 'ZW', countryName: 'Zimbabwe', bankCount: 5 },
          { countryCode: 'TN', countryName: 'Tunisia', bankCount: 3 },
          { countryCode: 'DZ', countryName: 'Algeria', bankCount: 3 },
          { countryCode: 'ET', countryName: 'Ethiopia', bankCount: 3 },
          { countryCode: 'TZ', countryName: 'Tanzania', bankCount: 3 },
          { countryCode: 'UG', countryName: 'Uganda', bankCount: 3 },
          { countryCode: 'BW', countryName: 'Botswana', bankCount: 3 },
          { countryCode: 'ZM', countryName: 'Zambia', bankCount: 3 },
          { countryCode: 'NA', countryName: 'Namibia', bankCount: 3 },
          { countryCode: 'MZ', countryName: 'Mozambique', bankCount: 3 },
          { countryCode: 'AO', countryName: 'Angola', bankCount: 3 },
          { countryCode: 'SN', countryName: 'Senegal', bankCount: 3 },
          { countryCode: 'CI', countryName: 'CÃ´te d\'Ivoire', bankCount: 3 },
          { countryCode: 'CM', countryName: 'Cameroon', bankCount: 3 },
          { countryCode: 'RW', countryName: 'Rwanda', bankCount: 3 },
          { countryCode: 'MU', countryName: 'Mauritius', bankCount: 3 },
          
          // Latin America & Caribbean
          { countryCode: 'CL', countryName: 'Chile', bankCount: 4 },
          { countryCode: 'CO', countryName: 'Colombia', bankCount: 4 },
          { countryCode: 'PE', countryName: 'Peru', bankCount: 4 },
          { countryCode: 'UY', countryName: 'Uruguay', bankCount: 3 },
          { countryCode: 'EC', countryName: 'Ecuador', bankCount: 3 },
          { countryCode: 'VE', countryName: 'Venezuela', bankCount: 3 },
          { countryCode: 'BO', countryName: 'Bolivia', bankCount: 3 },
          { countryCode: 'PY', countryName: 'Paraguay', bankCount: 3 },
          { countryCode: 'GT', countryName: 'Guatemala', bankCount: 3 },
          { countryCode: 'CR', countryName: 'Costa Rica', bankCount: 3 },
          { countryCode: 'PA', countryName: 'Panama', bankCount: 3 },
          { countryCode: 'JM', countryName: 'Jamaica', bankCount: 3 },
          { countryCode: 'TT', countryName: 'Trinidad and Tobago', bankCount: 3 },
          { countryCode: 'BB', countryName: 'Barbados', bankCount: 2 },
          { countryCode: 'BS', countryName: 'Bahamas', bankCount: 2 },
          
          // Additional countries with basic banking infrastructure
          { countryCode: 'LU', countryName: 'Luxembourg', bankCount: 2 },
          { countryCode: 'MT', countryName: 'Malta', bankCount: 2 },
          { countryCode: 'CY', countryName: 'Cyprus', bankCount: 2 },
          { countryCode: 'AD', countryName: 'Andorra', bankCount: 1 },
          { countryCode: 'MC', countryName: 'Monaco', bankCount: 1 },
          { countryCode: 'LI', countryName: 'Liechtenstein', bankCount: 1 }
        ];

        res.json({
          success: true,
          countries: fallbackCountries,
          total: fallbackCountries.length,
          fallback: true
        });
      }

    } catch (error) {
      console.error('Error fetching countries with banks:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch countries with banks'
      });
    }
  });

  // Detect user's payment methods based on country
  app.get('/api/payment-methods/detect/:countryCode', async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      // Comprehensive payment methods by country with proper fallbacks
      const paymentMethods: { [key: string]: any } = {
        // North America
        'US': { country: 'United States', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'paypal', 'apple_pay'], cardNetworks: ['visa', 'mastercard', 'american_express', 'discover'], localMethods: ['venmo', 'zelle'] },
        'CA': { country: 'Canada', currency: 'CAD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['interac'] },
        'MX': { country: 'Mexico', currency: 'MXN', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'oxxo'], popular: ['credit_card', 'debit_card', 'oxxo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['oxxo', 'spei'] },
        
        // Europe - Major economies
        'GB': { country: 'United Kingdom', currency: 'GBP', symbol: 'Â£', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['faster_payments', 'bacs'] },
        'DE': { country: 'Germany', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['bank_transfer', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'sofort', 'giropay'] },
        'FR': { country: 'France', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'carte_bleue'] },
        'IT': { country: 'Italy', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'postepay'] },
        'ES': { country: 'Spain', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'bizum'] },
        'NL': { country: 'Netherlands', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'ideal', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'ideal'] },
        'CH': { country: 'Switzerland', currency: 'CHF', symbol: 'CHF', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['twint', 'postfinance'] },
        'BE': { country: 'Belgium', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'bancontact', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'bancontact'] },
        'AT': { country: 'Austria', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'eps', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'eps'] },
        'PT': { country: 'Portugal', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'multibanco'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa', 'multibanco'] },
        'IE': { country: 'Ireland', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SE': { country: 'Sweden', currency: 'SEK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'swish', 'apple_pay', 'google_pay'], popular: ['swish', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['swish', 'bankgiro'] },
        'NO': { country: 'Norway', currency: 'NOK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'vipps', 'apple_pay', 'google_pay'], popular: ['vipps', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['vipps', 'bankgiro'] },
        'DK': { country: 'Denmark', currency: 'DKK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobilepay', 'apple_pay', 'google_pay'], popular: ['mobilepay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mobilepay'] },
        'FI': { country: 'Finland', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['debit_card', 'credit_card', 'online_banking'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'IS': { country: 'Iceland', currency: 'ISK', symbol: 'kr', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['Ã­slandsbankinn'] },
        'PL': { country: 'Poland', currency: 'PLN', symbol: 'zÅ‚', methods: ['credit_card', 'debit_card', 'bank_transfer', 'blik', 'paypal'], popular: ['blik', 'debit_card', 'przelewy24'], cardNetworks: ['visa', 'mastercard'], localMethods: ['blik', 'przelewy24'] },
        'CZ': { country: 'Czech Republic', currency: 'CZK', symbol: 'KÄ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['csob_pay'] },
        'HU': { country: 'Hungary', currency: 'HUF', symbol: 'Ft', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['barion'] },
        'RO': { country: 'Romania', currency: 'RON', symbol: 'lei', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['netopia'] },
        'BG': { country: 'Bulgaria', currency: 'BGN', symbol: 'Ð»Ð²', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['epay'] },
        'HR': { country: 'Croatia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'RS': { country: 'Serbia', currency: 'RSD', symbol: 'Ð´Ð¸Ð½', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ips'] },
        'GR': { country: 'Greece', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SK': { country: 'Slovakia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'SI': { country: 'Slovenia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LT': { country: 'Lithuania', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LV': { country: 'Latvia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'EE': { country: 'Estonia', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'LU': { country: 'Luxembourg', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'MT': { country: 'Malta', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        'CY': { country: 'Cyprus', currency: 'EUR', symbol: 'â‚¬', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sepa'] },
        
        // Asia-Pacific
        'JP': { country: 'Japan', currency: 'JPY', symbol: 'Â¥', methods: ['credit_card', 'debit_card', 'bank_transfer', 'convenience_store', 'mobile_pay'], popular: ['credit_card', 'convenience_store', 'mobile_pay'], cardNetworks: ['visa', 'mastercard', 'jcb'], localMethods: ['konbini', 'paypay', 'rakuten_pay'] },
        'CN': { country: 'China', currency: 'CNY', symbol: 'Â¥', methods: ['mobile_pay', 'bank_transfer', 'unionpay'], popular: ['mobile_pay', 'unionpay'], cardNetworks: ['unionpay'], localMethods: ['alipay', 'wechat_pay', 'unionpay'] },
        'KR': { country: 'South Korea', currency: 'KRW', symbol: 'â‚©', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_pay', 'kakaopay'], popular: ['kakaopay', 'credit_card', 'samsung_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kakaopay', 'naver_pay', 'toss'] },
        'IN': { country: 'India', currency: 'INR', symbol: 'â‚¹', methods: ['credit_card', 'debit_card', 'bank_transfer', 'upi', 'wallet'], popular: ['upi', 'debit_card', 'wallet'], cardNetworks: ['visa', 'mastercard', 'rupay'], localMethods: ['upi', 'paytm', 'phonepe', 'razorpay', 'imps', 'neft'] },
        'AU': { country: 'Australia', currency: 'AUD', symbol: 'A$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard', 'american_express'], localMethods: ['osko', 'bpay'] },
        'NZ': { country: 'New Zealand', currency: 'NZD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paypal', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'paypal'], cardNetworks: ['visa', 'mastercard'], localMethods: ['poli'] },
        'SG': { country: 'Singapore', currency: 'SGD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'paynow', 'grabpay'], popular: ['paynow', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['paynow', 'grabpay'] },
        'HK': { country: 'Hong Kong', currency: 'HKD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'alipay_hk', 'apple_pay'], popular: ['credit_card', 'octopus', 'alipay_hk'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fps', 'alipay_hk'] },
        'TW': { country: 'Taiwan', currency: 'TWD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'line_pay'], popular: ['credit_card', 'line_pay', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['line_pay', 'jkopay'] },
        'MY': { country: 'Malaysia', currency: 'MYR', symbol: 'RM', methods: ['credit_card', 'debit_card', 'bank_transfer', 'grabpay', 'boost'], popular: ['grabpay', 'fpx', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fpx', 'grabpay', 'boost'] },
        'TH': { country: 'Thailand', currency: 'THB', symbol: 'à¸¿', methods: ['credit_card', 'debit_card', 'bank_transfer', 'promptpay', 'truemoney'], popular: ['promptpay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['promptpay', 'truemoney'] },
        'ID': { country: 'Indonesia', currency: 'IDR', symbol: 'Rp', methods: ['credit_card', 'debit_card', 'bank_transfer', 'gopay', 'ovo'], popular: ['gopay', 'ovo', 'dana'], cardNetworks: ['visa', 'mastercard'], localMethods: ['gopay', 'ovo', 'dana', 'linkaja'] },
        'PH': { country: 'Philippines', currency: 'PHP', symbol: 'â‚±', methods: ['credit_card', 'debit_card', 'bank_transfer', 'gcash', 'paymaya'], popular: ['gcash', 'paymaya', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['gcash', 'paymaya', 'coins_ph'] },
        'VN': { country: 'Vietnam', currency: 'VND', symbol: 'â‚«', methods: ['credit_card', 'debit_card', 'bank_transfer', 'momo', 'zalopay'], popular: ['momo', 'zalopay', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['momo', 'zalopay', 'vnpay'] },
        'BD': { country: 'Bangladesh', currency: 'BDT', symbol: 'à§³', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_banking'], popular: ['bkash', 'nagad', 'rocket'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bkash', 'nagad', 'rocket'] },
        'LK': { country: 'Sri Lanka', currency: 'LKR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['lanka_qr'] },
        'PK': { country: 'Pakistan', currency: 'PKR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer', 'easypaisa', 'jazzcash'], popular: ['easypaisa', 'jazzcash', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['easypaisa', 'jazzcash'] },
        
        // Latin America
        'BR': { country: 'Brazil', currency: 'BRL', symbol: 'R$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'pix'], popular: ['pix', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard', 'elo'], localMethods: ['pix', 'boleto', 'ted', 'doc'] },
        'AR': { country: 'Argentina', currency: 'ARS', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mercado_pago'], popular: ['mercado_pago', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mercado_pago', 'rapipago'] },
        'CL': { country: 'Chile', currency: 'CLP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'webpay'], popular: ['webpay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['webpay', 'khipu'] },
        'CO': { country: 'Colombia', currency: 'COP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'nequi', 'daviplata'], popular: ['nequi', 'daviplata', 'pse'], cardNetworks: ['visa', 'mastercard'], localMethods: ['pse', 'nequi', 'daviplata'] },
        'PE': { country: 'Peru', currency: 'PEN', symbol: 'S/', methods: ['credit_card', 'debit_card', 'bank_transfer', 'yape', 'plin'], popular: ['yape', 'plin', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['yape', 'plin', 'pagoefectivo'] },
        'UY': { country: 'Uruguay', currency: 'UYU', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['abitab', 'redpagos'] },
        'EC': { country: 'Ecuador', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kushki'] },
        'VE': { country: 'Venezuela', currency: 'VES', symbol: 'Bs', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['bank_transfer', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['banesco'] },
        'BO': { country: 'Bolivia', currency: 'BOB', symbol: 'Bs', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['qr_boliviano'] },
        'PY': { country: 'Paraguay', currency: 'PYG', symbol: 'â‚²', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['personal_pay'] },
        'GT': { country: 'Guatemala', currency: 'GTQ', symbol: 'Q', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['visacuotas'] },
        'CR': { country: 'Costa Rica', currency: 'CRC', symbol: 'â‚¡', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'sinpe_movil'], cardNetworks: ['visa', 'mastercard'], localMethods: ['sinpe_movil'] },
        'PA': { country: 'Panama', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ace'] },
        'DO': { country: 'Dominican Republic', currency: 'DOP', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cardnet'] },
        'JM': { country: 'Jamaica', currency: 'JMD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['lynk'] },
        'TT': { country: 'Trinidad and Tobago', currency: 'TTD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['linx'] },
        'BB': { country: 'Barbados', currency: 'BBD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        'BS': { country: 'Bahamas', currency: 'BSD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        
        // Africa
        'ZA': { country: 'South Africa', currency: 'ZAR', symbol: 'R', methods: ['credit_card', 'debit_card', 'bank_transfer', 'eft'], popular: ['debit_card', 'credit_card', 'eft'], cardNetworks: ['visa', 'mastercard'], localMethods: ['eft', 'instant_eft'] },
        'NG': { country: 'Nigeria', currency: 'NGN', symbol: 'â‚¦', methods: ['credit_card', 'debit_card', 'bank_transfer', 'ussd'], popular: ['bank_transfer', 'ussd', 'debit_card'], cardNetworks: ['visa', 'mastercard', 'verve'], localMethods: ['ussd', 'quickteller', 'paystack'] },
        'KE': { country: 'Kenya', currency: 'KES', symbol: 'KSh', methods: ['mobile_money', 'bank_transfer', 'credit_card'], popular: ['mobile_money', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'airtel_money'] },
        'EG': { country: 'Egypt', currency: 'EGP', symbol: 'EÂ£', methods: ['credit_card', 'debit_card', 'bank_transfer', 'fawry'], popular: ['fawry', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['fawry', 'vodafone_cash'] },
        'MA': { country: 'Morocco', currency: 'MAD', symbol: 'Ø¯.Ù….', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cmi'] },
        'GH': { country: 'Ghana', currency: 'GHS', symbol: 'â‚µ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'vodafone_cash'] },
        'ZW': { country: 'Zimbabwe', currency: 'USD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'ecocash'], cardNetworks: ['visa', 'mastercard'], localMethods: ['ecocash', 'onemoney'] },
        'TN': { country: 'Tunisia', currency: 'TND', symbol: 'Ø¯.Øª', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['e_dinar'] },
        'DZ': { country: 'Algeria', currency: 'DZD', symbol: 'Ø¯.Ø¬', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['cib'] },
        'ET': { country: 'Ethiopia', currency: 'ETB', symbol: 'Br', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'bank_transfer', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['telebirr'] },
        'TZ': { country: 'Tanzania', currency: 'TZS', symbol: 'TSh', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mpesa'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'tigo_pesa'] },
        'UG': { country: 'Uganda', currency: 'UGX', symbol: 'USh', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mtn_momo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'airtel_money'] },
        'BW': { country: 'Botswana', currency: 'BWP', symbol: 'P', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mygate'] },
        'ZM': { country: 'Zambia', currency: 'ZMW', symbol: 'K', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'airtel_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['airtel_money', 'mtn_momo'] },
        'NA': { country: 'Namibia', currency: 'NAD', symbol: '$', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['switch'] },
        'MZ': { country: 'Mozambique', currency: 'MZN', symbol: 'MT', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mpesa'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mpesa', 'mkesh'] },
        'AO': { country: 'Angola', currency: 'AOA', symbol: 'Kz', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['multicaixa'] },
        'SN': { country: 'Senegal', currency: 'XOF', symbol: 'CFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'free_money'] },
        'CI': { country: 'CÃ´te d\'Ivoire', currency: 'XOF', symbol: 'CFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'mtn_momo'] },
        'CM': { country: 'Cameroon', currency: 'XAF', symbol: 'FCFA', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'orange_money'], cardNetworks: ['visa', 'mastercard'], localMethods: ['orange_money', 'mtn_momo'] },
        'RW': { country: 'Rwanda', currency: 'RWF', symbol: 'FRw', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mobile_money'], popular: ['mobile_money', 'bank_transfer', 'mtn_momo'], cardNetworks: ['visa', 'mastercard'], localMethods: ['mtn_momo', 'airtel_money'] },
        'MU': { country: 'Mauritius', currency: 'MUR', symbol: 'â‚¨', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['juice'] },
        
        // Middle East & Gulf
        'AE': { country: 'United Arab Emirates', currency: 'AED', symbol: 'Ø¯.Ø¥', methods: ['credit_card', 'debit_card', 'bank_transfer', 'apple_pay', 'google_pay'], popular: ['credit_card', 'debit_card', 'apple_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['payby', 'cbd_now'] },
        'SA': { country: 'Saudi Arabia', currency: 'SAR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer', 'stcpay', 'apple_pay'], popular: ['stcpay', 'mada', 'credit_card'], cardNetworks: ['visa', 'mastercard', 'mada'], localMethods: ['stcpay', 'mada'] },
        'QA': { country: 'Qatar', currency: 'QAR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer', 'apple_pay'], popular: ['credit_card', 'debit_card', 'apple_pay'], cardNetworks: ['visa', 'mastercard'], localMethods: ['qpay'] },
        'KW': { country: 'Kuwait', currency: 'KWD', symbol: 'Ø¯.Ùƒ', methods: ['credit_card', 'debit_card', 'bank_transfer', 'knet'], popular: ['knet', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['knet'] },
        'BH': { country: 'Bahrain', currency: 'BHD', symbol: '.Ø¯.Ø¨', methods: ['credit_card', 'debit_card', 'bank_transfer', 'benefit_pay'], popular: ['benefit_pay', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['benefit_pay'] },
        'OM': { country: 'Oman', currency: 'OMR', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['thunes'] },
        'IL': { country: 'Israel', currency: 'ILS', symbol: 'â‚ª', methods: ['credit_card', 'debit_card', 'bank_transfer', 'bit', 'paypal'], popular: ['bit', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bit', 'isracard'] },
        'TR': { country: 'Turkey', currency: 'TRY', symbol: 'â‚º', methods: ['credit_card', 'debit_card', 'bank_transfer', 'papara', 'paypal'], popular: ['papara', 'credit_card', 'debit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['papara', 'iyzico'] },
        'JO': { country: 'Jordan', currency: 'JOD', symbol: 'Ø¯.Ø£', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['jopacc'] },
        'LB': { country: 'Lebanon', currency: 'LBP', symbol: 'ï·¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['credit_card', 'debit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['whish_money'] },
        
        // Eastern Europe & CIS
        'RU': { country: 'Russia', currency: 'RUB', symbol: 'â‚½', methods: ['credit_card', 'debit_card', 'bank_transfer', 'mir_pay'], popular: ['mir_pay', 'sberbank', 'yandex_money'], cardNetworks: ['mir', 'visa', 'mastercard'], localMethods: ['mir_pay', 'sberbank_online', 'yandex_money'] },
        'UA': { country: 'Ukraine', currency: 'UAH', symbol: 'â‚´', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['privat24', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['privat24', 'liqpay'] },
        'BY': { country: 'Belarus', currency: 'BYN', symbol: 'Br', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['belcard'] },
        'GE': { country: 'Georgia', currency: 'GEL', symbol: 'â‚¾', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['bog'] },
        'AM': { country: 'Armenia', currency: 'AMD', symbol: 'Ö', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['idram'] },
        'AZ': { country: 'Azerbaijan', currency: 'AZN', symbol: 'â‚¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kapital_bank'] },
        'MD': { country: 'Moldova', currency: 'MDL', symbol: 'lei', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['debit_card', 'credit_card', 'bank_transfer'], cardNetworks: ['visa', 'mastercard'], localMethods: ['maib'] },
        'KZ': { country: 'Kazakhstan', currency: 'KZT', symbol: 'â‚¸', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['kaspi_pay', 'debit_card', 'credit_card'], cardNetworks: ['visa', 'mastercard'], localMethods: ['kaspi_pay'] },
        'UZ': { country: 'Uzbekistan', currency: 'UZS', symbol: 'ÑÑžÐ¼', methods: ['credit_card', 'debit_card', 'bank_transfer'], popular: ['uzcard', 'humo', 'bank_transfer'], cardNetworks: ['uzcard', 'humo'], localMethods: ['uzcard', 'humo'] }
      };

      // Get country-specific banks
      let countryBanks = [];
      try {
        countryBanks = await db
          .select({
            id: banks.id,
            bankName: banks.bankName,
            bankCode: banks.bankCode,
            swiftCode: banks.swiftCode
          })
          .from(banks)
          .where(and(
            eq(banks.countryCode, countryCode.toUpperCase()),
            eq(banks.isActive, true)
          ))
          .orderBy(asc(banks.bankName))
          .limit(20);
      } catch (dbError) {
        console.log('Database unavailable for bank detection');
      }

      // Create fallback payment info for countries not explicitly configured
      const createFallbackPaymentInfo = (countryCode: string, countryName: string) => {
        // Use USD as default currency for most countries not listed
        let currency = 'USD';
        let symbol = '$';
        
        // Use EUR for European countries not explicitly mapped
        const euroCountries = ['AD', 'MC', 'SM', 'VA', 'ME', 'XK', 'MK', 'AL', 'BA', 'RS'];
        if (euroCountries.includes(countryCode)) {
          currency = 'EUR';
          symbol = 'â‚¬';
        }
        
        return {
          country: countryName || countryCode,
          currency: currency,
          symbol: symbol,
          methods: ['credit_card', 'debit_card', 'bank_transfer'],
          popular: ['debit_card', 'credit_card', 'bank_transfer'],
          cardNetworks: ['visa', 'mastercard'],
          localMethods: ['bank_transfer']
        };
      };
      
      // Get payment methods for country with comprehensive fallback
      let countryPaymentInfo = paymentMethods[countryCode.toUpperCase()];
      
      if (!countryPaymentInfo) {
        // Get country name from our comprehensive mapping
        const countryNames: { [key: string]: string } = {
          'AF': 'Afghanistan', 'AL': 'Albania', 'DZ': 'Algeria', 'AS': 'American Samoa', 'AD': 'Andorra',
          'AO': 'Angola', 'AI': 'Anguilla', 'AQ': 'Antarctica', 'AG': 'Antigua and Barbuda', 'AR': 'Argentina',
          'AM': 'Armenia', 'AW': 'Aruba', 'AU': 'Australia', 'AT': 'Austria', 'AZ': 'Azerbaijan',
          'BS': 'Bahamas', 'BH': 'Bahrain', 'BD': 'Bangladesh', 'BB': 'Barbados', 'BY': 'Belarus',
          'BE': 'Belgium', 'BZ': 'Belize', 'BJ': 'Benin', 'BM': 'Bermuda', 'BT': 'Bhutan',
          'BO': 'Bolivia', 'BA': 'Bosnia and Herzegovina', 'BW': 'Botswana', 'BR': 'Brazil',
          'IO': 'British Indian Ocean Territory', 'VG': 'British Virgin Islands', 'BN': 'Brunei',
          'BG': 'Bulgaria', 'BF': 'Burkina Faso', 'BI': 'Burundi', 'KH': 'Cambodia', 'CM': 'Cameroon',
          'CA': 'Canada', 'CV': 'Cape Verde', 'BQ': 'Caribbean Netherlands', 'KY': 'Cayman Islands',
          'CF': 'Central African Republic', 'TD': 'Chad', 'CL': 'Chile', 'CN': 'China', 'CX': 'Christmas Island',
          'CC': 'Cocos Islands', 'CO': 'Colombia', 'KM': 'Comoros', 'CG': 'Congo', 'CD': 'Congo (DRC)',
          'CK': 'Cook Islands', 'CR': 'Costa Rica', 'CI': 'CÃ´te d\'Ivoire', 'HR': 'Croatia', 'CU': 'Cuba',
          'CW': 'CuraÃ§ao', 'CY': 'Cyprus', 'CZ': 'Czech Republic', 'DK': 'Denmark', 'DJ': 'Djibouti',
          'DM': 'Dominica', 'DO': 'Dominican Republic', 'EC': 'Ecuador', 'EG': 'Egypt', 'SV': 'El Salvador',
          'GQ': 'Equatorial Guinea', 'ER': 'Eritrea', 'EE': 'Estonia', 'ET': 'Ethiopia', 'FK': 'Falkland Islands',
          'FO': 'Faroe Islands', 'FJ': 'Fiji', 'FI': 'Finland', 'FR': 'France', 'GF': 'French Guiana',
          'PF': 'French Polynesia', 'TF': 'French Southern Territories', 'GA': 'Gabon', 'GM': 'Gambia',
          'GE': 'Georgia', 'DE': 'Germany', 'GH': 'Ghana', 'GI': 'Gibraltar', 'GR': 'Greece',
          'GL': 'Greenland', 'GD': 'Grenada', 'GP': 'Guadeloupe', 'GU': 'Guam', 'GT': 'Guatemala',
          'GG': 'Guernsey', 'GN': 'Guinea', 'GW': 'Guinea-Bissau', 'GY': 'Guyana', 'HT': 'Haiti',
          'HM': 'Heard Island and McDonald Islands', 'VA': 'Vatican City', 'HN': 'Honduras', 'HK': 'Hong Kong',
          'HU': 'Hungary', 'IS': 'Iceland', 'IN': 'India', 'ID': 'Indonesia', 'IR': 'Iran', 'IQ': 'Iraq',
          'IE': 'Ireland', 'IM': 'Isle of Man', 'IL': 'Israel', 'IT': 'Italy', 'JM': 'Jamaica',
          'JP': 'Japan', 'JE': 'Jersey', 'JO': 'Jordan', 'KZ': 'Kazakhstan', 'KE': 'Kenya', 'KI': 'Kiribati',
          'KP': 'North Korea', 'KR': 'South Korea', 'KW': 'Kuwait', 'KG': 'Kyrgyzstan', 'LA': 'Laos',
          'LV': 'Latvia', 'LB': 'Lebanon', 'LS': 'Lesotho', 'LR': 'Liberia', 'LY': 'Libya',
          'LI': 'Liechtenstein', 'LT': 'Lithuania', 'LU': 'Luxembourg', 'MO': 'Macao', 'MK': 'North Macedonia',
          'MG': 'Madagascar', 'MW': 'Malawi', 'MY': 'Malaysia', 'MV': 'Maldives', 'ML': 'Mali',
          'MT': 'Malta', 'MH': 'Marshall Islands', 'MQ': 'Martinique', 'MR': 'Mauritania', 'MU': 'Mauritius',
          'YT': 'Mayotte', 'MX': 'Mexico', 'FM': 'Micronesia', 'MD': 'Moldova', 'MC': 'Monaco',
          'MN': 'Mongolia', 'ME': 'Montenegro', 'MS': 'Montserrat', 'MA': 'Morocco', 'MZ': 'Mozambique',
          'MM': 'Myanmar', 'NA': 'Namibia', 'NR': 'Nauru', 'NP': 'Nepal', 'NL': 'Netherlands',
          'NC': 'New Caledonia', 'NZ': 'New Zealand', 'NI': 'Nicaragua', 'NE': 'Niger', 'NG': 'Nigeria',
          'NU': 'Niue', 'NF': 'Norfolk Island', 'MP': 'Northern Mariana Islands', 'NO': 'Norway',
          'OM': 'Oman', 'PK': 'Pakistan', 'PW': 'Palau', 'PS': 'Palestine', 'PA': 'Panama',
          'PG': 'Papua New Guinea', 'PY': 'Paraguay', 'PE': 'Peru', 'PH': 'Philippines', 'PN': 'Pitcairn',
          'PL': 'Poland', 'PT': 'Portugal', 'PR': 'Puerto Rico', 'QA': 'Qatar', 'RE': 'RÃ©union',
          'RO': 'Romania', 'RU': 'Russia', 'RW': 'Rwanda', 'BL': 'Saint BarthÃ©lemy', 'SH': 'Saint Helena',
          'KN': 'Saint Kitts and Nevis', 'LC': 'Saint Lucia', 'MF': 'Saint Martin', 'PM': 'Saint Pierre and Miquelon',
          'VC': 'Saint Vincent and the Grenadines', 'WS': 'Samoa', 'SM': 'San Marino', 'ST': 'SÃ£o TomÃ© and PrÃ­ncipe',
          'SA': 'Saudi Arabia', 'SN': 'Senegal', 'RS': 'Serbia', 'SC': 'Seychelles', 'SL': 'Sierra Leone',
          'SG': 'Singapore', 'SX': 'Sint Maarten', 'SK': 'Slovakia', 'SI': 'Slovenia', 'SB': 'Solomon Islands',
          'SO': 'Somalia', 'ZA': 'South Africa', 'GS': 'South Georgia and the South Sandwich Islands', 'SS': 'South Sudan',
          'ES': 'Spain', 'LK': 'Sri Lanka', 'SD': 'Sudan', 'SR': 'Suriname', 'SJ': 'Svalbard and Jan Mayen',
          'SZ': 'Eswatini', 'SE': 'Sweden', 'CH': 'Switzerland', 'SY': 'Syria', 'TW': 'Taiwan',
          'TJ': 'Tajikistan', 'TZ': 'Tanzania', 'TH': 'Thailand', 'TL': 'Timor-Leste', 'TG': 'Togo',
          'TK': 'Tokelau', 'TO': 'Tonga', 'TT': 'Trinidad and Tobago', 'TN': 'Tunisia', 'TR': 'Turkey',
          'TM': 'Turkmenistan', 'TC': 'Turks and Caicos Islands', 'TV': 'Tuvalu', 'UG': 'Uganda',
          'UA': 'Ukraine', 'AE': 'United Arab Emirates', 'GB': 'United Kingdom', 'US': 'United States',
          'UM': 'United States Minor Outlying Islands', 'UY': 'Uruguay', 'UZ': 'Uzbekistan', 'VU': 'Vanuatu',
          'VE': 'Venezuela', 'VN': 'Vietnam', 'VI': 'U.S. Virgin Islands', 'WF': 'Wallis and Futuna',
          'EH': 'Western Sahara', 'YE': 'Yemen', 'ZM': 'Zambia', 'ZW': 'Zimbabwe', 'XK': 'Kosovo'
        };
        
        const countryName = countryNames[countryCode.toUpperCase()] || countryCode;
        countryPaymentInfo = createFallbackPaymentInfo(countryCode, countryName);
      }

      res.json({
        success: true,
        countryCode: countryCode.toUpperCase(),
        ...countryPaymentInfo,
        banks: countryBanks,
        bankCount: countryBanks.length,
        detectedAt: new Date().toISOString()
      });

    } catch (error) {
      console.error('Error detecting payment methods:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to detect payment methods'
      });
    }
  });

  // Get Current User Profile (from session)
  app.get("/api/profile", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Get user profile
      const profile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: "Profile not found" });
      }

      res.json({ 
        success: true, 
        profile: profile[0] 
      });

    } catch (error) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch profile" });
    }
  });

  // Get User Profile
  app.get("/api/profile/:userId", async (req, res) => {
    try {
      const userId = req.params.userId;

      try {
        // Try database first
        const user = await db
          .select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        if (user.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }

        const profile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        res.json({
          success: true,
          user: {
            id: user[0].id,
            userId: user[0].userId,
            email: user[0].email
          },
          profile: profile.length > 0 ? profile[0] : null
        });

      } catch (dbError) {
        // Fallback to in-memory storage if DB fails
        console.log('Database unavailable, using in-memory storage for profile fetch');
        
        const storedProfile = profileStorage.get(userId);
        if (storedProfile) {
          res.json({
            success: true,
            user: {
              id: userId,
              userId: `USER_${userId.slice(-8)}`,
              email: "user@example.com"
            },
            profile: storedProfile
          });
        } else {
          // Return default profile if none exists
          const defaultProfile = {
            id: `profile_${userId}`,
            userId: userId,
            name: 'Student User',
            age: 18,
            grade: 10,
            educationLevel: 'grade',
            country: 'Unknown',
            countryId: 1,
            avatarUrl: null,
            role: 'student',
            stripeCustomerId: null,
            stripeSubscriptionId: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
          };
          
          profileStorage.set(userId, defaultProfile);
          
          res.json({
            success: true,
            user: {
              id: userId,
              userId: `USER_${userId.slice(-8)}`,
              email: "user@example.com"
            },
            profile: defaultProfile
          });
        }
      }

    } catch (error) {
      console.error('Profile fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch profile" });
    }
  });

  // Update User Profile
  app.put("/api/profile/:userId", async (req, res) => {
    try {
      const userId = req.params.userId;
      const { name, age, grade, educationLevel, country, pronouns } = req.body;

      try {
        // Try database operation first
        const user = await db
          .select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        if (user.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }

        const existingProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        if (existingProfile.length === 0) {
          return res.status(404).json({ success: false, error: "Profile not found" });
        }

        // Prepare update data
        const updateData: any = { updatedAt: new Date() };
        
        if (name !== undefined) updateData.name = name;
        if (age !== undefined) updateData.age = age;
        if (grade !== undefined) updateData.grade = grade;
        if (educationLevel !== undefined) updateData.educationLevel = educationLevel;
        if (country !== undefined) updateData.country = country;
        if (pronouns !== undefined) updateData.pronouns = pronouns;

        // Update profile in database
        await db
          .update(profiles)
          .set(updateData)
          .where(eq(profiles.userId, userId));

        // Get updated profile
        const updatedProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, userId))
          .limit(1);

        res.json({
          success: true,
          message: "Profile updated successfully",
          profile: updatedProfile[0]
        });

      } catch (dbError) {
        console.error('Database error:', dbError);
        return res.status(500).json({ 
          success: false, 
          error: "Database connection failed. Please try again later." 
        });
      }

    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ success: false, error: "Failed to update profile" });
    }
  });

  // Admin Dashboard - Get Platform Statistics
  app.get("/api/admin/stats", async (req, res) => {
    try {
      // Get basic user statistics
      const totalUsers = await db.select({ count: count() }).from(users);
      const totalProfiles = await db.select({ count: count() }).from(profiles);
      
      // Get users by role
      const usersByRole = await db
        .select({
          role: profiles.role,
          count: count()
        })
        .from(profiles)
        .groupBy(profiles.role);

      // Get recent registrations (last 30 days)
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
      const recentRegistrations = await db
        .select({ count: count() })
        .from(users)
        .where(gt(users.createdAt, thirtyDaysAgo));

      res.json({
        success: true,
        data: {
          totalUsers: totalUsers[0].count,
          totalProfiles: totalProfiles[0].count,
          usersByRole,
          recentRegistrations: recentRegistrations[0].count,
          platformHealth: {
            database: "healthy",
            services: "operational"
          }
        }
      });

    } catch (error) {
      console.error('Admin stats error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch admin statistics" });
    }
  });
  // Admin Dashboard - Get Plan Statistics
  app.get('/api/admin/plan-stats', requireAuth, requireAdmin, async (req, res) => {
    try {
      // Count subscriptions from all sources
      const [
        shopMembershipsCount,
        manualAssignmentsCount,
        userSubscriptionsCount
      ] = await Promise.all([
        db.select({ count: count() }).from(shopMemberships),
        db.select({ count: count() }).from(manualPlanAssignments).where(eq(manualPlanAssignments.isActive, true)),
        db.select({ count: count() }).from(userSubscriptions)
      ]);

      const totalSubscriptions = 
        (shopMembershipsCount[0]?.count || 0) +
        (manualAssignmentsCount[0]?.count || 0) +
        (userSubscriptionsCount[0]?.count || 0);

      // Count active subscriptions from all sources
      const [
        activeShopMemberships,
        activeManualAssignments,
        activeUserSubscriptions
      ] = await Promise.all([
        db.select({ count: count() }).from(shopMemberships).where(eq(shopMemberships.status, 'active')),
        db.select({ count: count() }).from(manualPlanAssignments).where(eq(manualPlanAssignments.isActive, true)),
        db.select({ count: count() }).from(userSubscriptions).where(eq(userSubscriptions.subscriptionStatus, 'active'))
      ]);

      const activeSubscriptions =
        (activeShopMemberships[0]?.count || 0) +
        (activeManualAssignments[0]?.count || 0) +
        (activeUserSubscriptions[0]?.count || 0);

      // Calculate total revenue from all successful payments
      const totalRevenueResult = await db
        .select({
          total: sql<string>`COALESCE(SUM(CAST(${payments.amount} AS DECIMAL)), 0)`
        })
        .from(payments)
        .where(eq(payments.status, 'succeeded'));
      
      const totalRevenue = parseFloat(totalRevenueResult[0]?.total || '0');

      // Calculate revenue by user role
      const revenueByRoleResult = await db
        .select({
          role: profiles.role,
          total: sql<string>`COALESCE(SUM(CAST(${payments.amount} AS DECIMAL)), 0)`
        })
        .from(payments)
        .leftJoin(users, eq(payments.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(payments.status, 'succeeded'))
        .groupBy(profiles.role);

      // Build revenue by role object
      const revenueByRole = {
        student: 0,
        freelancer: 0,
        teacher: 0,
        general: 0
      };

      revenueByRoleResult.forEach((row: any) => {
        const role = row.role || 'general';
        const amount = parseFloat(row.total || '0');
        
        if (role === 'student') {
          revenueByRole.student += amount;
        } else if (role === 'freelancer') {
          revenueByRole.freelancer += amount;
        } else if (role === 'teacher') {
          revenueByRole.teacher += amount;
        } else {
          revenueByRole.general += amount;
        }
      });

      // Get plan statistics from shop memberships
      const shopPlanStats = await db
        .select({
          planName: shopMemberships.plan,
          count: count(),
          activeCount: sql<number>`COUNT(CASE WHEN ${shopMemberships.status} = 'active' THEN 1 END)`
        })
        .from(shopMemberships)
        .groupBy(shopMemberships.plan);

      // Get plan statistics from user subscriptions
      const userPlanStats = await db
        .select({
          planId: userSubscriptions.planId,
          planName: pricingPlans.displayName,
          gradeTier: pricingPlans.gradeTier,
          count: count(),
          activeCount: sql<number>`COUNT(CASE WHEN ${userSubscriptions.subscriptionStatus} = 'active' THEN 1 END)`
        })
        .from(userSubscriptions)
        .leftJoin(pricingPlans, eq(userSubscriptions.planId, pricingPlans.id))
        .groupBy(userSubscriptions.planId, pricingPlans.displayName, pricingPlans.gradeTier);

      // Combine plan stats
      const planStats = [
        ...shopPlanStats.map((stat: any) => ({
          planName: stat.planName,
          count: stat.count,
          activeCount: stat.activeCount
        })),
        ...userPlanStats
      ];

      // Get recent subscriptions from shop memberships
      const recentShopSubscriptions = await db
        .select({
          id: shopMemberships.id,
          userId: shopCustomers.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          userRole: profiles.role,
          planName: shopMemberships.plan,
          status: shopMemberships.status,
          startDate: shopMemberships.createdAt,
          endDate: shopMemberships.renewalDate,
          createdAt: shopMemberships.createdAt
        })
        .from(shopMemberships)
        .leftJoin(shopCustomers, eq(shopMemberships.customerId, shopCustomers.id))
        .leftJoin(users, eq(shopCustomers.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .orderBy(desc(shopMemberships.createdAt))
        .limit(10);

      // Get recent subscriptions from user subscriptions
      const recentUserSubscriptions = await db
        .select({
          id: userSubscriptions.id,
          userId: userSubscriptions.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          userRole: profiles.role,
          planName: pricingPlans.displayName,
          gradeTier: pricingPlans.gradeTier,
          status: userSubscriptions.subscriptionStatus,
          startDate: userSubscriptions.startDate,
          endDate: userSubscriptions.endDate,
          createdAt: userSubscriptions.createdAt
        })
        .from(userSubscriptions)
        .leftJoin(users, sql`${userSubscriptions.userId} = ${users.userId}`)
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .leftJoin(pricingPlans, eq(userSubscriptions.planId, pricingPlans.id))
        .orderBy(desc(userSubscriptions.createdAt))
        .limit(10);

      // Combine and sort recent subscriptions
      const recentSubscriptions = [...recentShopSubscriptions, ...recentUserSubscriptions]
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 20);

      // Get recent payments with user details
      const recentPayments = await db
        .select({
          id: payments.id,
          userId: payments.userId,
          userName: profiles.name,
          userEmail: profiles.email,
          amount: payments.amount,
          status: payments.status,
          planType: payments.planType,
          createdAt: payments.createdAt
        })
        .from(payments)
        .leftJoin(users, eq(payments.userId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .orderBy(desc(payments.createdAt))
        .limit(20);

      res.json({
        success: true,
        stats: {
          totalRevenue,
          revenueByRole,
          totalSubscriptions,
          activeSubscriptions,
          planStats,
          recentSubscriptions,
          recentPayments
        }
      });

    } catch (error) {
      console.error('Admin plan stats error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch plan statistics" });
    }
  });

  // Admin Dashboard - Get All Users
  app.get("/api/admin/users", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { page = 1, limit = 50, search = '', role = '' } = req.query;
      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);

      let query = db
        .select({
          id: users.id,
          userId: users.userId,
          email: users.email,
          createdAt: users.createdAt,
          name: profiles.name,
          age: profiles.age,
          grade: profiles.grade,
          country: profiles.country,
          role: profiles.role,
          status: profiles.status,
          avatarUrl: profiles.avatarUrl,
          verificationBadge: profiles.verificationBadge,
          isFeatured: profiles.isFeatured,
          subscriptionTier: profiles.subscriptionTier,
          planExpiry: profiles.planExpiry,
        })
        .from(users)
        .leftJoin(profiles, eq(users.id, profiles.userId));

      // Apply filters
      const conditions = [];
      
      if (search) {
        conditions.push(
          or(
            like(users.email, `%${search}%`),
            like(profiles.name, `%${search}%`),
            like(users.userId, `%${search}%`)
          )
        );
      }

      if (role) {
        conditions.push(eq(profiles.role, role as string));
      }

      if (conditions.length > 0) {
        query = query.where(and(...conditions)) as any;
      }

      const usersData = await query
        .orderBy(desc(users.createdAt))
        .limit(parseInt(limit as string))
        .offset(offset);

      // Get total count for pagination
      let countQuery = db.select({ count: count() }).from(users).leftJoin(profiles, eq(users.id, profiles.userId));
      if (conditions.length > 0) {
        countQuery = countQuery.where(and(...conditions)) as any;
      }
      const totalCount = await countQuery;

      res.json({
        success: true,
        data: usersData,
        pagination: {
          page: parseInt(page as string),
          limit: parseInt(limit as string),
          total: totalCount[0].count,
          pages: Math.ceil(totalCount[0].count / parseInt(limit as string))
        }
      });

    } catch (error) {
      console.error('Admin users fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch users" });
    }
  });

  // Admin Dashboard - Update User Role
  app.put("/api/admin/users/:userId/role", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { role } = req.body;

      if (!['admin', 'moderator', 'teacher', 'student', 'user', 'freelancer', 'general', 'accountant', 'customer_service'].includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      await db
        .update(profiles)
        .set({ role, updatedAt: new Date() })
        .where(eq(profiles.userId, userUuid));

      res.json({ success: true, message: "User role updated successfully" });

    } catch (error) {
      console.error('Update user role error:', error);
      res.status(500).json({ success: false, error: "Failed to update user role" });
    }
  });

  // Admin Dashboard - Update User Verification Badge
  app.put("/api/admin/users/:userId/verification", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { verificationBadge } = req.body;

      if (!['none', 'green', 'blue'].includes(verificationBadge)) {
        return res.status(400).json({ success: false, error: "Invalid verification badge" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      await db
        .update(profiles)
        .set({ verificationBadge, updatedAt: new Date() })
        .where(eq(profiles.userId, userUuid));

      res.json({ success: true, message: "User verification badge updated successfully" });

    } catch (error) {
      console.error('Update verification badge error:', error);
      res.status(500).json({ success: false, error: "Failed to update verification badge" });
    }
  });

  // Admin Dashboard - Edit User Profile
  app.put("/api/admin/users/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      const { name, email, age, grade, country, role, verificationBadge } = req.body;

      // Validate inputs
      if (!name || !email || !age || !grade || !country || !role) {
        return res.status(400).json({ success: false, error: "All fields are required" });
      }

      if (!['admin', 'moderator', 'teacher', 'student', 'user', 'freelancer', 'general', 'accountant', 'customer_service'].includes(role)) {
        return res.status(400).json({ success: false, error: "Invalid role" });
      }

      if (verificationBadge && !['none', 'green', 'blue'].includes(verificationBadge)) {
        return res.status(400).json({ success: false, error: "Invalid verification badge" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Update profile using UUID
      const profileUpdate: any = { 
        name, 
        age: parseInt(age), 
        grade: parseInt(grade), 
        country, 
        role,
        updatedAt: new Date() 
      };

      if (verificationBadge !== undefined) {
        profileUpdate.verificationBadge = verificationBadge;
      }

      await db
        .update(profiles)
        .set(profileUpdate)
        .where(eq(profiles.userId, userUuid));

      // Update email in users table if changed
      await db
        .update(users)
        .set({ 
          email,
          updatedAt: new Date() 
        })
        .where(eq(users.userId, userId));

      res.json({ success: true, message: "User profile updated successfully" });

    } catch (error) {
      console.error('Update user profile error:', error);
      res.status(500).json({ success: false, error: "Failed to update user profile" });
    }
  });

  // Admin Dashboard - Delete User
  app.delete("/api/admin/users/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      console.log(`Starting delete for userId: ${userId}`);

      // First get the UUID for the user
      console.log('Looking up user UUID...');
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const userUuid = user[0].id;

      // Get the profile ID for this user (needed for message deletions)
      const profileRecord = await db
        .select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, userUuid))
        .limit(1);
      
      const profileId = profileRecord.length > 0 ? profileRecord[0].id : null;

      // Get the shop customer ID for this user (needed for shop-related deletions)
      const shopCustomerRecord = await db
        .select({ id: shopCustomers.id })
        .from(shopCustomers)
        .where(eq(shopCustomers.userId, userUuid))
        .limit(1);
      
      const shopCustomerId = shopCustomerRecord.length > 0 ? shopCustomerRecord[0].id : null;

      // Delete in correct order to avoid foreign key conflicts
      // Some tables reference users.userId (text), others reference users.id (uuid)
      
      console.log(`Deleting user: userId=${userId}, userUuid=${userUuid}, profileId=${profileId}, shopCustomerId=${shopCustomerId}`);
      
      // Delete related data with error handling for each table
      // All deletions run in parallel for performance
      const deletions = [
        // Core user data
        { name: 'userLoginSessions', fn: () => db.delete(userLoginSessions).where(eq(userLoginSessions.userId, userUuid)) },
        { name: 'userNotificationPreferences', fn: () => db.delete(userNotificationPreferences).where(eq(userNotificationPreferences.userId, userUuid)) },
        { name: 'userPrivacySettings', fn: () => db.delete(userPrivacySettings).where(eq(userPrivacySettings.userId, userUuid)) },
        
        // Educational data
        { name: 'courseEnrollments', fn: () => db.delete(courseEnrollments).where(eq(courseEnrollments.userId, userUuid)) },
        { name: 'notifications', fn: () => db.delete(notifications).where(eq(notifications.userId, userUuid)) },
        { name: 'teacherApplications', fn: () => db.delete(teacherApplications).where(eq(teacherApplications.userId, userUuid)) },
        { name: 'tasks', fn: () => db.delete(tasks).where(eq(tasks.userId, userUuid)) },
        { name: 'studyNotes', fn: () => db.delete(studyNotes).where(eq(studyNotes.userId, userUuid)) },
        { name: 'teacherStudentAssignments (as teacher)', fn: () => db.delete(teacherStudentAssignments).where(eq(teacherStudentAssignments.teacherId, userUuid)) },
        { name: 'teacherStudentAssignments (as student)', fn: () => db.delete(teacherStudentAssignments).where(eq(teacherStudentAssignments.studentId, userUuid)) },
        
        // Social features
        { name: 'friendships (as requester)', fn: () => db.delete(friendships).where(eq(friendships.requesterId, userUuid)) },
        { name: 'friendships (as receiver)', fn: () => db.delete(friendships).where(eq(friendships.receiverId, userUuid)) },
        { name: 'workLikes', fn: () => db.delete(workLikes).where(eq(workLikes.userId, userUuid)) },
        { name: 'workComments', fn: () => db.delete(workComments).where(eq(workComments.userId, userUuid)) },
        { name: 'workViews', fn: () => db.delete(workViews).where(eq(workViews.userId, userUuid)) },
        
        // Shop-related data (must be deleted before shopCustomers)
        ...(shopCustomerId ? [
          { name: 'shopPurchases', fn: () => db.delete(shopPurchases).where(eq(shopPurchases.customerId, shopCustomerId)) },
          { name: 'shopAds', fn: () => db.delete(shopAds).where(eq(shopAds.customerId, shopCustomerId)) },
          { name: 'shopMemberships', fn: () => db.delete(shopMemberships).where(eq(shopMemberships.customerId, shopCustomerId)) },
          { name: 'shopTransactions', fn: () => db.delete(shopTransactions).where(eq(shopTransactions.customerId, shopCustomerId)) },
          { name: 'shopSupportTickets', fn: () => db.delete(shopSupportTickets).where(eq(shopSupportTickets.customerId, shopCustomerId)) },
        ] : []),
        
        // Shop/customer data (delete after shop-related tables)
        { name: 'shopCustomers', fn: () => db.delete(shopCustomers).where(eq(shopCustomers.userId, userUuid)) },
        
        // Advertising
        { name: 'adsBanners', fn: () => db.delete(adsBanners).where(eq(adsBanners.userId, userUuid)) },
        { name: 'heroSections', fn: () => db.delete(heroSections).where(eq(heroSections.userId, userUuid)) },
        
        // Messages (must be deleted before profile)
        ...(profileId ? [
          { name: 'messages (as sender)', fn: () => db.delete(messages).where(eq(messages.senderId, profileId)) },
          { name: 'messages (as receiver)', fn: () => db.delete(messages).where(eq(messages.receiverId, profileId)) },
        ] : []),
        
        // Profile (delete last as it may have dependencies)
        { name: 'profiles', fn: () => db.delete(profiles).where(eq(profiles.userId, userUuid)) },
      ];

      // Run all deletions in parallel for better performance
      const results = await Promise.allSettled(
        deletions.map(deletion => 
          deletion.fn().catch(err => {
            console.log(`Error deleting ${deletion.name}:`, err instanceof Error ? err.message : err);
            throw err;
          })
        )
      );

      // Log results
      results.forEach((result, index) => {
        const deletion = deletions[index];
        if (result.status === 'fulfilled') {
          console.log(`âœ“ Deleted ${deletion.name}`);
        } else {
          console.log(`âœ— Failed to delete ${deletion.name}:`, result.reason);
        }
      });
      
      // Delete user last
      console.log('Deleting user...');
      await db.delete(users).where(eq(users.id, userUuid));
      
      console.log('User deletion completed successfully');

      res.json({ success: true, message: "User deleted successfully" });

    } catch (error) {
      console.error('Delete user error:', error);
      res.status(500).json({ success: false, error: "Failed to delete user" });
    }
  });

  // Admin Dashboard - Update User Status (Ban/Unban)
  app.put("/api/admin/users/:userId/status", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { status } = req.body;

      if (!['active', 'banned', 'suspended'].includes(status)) {
        return res.status(400).json({ success: false, error: "Invalid status. Must be active, banned, or suspended" });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      await db
        .update(profiles)
        .set({ status, updatedAt: new Date() })
        .where(eq(profiles.userId, user[0].id));

      const statusMessage = status === 'active' ? 'User unbanned successfully' : 
                           status === 'banned' ? 'User banned successfully' : 
                           'User suspended successfully';

      res.json({ success: true, message: statusMessage });

    } catch (error) {
      console.error('Update user status error:', error);
      res.status(500).json({ success: false, error: "Failed to update user status" });
    }
  });

  // Admin manually update user subscription plan
  app.put("/api/admin/users/:userId/plan", requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { subscriptionTier, planExpiry } = req.body;

      // Validate subscription tier
      const allowedTiers = ['elementary', 'high_school', 'college_university', 'free', null];
      if (subscriptionTier !== null && !allowedTiers.includes(subscriptionTier)) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid subscription tier. Must be elementary, high_school, college_university, free, or null" 
        });
      }

      // First get the UUID for the user
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Prepare update data
      const updateData: any = { 
        updatedAt: new Date() 
      };

      if (subscriptionTier !== undefined) {
        updateData.subscriptionTier = subscriptionTier;
      }

      if (planExpiry !== undefined) {
        updateData.planExpiry = planExpiry ? new Date(planExpiry) : null;
      }

      // Update user profile with new subscription details
      await db
        .update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, user[0].id));

      const tierMessage = subscriptionTier === null || subscriptionTier === 'free' 
        ? 'Plan removed' 
        : `Plan set to ${subscriptionTier}`;

      res.json({ 
        success: true, 
        message: `${tierMessage}${planExpiry ? ` with expiry ${new Date(planExpiry).toLocaleDateString()}` : ''}` 
      });

    } catch (error) {
      console.error('Update user plan error:', error);
      res.status(500).json({ success: false, error: "Failed to update user plan" });
    }
  });

  // Admin manually add funds to user wallet
  app.post("/api/admin/users/:userId/add-funds", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { userId } = req.params;
      const { amount, reason } = req.body;

      // Validate amount
      if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Invalid amount. Must be a positive number." 
        });
      }

      // Get user UUID from userId
      const user = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, userId))
        .limit(1);

      if (user.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Get or create shop customer record
      let customer = await storage.getShopCustomerByUserId(user[0].id);
      
      if (!customer) {
        // Get user profile for basic info
        const profile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, user[0].id))
          .limit(1);

        if (profile.length === 0) {
          return res.status(404).json({ success: false, error: "User profile not found" });
        }

        // Get user email
        const userRecord = await db
          .select({ email: users.email })
          .from(users)
          .where(eq(users.id, user[0].id))
          .limit(1);

        // Create shop customer record if it doesn't exist
        customer = await storage.createShopCustomer({
          userId: user[0].id,
          fullName: profile[0].name,
          email: userRecord[0]?.email || '',
        });
      }

      // Add funds to wallet
      const updatedCustomer = await storage.updateWalletBalance(customer.id, parseFloat(amount));

      // Record the transaction
      await db.insert(shopTransactions).values({
        customerId: customer.id,
        amount: amount.toString(),
        type: 'add_funds',
        description: reason || `Manual fund addition by admin (Cash payment)`,
        status: 'completed',
        referenceId: `admin-manual-${Date.now()}`
      });

      res.json({ 
        success: true, 
        message: `Successfully added $${amount} to user's wallet`,
        newBalance: updatedCustomer.walletBalance
      });

    } catch (error) {
      console.error('Admin add funds error:', error);
      res.status(500).json({ success: false, error: "Failed to add funds to user wallet" });
    }
  });

  // Admin impersonate user
  app.post("/api/admin/impersonate", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { targetUserId } = req.body;
      const adminUser = req.user;

      if (!targetUserId) {
        return res.status(400).json({ success: false, error: "Target user ID is required" });
      }

      // Get the target user and profile
      const targetUser = await db
        .select()
        .from(users)
        .where(eq(users.userId, targetUserId))
        .limit(1);

      if (targetUser.length === 0) {
        return res.status(404).json({ success: false, error: "Target user not found" });
      }

      // Get user's profile to determine role
      const userProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, targetUser[0].id))
        .limit(1);

      // Create a new session for the target user
      const newSessionId = uuidv4();
      const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

      await db.insert(userLoginSessions).values({
        id: uuidv4(),
        userId: targetUser[0].id,
        sessionId: newSessionId,
        ipAddress: req.ip || req.headers['x-forwarded-for'] as string || 'unknown',
        userAgent: req.headers['user-agent'] || 'unknown',
        expiresAt,
        createdAt: new Date()
      });

      res.json({ 
        success: true, 
        sessionId: newSessionId,
        user: {
          id: targetUser[0].id,
          userId: targetUser[0].userId,
          email: targetUser[0].email
        },
        profile: userProfile[0],
        role: userProfile[0]?.role || 'student',
        message: `Successfully logged in as ${targetUserId}`
      });

    } catch (error) {
      console.error('Admin impersonate error:', error);
      res.status(500).json({ success: false, error: "Failed to impersonate user" });
    }
  });

  // Advertise page button configuration endpoint
  app.get("/api/admin/system-settings/advertise-buttons", async (req, res) => {
    try {
      const buttonSettings = await db
        .select()
        .from(systemSettings)
        .where(
          or(
            eq(systemSettings.key, 'advertise_contact_button_enabled'),
            eq(systemSettings.key, 'advertise_create_banner_button_enabled')
          )
        );

      const settings = buttonSettings.reduce((acc, setting) => {
        if (setting.key === 'advertise_contact_button_enabled') {
          acc.contactDesignTeamEnabled = setting.value === 'true';
        } else if (setting.key === 'advertise_create_banner_button_enabled') {
          acc.createBannerEnabled = setting.value === 'true';
        }
        return acc;
      }, {} as any);

      // Default to enabled if no settings exist
      if (Object.keys(settings).length === 0) {
        settings.contactDesignTeamEnabled = true;
        settings.createBannerEnabled = true;
      }

      res.json(settings);
    } catch (error) {
      console.error('Advertise button settings error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch advertise button settings" });
    }
  });

  app.put("/api/admin/system-settings/advertise-buttons", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { contactDesignTeamEnabled, createBannerEnabled } = req.body;

      // Update or insert contact button setting
      const contactSetting = await db
        .select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'advertise_contact_button_enabled'))
        .limit(1);

      if (contactSetting.length > 0) {
        await db
          .update(systemSettings)
          .set({ value: String(contactDesignTeamEnabled), updatedAt: new Date() })
          .where(eq(systemSettings.key, 'advertise_contact_button_enabled'));
      } else {
        await db.insert(systemSettings).values({
          key: 'advertise_contact_button_enabled',
          value: String(contactDesignTeamEnabled),
          type: 'boolean',
          description: 'Enable/disable Contact Design Team button on advertise page',
          category: 'advertise_page'
        });
      }

      // Update or insert create banner button setting
      const bannerSetting = await db
        .select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'advertise_create_banner_button_enabled'))
        .limit(1);

      if (bannerSetting.length > 0) {
        await db
          .update(systemSettings)
          .set({ value: String(createBannerEnabled), updatedAt: new Date() })
          .where(eq(systemSettings.key, 'advertise_create_banner_button_enabled'));
      } else {
        await db.insert(systemSettings).values({
          key: 'advertise_create_banner_button_enabled',
          value: String(createBannerEnabled),
          type: 'boolean',
          description: 'Enable/disable Create Banner Now button on advertise page',
          category: 'advertise_page'
        });
      }

      res.json({ success: true, message: "Advertise button settings updated successfully" });
    } catch (error) {
      console.error('Update advertise button settings error:', error);
      res.status(500).json({ success: false, error: "Failed to update advertise button settings" });
    }
  });

  // Get custom logo URL by type and size
  app.get("/api/admin/settings/logo/:type?/:size?", async (req, res) => {
    try {
      const { type = 'home', size = 'square' } = req.params;
      const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
      const validSizes = ['square', 'wide'];
      
      if (!validTypes.includes(type)) {
        return res.status(400).json({ success: false, error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
      }
      
      if (!validSizes.includes(size)) {
        return res.status(400).json({ success: false, error: 'Invalid logo size. Must be: square or wide' });
      }
      
      const logoKey = `${type}_logo_${size}_url`;
      const logoSetting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, logoKey))
        .limit(1);
      
      res.json({ success: true, logoUrl: logoSetting[0]?.value || null, type, size });
    } catch (error) {
      console.error('Error fetching logo setting:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch logo setting' });
    }
  });

  // Get all logo URLs (both square and wide)
  app.get("/api/admin/settings/logos", async (req, res) => {
    try {
      const logoSettings = await db.select()
        .from(systemSettings)
        .where(or(
          eq(systemSettings.key, 'home_logo_square_url'),
          eq(systemSettings.key, 'home_logo_wide_url'),
          eq(systemSettings.key, 'student_logo_square_url'),
          eq(systemSettings.key, 'student_logo_wide_url'),
          eq(systemSettings.key, 'teacher_logo_square_url'),
          eq(systemSettings.key, 'teacher_logo_wide_url'),
          eq(systemSettings.key, 'freelancer_logo_square_url'),
          eq(systemSettings.key, 'freelancer_logo_wide_url'),
          eq(systemSettings.key, 'customer_logo_square_url'),
          eq(systemSettings.key, 'customer_logo_wide_url'),
          eq(systemSettings.key, 'footer_logo_square_url'),
          eq(systemSettings.key, 'footer_logo_wide_url'),
          eq(systemSettings.key, 'auth_logo_square_url'),
          eq(systemSettings.key, 'auth_logo_wide_url')
        ));
      
      const logos = {
        home: { square: null, wide: null },
        student: { square: null, wide: null },
        teacher: { square: null, wide: null },
        freelancer: { square: null, wide: null },
        customer: { square: null, wide: null },
        footer: { square: null, wide: null },
        auth: { square: null, wide: null }
      };
      
      logoSettings.forEach(setting => {
        const match = setting.key.match(/^(\w+)_logo_(square|wide)_url$/);
        if (match) {
          const [, type, size] = match;
          if (logos[type as keyof typeof logos]) {
            logos[type as keyof typeof logos][size as 'square' | 'wide'] = setting.value;
          }
        }
      });
      
      res.json({ success: true, logos });
    } catch (error) {
      console.error('Error fetching logo settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch logo settings' });
    }
  });

  // Clean dedicated logo upload endpoint with size support
  app.post("/api/admin/settings/logo/:type/:size", requireAuth, requireAdmin, (req, res) => {
    console.log('ðŸŽ¯ Clean logo upload endpoint hit:', req.url);
    console.log('ðŸŽ¯ Content-Type:', req.get('content-type'));
    
    const { type, size } = req.params;
    const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
    const validSizes = ['square', 'wide'];
    
    if (!validTypes.includes(type)) {
      return res.status(400).json({ error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
    }
    
    if (!validSizes.includes(size)) {
      return res.status(400).json({ error: 'Invalid logo size. Must be: square or wide' });
    }
    
    // Create multer instance for this specific request
    const upload = multer({
      storage: multer.memoryStorage(),
      limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
      fileFilter: (req, file, cb) => {
        const allowedTypes = ["image/jpeg", "image/png", "image/webp", "image/gif"];
        if (allowedTypes.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(new Error("Only JPEG, PNG, WebP, and GIF files are allowed"));
        }
      }
    }).single('logo');
    
    upload(req, res, async (err) => {
      if (err) {
        console.log('âŒ Upload error:', err.message);
        return res.status(400).json({ error: err.message });
      }
      
      console.log('ðŸŽ¯ File received:', {
        hasFile: !!req.file,
        filename: req.file?.originalname,
        size: req.file?.size,
        mimetype: req.file?.mimetype
      });
      
      if (!req.file) {
        return res.status(400).json({ error: 'No logo file provided' });
      }

      try {
        console.log('ðŸ”„ Starting Cloudinary upload...');
        const result = await cloudinaryStorage.uploadFile(
          req.file.buffer,
          req.file.originalname,
          req.file.mimetype,
          `logos/${type}/${size}`
        );
        
        console.log('ðŸ“¤ Upload result:', { success: result.success, hasUrl: !!result.url });

        if (!result.success || !result.url) {
          return res.status(500).json({ 
            success: false, 
            error: result.error || 'Upload failed'
          });
        }

        // Save to database
        const logoKey = `${type}_logo_${size}_url`;
        const existingLogo = await db.select()
          .from(systemSettings)
          .where(eq(systemSettings.key, logoKey))
          .limit(1);

        if (existingLogo.length > 0) {
          await db.update(systemSettings)
            .set({ value: result.url, updatedAt: new Date() })
            .where(eq(systemSettings.key, logoKey));
        } else {
          await db.insert(systemSettings).values({
            key: logoKey,
            value: result.url,
            type: 'string',
            description: `${type} ${size} logo URL`,
            category: 'branding',
            isPublic: true
          });
        }

        console.log('âœ… Logo upload successful');
        res.json({ 
          success: true, 
          logoUrl: result.url, 
          type,
          size,
          message: `${type.charAt(0).toUpperCase() + type.slice(1)} ${size} logo uploaded successfully` 
        });
        
      } catch (error) {
        console.error('âŒ Upload error:', error);
        res.status(500).json({ success: false, error: 'Upload failed' });
      }
    });
  });

  // Reset to default logo by type and size
  app.delete("/api/admin/settings/logo/:type/:size", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { type, size } = req.params;
      const validTypes = ['home', 'student', 'teacher', 'freelancer', 'customer', 'footer', 'auth'];
      const validSizes = ['square', 'wide'];
      
      if (!validTypes.includes(type)) {
        return res.status(400).json({ error: 'Invalid logo type. Must be: home, student, teacher, freelancer, customer, footer, or auth' });
      }
      
      if (!validSizes.includes(size)) {
        return res.status(400).json({ error: 'Invalid logo size. Must be: square or wide' });
      }
      
      const logoKey = `${type}_logo_${size}_url`;
      await db.delete(systemSettings)
        .where(eq(systemSettings.key, logoKey));
      
      res.json({ success: true, type, size, message: `${type.charAt(0).toUpperCase() + type.slice(1)} ${size} logo reset to default successfully` });
    } catch (error) {
      console.error('Error resetting logo:', error);
      res.status(500).json({ success: false, error: 'Failed to reset logo' });
    }
  });

  // GET /api/admin/settings/freelancer-default-cover - Get default freelancer cover (admin)
  app.get("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, async (req, res) => {
    try {
      const setting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (setting.length === 0 || !setting[0].value) {
        return res.json({ success: true, url: null });
      }

      res.json({ success: true, url: setting[0].value });
    } catch (error) {
      console.error('Error fetching default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch default cover' });
    }
  });

  // POST /api/admin/settings/freelancer-default-cover - Upload default freelancer cover (admin)
  app.post("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, upload.single('cover'), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ success: false, error: 'No file uploaded' });
      }

      // Upload to Cloudinary
      const result = await cloudinaryStorage.uploadFile(
        req.file.buffer,
        req.file.originalname,
        req.file.mimetype,
        'general/default-covers'
      );

      const coverUrl = result.url;

      // Save to system settings
      const existingSetting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (existingSetting.length > 0) {
        await db.update(systemSettings)
          .set({ value: coverUrl, updatedAt: new Date() })
          .where(eq(systemSettings.key, 'freelancer_default_cover'));
      } else {
        await db.insert(systemSettings).values({
          key: 'freelancer_default_cover',
          value: coverUrl,
        });
      }

      res.json({ success: true, url: coverUrl });
    } catch (error) {
      console.error('Error uploading default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to upload default cover' });
    }
  });

  // DELETE /api/admin/settings/freelancer-default-cover - Delete default freelancer cover (admin)
  app.delete("/api/admin/settings/freelancer-default-cover", requireAuth, requireAdmin, async (req, res) => {
    try {
      await db.update(systemSettings)
        .set({ value: null, updatedAt: new Date() })
        .where(eq(systemSettings.key, 'freelancer_default_cover'));

      res.json({ success: true, message: 'Default cover removed successfully' });
    } catch (error) {
      console.error('Error deleting default freelancer cover:', error);
      res.status(500).json({ success: false, error: 'Failed to delete default cover' });
    }
  });

  // GET /api/system-settings/freelancer-default-cover - Get default freelancer cover (public)
  app.get("/api/system-settings/freelancer-default-cover", async (req, res) => {
    try {
      const setting = await db.select()
        .from(systemSettings)
        .where(eq(systemSettings.key, 'freelancer_default_cover'))
        .limit(1);

      if (setting.length === 0 || !setting[0].value) {
        return res.json({ url: null });
      }

      res.json({ url: setting[0].value });
    } catch (error) {
      console.error('Error fetching default freelancer cover:', error);
      res.status(500).json({ error: 'Failed to fetch default cover' });
    }
  });

  // ================================
  // Admin Settings & API Keys Routes
  // ================================
  
  // Get all admin settings (optionally filtered by category)
  app.get("/api/admin/settings", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { category } = req.query;
      const settings = await storage.getAdminSettings(category as string);
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error('Error fetching admin settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch admin settings' });
    }
  });

  // Get a specific admin setting by key
  app.get("/api/admin/settings/:key", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { key } = req.params;
      const setting = await storage.getAdminSetting(key);
      
      if (!setting) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }
      
      res.json({ success: true, data: setting });
    } catch (error) {
      console.error('Error fetching admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch admin setting' });
    }
  });

  // Create or update an admin setting
  app.put("/api/admin/settings/:key", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { key } = req.params;
      const { value, category, description, isEncrypted, isActive } = req.body;
      const adminUserId = req.user!.userId;

      // Check if setting exists
      const existing = await storage.getAdminSetting(key);
      
      if (existing) {
        // Update existing
        const updated = await storage.updateAdminSetting(key, value, adminUserId);
        // Clear cache for this setting
        clearSettingsCache(key);
        res.json({ success: true, data: updated, message: 'Setting updated successfully' });
      } else {
        // Create new
        const newSetting = await storage.createAdminSetting({
          settingKey: key,
          settingValue: value,
          category: category || 'api',
          description,
          isEncrypted: isEncrypted || false,
          isActive: isActive !== undefined ? isActive : true,
          updatedBy: adminUserId
        });
        // Clear cache for this setting
        clearSettingsCache(key);
        res.json({ success: true, data: newSetting, message: 'Setting created successfully' });
      }
    } catch (error) {
      console.error('Error creating/updating admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to save admin setting' });
    }
  });

  // Delete an admin setting
  app.delete("/api/admin/settings/:key", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { key } = req.params;
      const deleted = await storage.deleteAdminSetting(key);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }
      
      // Clear cache for this setting
      clearSettingsCache(key);
      res.json({ success: true, message: 'Setting deleted successfully' });
    } catch (error) {
      console.error('Error deleting admin setting:', error);
      res.status(500).json({ success: false, error: 'Failed to delete admin setting' });
    }
  });

  // ================================
  // =================================
  // Theme Settings Routes
  // =================================

  // Get theme settings (public - no auth required)
  app.get("/api/theme-settings", async (req, res) => {
    try {
      const themeSettings = await storage.getAdminSettings('theme');
      
      const themeData: Record<string, string> = {};
      themeSettings.forEach(setting => {
        themeData[setting.settingKey] = setting.settingValue || '';
      });
      
      res.json({ success: true, data: themeData });
    } catch (error) {
      console.error('Error fetching theme settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch theme settings' });
    }
  });

  // Update theme settings (admin only)
  app.post("/api/admin/theme-settings", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { primaryColor, secondaryColor, accentColor, primaryFont, headingFont } = req.body;
      const adminUserId = req.user!.userId;

      const themeSettings = [
        { key: 'theme_primary_color', value: primaryColor },
        { key: 'theme_secondary_color', value: secondaryColor },
        { key: 'theme_accent_color', value: accentColor },
        { key: 'theme_primary_font', value: primaryFont },
        { key: 'theme_heading_font', value: headingFont }
      ];

      for (const { key, value } of themeSettings) {
        if (value) {
          const existing = await storage.getAdminSetting(key);
          if (existing) {
            await storage.updateAdminSetting(key, value, adminUserId);
          } else {
            await storage.createAdminSetting({
              settingKey: key,
              settingValue: value,
              category: 'theme',
              description: `Theme setting for ${key.replace('theme_', '').replace(/_/g, ' ')}`,
              isEncrypted: false,
              isActive: true,
              updatedBy: adminUserId
            });
          }
          clearSettingsCache(key);
        }
      }

      res.json({ success: true, message: 'Theme settings updated successfully' });
    } catch (error) {
      console.error('Error updating theme settings:', error);
      res.status(500).json({ success: false, error: 'Failed to update theme settings' });
    }
  });

  // Reset theme to defaults (admin only)
  app.post("/api/admin/theme-settings/reset", requireAuth, requireAdmin, async (req, res) => {
    try {
      const themeKeys = [
        'theme_primary_color',
        'theme_secondary_color',
        'theme_accent_color',
        'theme_primary_font',
        'theme_heading_font'
      ];

      for (const key of themeKeys) {
        await storage.deleteAdminSetting(key);
        clearSettingsCache(key);
      }

      res.json({ success: true, message: 'Theme reset to defaults successfully' });
    } catch (error) {
      console.error('Error resetting theme:', error);
      res.status(500).json({ success: false, error: 'Failed to reset theme' });
    }
  });

  // =================================
  // Payment Gateway Configuration Routes
  // ================================
  
  // Public endpoint to get enabled payment gateways (without sensitive data)
  app.get("/api/payment-gateways/enabled", async (req, res) => {
    try {
      const gateways = await storage.getPaymentGateways(true); // Get only enabled
      
      // Return only non-sensitive information
      const publicGateways = gateways.map(gateway => ({
        gatewayId: gateway.gatewayId,
        gatewayName: gateway.gatewayName,
        isPrimary: gateway.isPrimary,
        supportedCurrencies: gateway.supportedCurrencies,
        features: gateway.features,
        testMode: gateway.testMode
      }));
      
      res.json({ success: true, data: publicGateways });
    } catch (error) {
      console.error('Error fetching enabled payment gateways:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateways' });
    }
  });
  
  // Get all payment gateways
  app.get("/api/admin/payment-gateways", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { enabled } = req.query;
      const gateways = await storage.getPaymentGateways(enabled === 'true');
      res.json({ success: true, data: gateways });
    } catch (error) {
      console.error('Error fetching payment gateways:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateways' });
    }
  });

  // Get a specific payment gateway
  app.get("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const gateway = await storage.getPaymentGateway(gatewayId);
      
      if (!gateway) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      res.json({ success: true, data: gateway });
    } catch (error) {
      console.error('Error fetching payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch payment gateway' });
    }
  });

  // Create or update a payment gateway
  app.put("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { gatewayId } = req.params;
      const {
        gatewayName,
        publishableKey,
        secretKey,
        webhookSecret,
        isEnabled,
        isPrimary,
        testMode,
        supportedCurrencies,
        features,
        additionalConfig
      } = req.body;
      const adminUserId = req.user!.userId;

      // Check if gateway exists
      const existing = await storage.getPaymentGateway(gatewayId);
      
      if (existing) {
        // Update existing
        const updated = await storage.updatePaymentGateway(gatewayId, {
          gatewayName,
          publishableKey,
          secretKey,
          webhookSecret,
          isEnabled,
          isPrimary,
          testMode,
          supportedCurrencies,
          features,
          additionalConfig
        }, adminUserId);
        
        // Invalidate payment gateway cache
        invalidatePaymentGatewayCache();
        
        res.json({ success: true, data: updated, message: 'Payment gateway updated successfully' });
      } else {
        // Create new
        const newGateway = await storage.createPaymentGateway({
          gatewayId,
          gatewayName,
          publishableKey,
          secretKey,
          webhookSecret,
          isEnabled: isEnabled !== undefined ? isEnabled : false,
          isPrimary: isPrimary !== undefined ? isPrimary : false,
          testMode: testMode !== undefined ? testMode : true,
          supportedCurrencies,
          features,
          additionalConfig,
          updatedBy: adminUserId
        });
        
        // Invalidate payment gateway cache
        invalidatePaymentGatewayCache();
        
        res.json({ success: true, data: newGateway, message: 'Payment gateway created successfully' });
      }
    } catch (error) {
      console.error('Error creating/updating payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to save payment gateway' });
    }
  });

  // Set a payment gateway as primary
  app.post("/api/admin/payment-gateways/:gatewayId/set-primary", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const updated = await storage.setPrimaryPaymentGateway(gatewayId);
      
      if (!updated) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      // Invalidate payment gateway cache
      invalidatePaymentGatewayCache();
      
      res.json({ success: true, data: updated, message: 'Primary payment gateway updated successfully' });
    } catch (error) {
      console.error('Error setting primary payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to set primary payment gateway' });
    }
  });

  // Delete a payment gateway
  app.delete("/api/admin/payment-gateways/:gatewayId", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { gatewayId } = req.params;
      const deleted = await storage.deletePaymentGateway(gatewayId);
      
      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Payment gateway not found' });
      }
      
      // Invalidate payment gateway cache
      invalidatePaymentGatewayCache();
      
      res.json({ success: true, message: 'Payment gateway deleted successfully' });
    } catch (error) {
      console.error('Error deleting payment gateway:', error);
      res.status(500).json({ success: false, error: 'Failed to delete payment gateway' });
    }
  });

  // Get Stripe publishable key (public endpoint for frontend)
  app.get("/api/payment/stripe/publishable-key", async (req, res) => {
    try {
      const publishableKey = await getStripePublishableKey();
      
      if (!publishableKey) {
        return res.status(404).json({ 
          success: false, 
          error: 'Stripe is not configured. Please configure it in admin settings.' 
        });
      }
      
      res.json({ success: true, publishableKey });
    } catch (error) {
      console.error('Error fetching Stripe publishable key:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch Stripe publishable key' });
    }
  });

  // Admin Dashboard - Delete All Users
  app.delete("/api/admin/users/all", async (req, res) => {
    try {
      console.log('ðŸ—‘ï¸ Starting deletion of all users...');
      
      // Delete all user-related data in the correct order to avoid foreign key conflicts
      
      // 1. Delete user login sessions
      await db.delete(userLoginSessions);
      console.log('âœ… Deleted user login sessions');
      
      // 2. Delete user notification preferences
      await db.delete(userNotificationPreferences);
      console.log('âœ… Deleted user notification preferences');
      
      // 3. Delete user privacy settings
      await db.delete(userPrivacySettings);
      console.log('âœ… Deleted user privacy settings');
      
      // 4. Delete user other settings
      await db.delete(userOtherSettings);
      console.log('âœ… Deleted user other settings');
      
      // 5. Delete student progress
      await db.delete(studentProgress);
      console.log('âœ… Deleted student progress');
      
      // 6. Delete course enrollments
      await db.delete(courseEnrollments);
      console.log('âœ… Deleted course enrollments');
      
      // 7. Delete payment methods
      await db.delete(paymentMethods);
      console.log('âœ… Deleted payment methods');
      
      // 8. Delete notifications
      await db.delete(notifications);
      console.log('âœ… Deleted notifications');
      
      // 9. Delete teacher applications
      await db.delete(teacherApplications);
      console.log('âœ… Deleted teacher applications');
      
      // 10. Delete password reset tokens
      await db.delete(passwordResetTokens);
      console.log('âœ… Deleted password reset tokens');
      
      // 11. Delete verification codes
      await db.delete(verificationCodes);
      console.log('âœ… Deleted verification codes');
      
      // 12. Delete user profiles
      await db.delete(profiles);
      console.log('âœ… Deleted user profiles');
      
      // 13. Finally, delete users
      const deletedUsers = await db.delete(users);
      console.log('âœ… Deleted all users');
      
      // Clear any in-memory storage
      const paymentMethodsStorage = new Map();
      const profileStorage = new Map();
      paymentMethodsStorage.clear();
      profileStorage.clear();
      
      console.log('ðŸŽ‰ All users and related data deleted successfully');
      
      res.json({ 
        success: true, 
        message: "All users and related data deleted successfully" 
      });

    } catch (error) {
      console.error('âŒ Error deleting all users:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete all users" 
      });
    }
  });

  // ==================== PRICING PLANS MANAGEMENT API ====================
  
  // GET /api/admin/pricing-plans - Get all pricing plans
  app.get("/api/admin/pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(pricingPlans)
        .orderBy(asc(pricingPlans.sortOrder), asc(pricingPlans.createdAt));

      res.json({
        success: true,
        data: plans
      });
    } catch (error) {
      console.error('Error fetching pricing plans:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pricing plans'
      });
    }
  });

  // POST /api/admin/pricing-plans - Create new pricing plan
  app.post("/api/admin/pricing-plans", requireAuth, requireAdmin, async (req, res) => {
    try {
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.priceMonthly !== undefined && typeof bodyData.priceMonthly === 'number') {
        bodyData.priceMonthly = bodyData.priceMonthly.toString();
      }
      if (bodyData.priceYearly !== undefined && typeof bodyData.priceYearly === 'number') {
        bodyData.priceYearly = bodyData.priceYearly.toString();
      }
      
      const validatedData = insertPricingPlanSchema.parse(bodyData);
      
      const [newPlan] = await db
        .insert(pricingPlans)
        .values(validatedData)
        .returning();

      res.json({
        success: true,
        data: newPlan,
        message: 'Pricing plan created successfully'
      });
    } catch (error) {
      console.error('Error creating pricing plan:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          error: 'Invalid input data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to create pricing plan'
      });
    }
  });

  // PUT /api/admin/pricing-plans/:id - Update existing pricing plan
  app.put("/api/admin/pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      // Transform numeric prices to strings if needed
      const bodyData = { ...req.body };
      if (bodyData.priceMonthly !== undefined && typeof bodyData.priceMonthly === 'number') {
        bodyData.priceMonthly = bodyData.priceMonthly.toString();
      }
      if (bodyData.priceYearly !== undefined && typeof bodyData.priceYearly === 'number') {
        bodyData.priceYearly = bodyData.priceYearly.toString();
      }
      
      const validatedData = insertPricingPlanSchema.partial().parse(bodyData);
      
      // Remove undefined values
      const updateData = Object.fromEntries(
        Object.entries(validatedData).filter(([_, value]) => value !== undefined)
      );
      
      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No valid fields to update'
        });
      }

      updateData.updatedAt = new Date();

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set(updateData)
        .where(eq(pricingPlans.id, id))
        .returning();

      if (!updatedPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      res.json({
        success: true,
        data: updatedPlan,
        message: 'Pricing plan updated successfully'
      });
    } catch (error) {
      console.error('Error updating pricing plan:', error);
      if (error.name === 'ZodError') {
        return res.status(400).json({
          success: false,
          error: 'Invalid input data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to update pricing plan'
      });
    }
  });

  // DELETE /api/admin/pricing-plans/:id - Delete pricing plan
  app.delete("/api/admin/pricing-plans/:id", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Check if plan is being used by any active subscriptions
      const activeSubscriptions = await db
        .select({ count: count() })
        .from(userSubscriptions)
        .where(and(
          eq(userSubscriptions.planId, id),
          eq(userSubscriptions.status, 'active')
        ));

      if (activeSubscriptions[0].count > 0) {
        return res.status(400).json({
          success: false,
          error: 'Cannot delete pricing plan with active subscriptions. Please deactivate it instead.'
        });
      }

      const [deletedPlan] = await db
        .delete(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .returning();

      if (!deletedPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      res.json({
        success: true,
        message: 'Pricing plan deleted successfully'
      });
    } catch (error) {
      console.error('Error deleting pricing plan:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete pricing plan'
      });
    }
  });

  // PATCH /api/admin/pricing-plans/:id/toggle - Toggle active status
  app.patch("/api/admin/pricing-plans/:id/toggle", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Get current plan
      const [currentPlan] = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .limit(1);

      if (!currentPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set({ 
          isActive: !currentPlan.isActive,
          updatedAt: new Date()
        })
        .where(eq(pricingPlans.id, id))
        .returning();

      res.json({
        success: true,
        data: updatedPlan,
        message: `Pricing plan ${updatedPlan.isActive ? 'activated' : 'deactivated'} successfully`
      });
    } catch (error) {
      console.error('Error toggling pricing plan status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle pricing plan status'
      });
    }
  });

  // PATCH /api/admin/pricing-plans/:id/popular - Toggle popular status
  app.patch("/api/admin/pricing-plans/:id/popular", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;

      // Get current plan
      const [currentPlan] = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.id, id))
        .limit(1);

      if (!currentPlan) {
        return res.status(404).json({
          success: false,
          error: 'Pricing plan not found'
        });
      }

      const [updatedPlan] = await db
        .update(pricingPlans)
        .set({ 
          isPopular: !currentPlan.isPopular,
          updatedAt: new Date()
        })
        .where(eq(pricingPlans.id, id))
        .returning();

      res.json({
        success: true,
        data: updatedPlan,
        message: `Pricing plan marked as ${updatedPlan.isPopular ? 'popular' : 'not popular'} successfully`
      });
    } catch (error) {
      console.error('Error toggling pricing plan popular status:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle pricing plan popular status'
      });
    }
  });

  // GET /api/pricing-plans - Get active pricing plans (public endpoint)
  app.get("/api/pricing-plans", async (req, res) => {
    try {
      const plans = await db
        .select()
        .from(pricingPlans)
        .where(eq(pricingPlans.isActive, true))
        .orderBy(asc(pricingPlans.sortOrder), asc(pricingPlans.createdAt));

      res.json({
        success: true,
        data: plans
      });
    } catch (error) {
      console.error('Error fetching active pricing plans:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch pricing plans'
      });
    }
  });

  // Teacher Verification System
  
  // Submit Teacher Application
  app.post("/api/teacher/apply", async (req, res) => {
    try {
      const {
        fullName,
        email,
        phoneNumber,
        qualifications,
        experience,
        portfolioLinks,
        certifications,
        country,
        city,
        availableHours,
        hourlyRate,
        bio
      } = req.body;

      // Validation
      if (!fullName || !email || !qualifications || !experience || !country) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields: Full Name, Email, Qualifications, Experience, and Country are required" 
        });
      }

      if (!isValidEmail(email)) {
        return res.status(400).json({ success: false, error: "Invalid email format" });
      }

      // Check if application already exists for this email
      const existingApplication = await db
        .select()
        .from(teacherApplications)
        .where(eq(teacherApplications.email, email))
        .limit(1);

      if (existingApplication.length > 0) {
        return res.status(400).json({ 
          success: false, 
          error: "Application already submitted for this email address" 
        });
      }

      // Generate verification code
      const verificationCode = Math.random().toString(36).substring(2, 8).toUpperCase();

      // Insert teacher application
      const [newApplication] = await db
        .insert(teacherApplications)
        .values({
          fullName,
          email,
          phoneNumber: phoneNumber || null,
          qualifications,
          experience,
          portfolioLinks: portfolioLinks ? JSON.parse(JSON.stringify(portfolioLinks)) : null,
          certifications: certifications ? JSON.parse(JSON.stringify(certifications)) : null,
          country,
          city: city || null,
          availableHours: availableHours || null,
          hourlyRate: hourlyRate ? hourlyRate.toString() : null,
          bio: bio || null,
          verificationCode,
          status: 'pending'
        })
        .returning();

      // Send verification email
      const emailResult = await sendEmail(
        email,
        'Verify Your EduFiliova Teacher Application',
        getEmailTemplate('teacher-verification', { 
          code: verificationCode,
          fullName 
        })
      );

      res.json({ 
        success: true, 
        message: "Teacher application submitted successfully. Please check your email for verification code.",
        applicationId: newApplication.id
      });

    } catch (error) {
      console.error('Teacher application error:', error);
      res.status(500).json({ success: false, error: "Failed to submit teacher application" });
    }
  });

  // Verify Teacher Application
  app.post("/api/teacher/verify", async (req, res) => {
    try {
      const { email, code } = req.body;

      if (!email || !code) {
        return res.status(400).json({ success: false, error: "Email and verification code are required" });
      }

      // Find application with matching email and code
      const application = await db
        .select()
        .from(teacherApplications)
        .where(and(
          eq(teacherApplications.email, email),
          eq(teacherApplications.verificationCode, code),
          eq(teacherApplications.status, 'pending')
        ))
        .limit(1);

      if (application.length === 0) {
        return res.status(400).json({ success: false, error: "Invalid verification code or application not found" });
      }

      // Update application status to verified
      await db
        .update(teacherApplications)
        .set({ 
          status: 'verified',
          verifiedAt: new Date()
        })
        .where(eq(teacherApplications.id, application[0].id));

      res.json({ 
        success: true, 
        message: "Teacher application verified successfully. Your application is now under review."
      });

    } catch (error) {
      console.error('Teacher verification error:', error);
      res.status(500).json({ success: false, error: "Failed to verify teacher application" });
    }
  });

  // Create Verified Teacher Login
  app.post("/api/teacher/login", async (req, res) => {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        return res.status(400).json({ success: false, error: "Email and password are required" });
      }

      // Find verified teacher application
      const teacherApp = await db
        .select()
        .from(teacherApplications)
        .where(and(
          eq(teacherApplications.email, email),
          or(
            eq(teacherApplications.status, 'verified'),
            eq(teacherApplications.status, 'approved')
          )
        ))
        .limit(1);

      if (teacherApp.length === 0) {
        return res.status(401).json({ 
          success: false, 
          error: "No verified teacher account found for this email. Please apply as a teacher first." 
        });
      }

      // Find user account
      const user = await db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);

      let userId;
      let profile;

      if (user.length === 0) {
        // Create new user account for verified teacher
        const hashedPassword = await bcrypt.hash(password, 10);
        const newUserId = `T${Date.now().toString().slice(-7)}${Math.random().toString(36).substring(2, 4).toUpperCase()}`;

        const [newUser] = await db
          .insert(users)
          .values({
            userId: newUserId,
            email,
            passwordHash: hashedPassword
          })
          .returning();

        // Create teacher profile
        const [newProfile] = await db
          .insert(profiles)
          .values({
            userId: newUser.id,
            name: teacherApp[0].fullName,
            age: 25, // Default age for teachers
            grade: 12, // Default grade for teachers
            educationLevel: 'university',
            country: teacherApp[0].country,
            role: 'teacher'
          })
          .returning();

        // Link teacher application to user
        await db
          .update(teacherApplications)
          .set({ userId: newUser.id })
          .where(eq(teacherApplications.id, teacherApp[0].id));

        userId = newUser.id;
        profile = newProfile;
      } else {
        // Verify existing password
        const isValidPassword = await bcrypt.compare(password, user[0].passwordHash);
        if (!isValidPassword) {
          return res.status(401).json({ success: false, error: "Invalid password" });
        }

        // Get profile
        const existingProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, user[0].id))
          .limit(1);

        if (existingProfile.length === 0 || existingProfile[0].role !== 'teacher') {
          return res.status(401).json({ success: false, error: "Account is not verified as a teacher" });
        }

        userId = user[0].id;
        profile = existingProfile[0];
      }

      // Create session
      const sessionId = uuidv4();
      await db.insert(userLoginSessions).values({
        userId,
        sessionId,
        userAgent: req.headers['user-agent'] || 'Unknown',
        ipAddress: req.ip || 'Unknown',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      });

      res.json({
        success: true,
        message: "Teacher login successful",
        user: {
          id: userId,
          email,
          role: 'teacher'
        },
        profile,
        sessionId,
        teacherApplication: teacherApp[0]
      });

    } catch (error) {
      console.error('Teacher login error:', error);
      res.status(500).json({ success: false, error: "Failed to login as teacher" });
    }
  });

  // Get Teacher Application Status
  app.get("/api/teacher/status/:email", async (req, res) => {
    try {
      const { email } = req.params;

      const application = await db
        .select()
        .from(teacherApplications)
        .where(eq(teacherApplications.email, email))
        .limit(1);

      if (application.length === 0) {
        return res.status(404).json({ success: false, error: "No teacher application found" });
      }

      res.json({ 
        success: true, 
        status: application[0].status,
        application: {
          id: application[0].id,
          fullName: application[0].fullName,
          email: application[0].email,
          status: application[0].status,
          submittedAt: application[0].submittedAt,
          verifiedAt: application[0].verifiedAt,
          reviewedAt: application[0].reviewedAt
        }
      });

    } catch (error) {
      console.error('Teacher status check error:', error);
      res.status(500).json({ success: false, error: "Failed to check teacher status" });
    }
  });

  // Admin: Approve/Reject Teacher Application
  app.put("/api/admin/teacher/:id/status", async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;

      if (!['approved', 'rejected'].includes(status)) {
        return res.status(400).json({ success: false, error: "Status must be 'approved' or 'rejected'" });
      }

      await db
        .update(teacherApplications)
        .set({ 
          status,
          notes: notes || null,
          reviewedAt: new Date()
        })
        .where(eq(teacherApplications.id, id));

      res.json({ success: true, message: `Teacher application ${status} successfully` });

    } catch (error) {
      console.error('Teacher status update error:', error);
      res.status(500).json({ success: false, error: "Failed to update teacher status" });
    }
  });


  // Get curricula for a specific country with fallback logic
  app.get("/api/curricula/for-country/:countryId", async (req, res) => {
    try {
      const { countryId } = req.params;
      
      // First try to find country-specific curricula
      let curriculaData = await db
        .select({
          id: curricula.id,
          name: curricula.name,
          displayName: curricula.displayName,
          description: curricula.description,
          systemType: curricula.systemType,
          countryCode: curricula.countryCode,
          isPrimary: countryCurricula.isPrimary,
          isActive: curricula.isActive
        })
        .from(curricula)
        .innerJoin(countryCurricula, eq(curricula.id, countryCurricula.curriculumId))
        .where(and(
          eq(countryCurricula.countryId, parseInt(countryId)),
          eq(curricula.isActive, true)
        ))
        .orderBy(desc(countryCurricula.isPrimary));
      
      // If no country-specific curricula found, include "All Systems" as fallback
      if (curriculaData.length === 0) {
        const allSystemsCurriculum = await db
          .select({
            id: curricula.id,
            name: curricula.name,
            displayName: curricula.displayName,
            description: curricula.description,
            systemType: curricula.systemType,
            countryCode: curricula.countryCode,
            isPrimary: sql<boolean>`true`.as('isPrimary'), // Set as primary since it's the fallback
            isActive: curricula.isActive
          })
          .from(curricula)
          .where(and(
            eq(curricula.systemType, 'all_systems'),
            eq(curricula.isActive, true)
          ))
          .limit(1);
        
        curriculaData = allSystemsCurriculum;
      }
      
      // Get country info for context
      const countryInfo = await db
        .select()
        .from(countries)
        .where(eq(countries.id, parseInt(countryId)))
        .limit(1);
      
      res.json({ 
        success: true, 
        data: curriculaData,
        country: countryInfo[0] || null,
        hasFallback: curriculaData.length > 0 && curriculaData[0].systemType === 'all_systems'
      });
    } catch (error) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // Get curricula by country (legacy endpoint)
  app.get("/api/curricula/by-country/:countryId", async (req, res) => {
    try {
      const { countryId } = req.params;
      
      const curriculaData = await db
        .select({
          id: curricula.id,
          name: curricula.name,
          displayName: curricula.displayName,
          description: curricula.description,
          systemType: curricula.systemType,
          isPrimary: countryCurricula.isPrimary
        })
        .from(curricula)
        .innerJoin(countryCurricula, eq(curricula.id, countryCurricula.curriculumId))
        .where(eq(countryCurricula.countryId, parseInt(countryId)))
        .orderBy(desc(countryCurricula.isPrimary));
      
      res.json({ success: true, data: curriculaData });
    } catch (error) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // Get all available curricula
  app.get("/api/curricula", async (req, res) => {
    try {
      const curriculaData = await db
        .select()
        .from(curricula)
        .where(eq(curricula.isActive, true))
        .orderBy(curricula.displayName);
      
      res.json({ success: true, data: curriculaData });
    } catch (error) {
      console.error('Curricula fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch curricula" });
    }
  });

  // ============================================
  // SUBJECT-BASED EDUCATION API (Primary/Secondary)
  // ============================================

  // Get subjects filtered by grade level and system (for primary/secondary students)
  app.get("/api/subjects", async (req, res) => {
    try {
      const { gradeLevel, gradeSystem } = req.query;
      
      console.log(`ðŸ“š Fetching subjects - gradeLevel: ${gradeLevel}, gradeSystem: ${gradeSystem}`);
      
      // Build conditions array
      let conditions = [eq(subjects.isActive, true)];
      
      if (gradeLevel) {
        const parsedGrade = parseInt(gradeLevel as string);
        console.log(`ðŸ“š Filtering by grade level: ${parsedGrade}`);
        conditions.push(eq(subjects.gradeLevel, parsedGrade));
      }
      
      // Handle grade system filtering - more flexible approach
      if (gradeSystem && gradeSystem !== 'undefined' && gradeSystem !== 'null') {
        console.log(`ðŸ“š User has gradeSystem: ${gradeSystem}, showing subjects for that system + "all"`);
        // If user has a specific grade system, show subjects for that system + "all"
        conditions.push(or(
          eq(subjects.gradeSystem, gradeSystem as string),
          eq(subjects.gradeSystem, 'all')
        ));
      } else {
        console.log(`ðŸ“š User has no gradeSystem, showing "all" subjects`);
        // If user has no grade system (null), show subjects with "all" as fallback
        // This ensures all students can see general subjects
        conditions.push(eq(subjects.gradeSystem, 'all'));
      }
      
      const subjectsData = await db
        .select()
        .from(subjects)
        .where(and(...conditions))
        .orderBy(subjects.name);
      
      console.log(`ðŸ“š Found ${subjectsData.length} subjects for grade ${gradeLevel}`);
      
      res.json({ success: true, data: subjectsData });
    } catch (error) {
      console.error('Subjects fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch subjects" });
    }
  });

  // Get chapters for a specific subject
  app.get("/api/subjects/:subjectId/chapters", async (req, res) => {
    try {
      const { subjectId } = req.params;
      
      const chaptersData = await db
        .select()
        .from(subjectChapters)
        .where(and(
          eq(subjectChapters.subjectId, subjectId),
          eq(subjectChapters.isActive, true)
        ))
        .orderBy(subjectChapters.order);
      
      res.json({ success: true, data: chaptersData });
    } catch (error) {
      console.error('Chapters fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch chapters" });
    }
  });

  // Get lessons for a specific chapter
  app.get("/api/chapters/:chapterId/lessons", async (req, res) => {
    try {
      const { chapterId } = req.params;
      
      const lessonsData = await db
        .select()
        .from(subjectLessons)
        .where(and(
          eq(subjectLessons.chapterId, chapterId),
          eq(subjectLessons.isActive, true)
        ))
        .orderBy(subjectLessons.order);
      
      res.json({ success: true, data: lessonsData });
    } catch (error) {
      console.error('Lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lessons" });
    }
  });

  // Get a specific lesson with full content
  app.get("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const lessonData = await db
        .select()
        .from(subjectLessons)
        .where(eq(subjectLessons.id, lessonId))
        .limit(1);
      
      if (lessonData.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }
      
      res.json({ success: true, data: lessonData[0] });
    } catch (error) {
      console.error('Lesson fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lesson" });
    }
  });

  // Get quiz exercises for a specific lesson
  app.get("/api/lessons/:lessonId/exercises", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const exercisesData = await db
        .select()
        .from(subjectExercises)
        .where(and(
          eq(subjectExercises.lessonId, lessonId),
          eq(subjectExercises.isActive, true)
        ))
        .orderBy(subjectExercises.order);
      
      res.json({ success: true, data: exercisesData });
    } catch (error) {
      console.error('Exercises fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch exercises" });
    }
  });

  // Save or update lesson progress and quiz score
  app.post("/api/lessons/:lessonId/progress", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { userId, status, score, correctAnswers, totalQuestions, timeSpent } = req.body;
      
      if (!userId) {
        return res.status(400).json({ success: false, error: "User ID is required" });
      }
      
      // Check if progress already exists
      const existingProgress = await db
        .select()
        .from(subjectProgress)
        .where(and(
          eq(subjectProgress.userId, userId),
          eq(subjectProgress.lessonId, lessonId)
        ))
        .limit(1);
      
      const progressData = {
        userId,
        lessonId,
        status: status || 'in_progress',
        score: score || null,
        correctAnswers: correctAnswers || 0,
        totalQuestions: totalQuestions || 15,
        timeSpent: timeSpent || 0,
        completedAt: status === 'completed' ? new Date() : null,
        updatedAt: new Date()
      };
      
      if (existingProgress.length > 0) {
        // Update existing progress
        await db
          .update(subjectProgress)
          .set(progressData)
          .where(eq(subjectProgress.id, existingProgress[0].id));
        
        res.json({ success: true, message: "Progress updated successfully" });
      } else {
        // Create new progress record
        await db.insert(subjectProgress).values(progressData);
        res.json({ success: true, message: "Progress saved successfully" });
      }
    } catch (error) {
      console.error('Progress save error:', error);
      res.status(500).json({ success: false, error: "Failed to save progress" });
    }
  });

  // Get student's progress across all subjects
  app.get("/api/subjects/progress/:userId", async (req, res) => {
    try {
      const { userId } = req.params;
      
      const progressData = await db
        .select({
          lessonId: subjectProgress.lessonId,
          status: subjectProgress.status,
          score: subjectProgress.score,
          correctAnswers: subjectProgress.correctAnswers,
          totalQuestions: subjectProgress.totalQuestions,
          completedAt: subjectProgress.completedAt,
          timeSpent: subjectProgress.timeSpent,
          lessonTitle: subjectLessons.title,
          chapterTitle: subjectChapters.title,
          subjectName: subjects.name
        })
        .from(subjectProgress)
        .innerJoin(subjectLessons, eq(subjectProgress.lessonId, subjectLessons.id))
        .innerJoin(subjectChapters, eq(subjectLessons.chapterId, subjectChapters.id))
        .innerJoin(subjects, eq(subjectChapters.subjectId, subjects.id))
        .where(eq(subjectProgress.userId, userId))
        .orderBy(subjects.name, subjectChapters.order, subjectLessons.order);
      
      res.json({ success: true, data: progressData });
    } catch (error) {
      console.error('Progress fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch progress" });
    }
  });

  // Get student's in-progress lessons for continue reading cards
  app.get("/api/users/:userId/in-progress-lessons", async (req, res) => {
    try {
      const { userId } = req.params;
      
      const inProgressLessons = await db
        .select({
          lessonId: subjectProgress.lessonId,
          progressPercent: sql<number>`COALESCE(
            CASE 
              WHEN ${subjectProgress.status} = 'completed' THEN 100
              WHEN ${subjectProgress.totalQuestions} > 0 THEN 
                ROUND((${subjectProgress.correctAnswers}::float / ${subjectProgress.totalQuestions}::float) * 100)
              ELSE 0
            END, 
            0
          )`.as('progressPercent'),
          status: subjectProgress.status,
          updatedAt: subjectProgress.updatedAt,
          lessonTitle: subjectLessons.title,
          lessonOrder: subjectLessons.order,
          chapterTitle: subjectChapters.title,
          chapterOrder: subjectChapters.order,
          subjectName: subjects.name,
          subjectId: subjects.id,
          chapterId: subjectChapters.id
        })
        .from(subjectProgress)
        .innerJoin(subjectLessons, eq(subjectProgress.lessonId, subjectLessons.id))
        .innerJoin(subjectChapters, eq(subjectLessons.chapterId, subjectChapters.id))
        .innerJoin(subjects, eq(subjectChapters.subjectId, subjects.id))
        .where(
          and(
            eq(subjectProgress.userId, userId),
            ne(subjectProgress.status, 'completed')
          )
        )
        .orderBy(desc(subjectProgress.updatedAt))
        .limit(10);
      
      res.json({ success: true, data: inProgressLessons });
    } catch (error) {
      console.error('In-progress lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch in-progress lessons" });
    }
  });

  // ============================================
  // POST ENDPOINTS FOR SUBJECT-BASED EDUCATION
  // ============================================

  // Create a new subject
  app.post("/api/subjects", async (req, res) => {
    try {
      const { name, gradeSystem, gradeLevel, description, iconUrl } = req.body;
      
      if (!name || !gradeSystem || !gradeLevel) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields: name, gradeSystem, gradeLevel" 
        });
      }
      
      const newSubject = await db
        .insert(subjects)
        .values({
          name,
          gradeSystem,
          gradeLevel: parseInt(gradeLevel),
          description: description || null,
          iconUrl: iconUrl || null,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newSubject[0] });
    } catch (error) {
      console.error('Subject creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create subject" });
    }
  });

  // Create a new chapter
  app.post("/api/subjects/:subjectId/chapters", async (req, res) => {
    try {
      const { subjectId } = req.params;
      const { title, description, order } = req.body;
      
      if (!title) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required field: title" 
        });
      }
      
      const newChapter = await db
        .insert(subjectChapters)
        .values({
          subjectId,
          title,
          description: description || null,
          order: order || 1,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newChapter[0] });
    } catch (error) {
      console.error('Chapter creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create chapter" });
    }
  });

  // Create a new lesson
  app.post("/api/chapters/:chapterId/lessons", async (req, res) => {
    try {
      const { chapterId } = req.params;
      const { title, notes, examples, cloudinaryImages, order, durationMinutes } = req.body;
      
      if (!title || !notes) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required fields: title, notes" 
        });
      }
      
      const newLesson = await db
        .insert(subjectLessons)
        .values({
          chapterId,
          title,
          notes,
          examples: examples || [],
          cloudinaryImages: cloudinaryImages || [],
          order: order || 1,
          durationMinutes: durationMinutes || 30,
          isActive: true
        })
        .returning();
      
      res.json({ success: true, data: newLesson[0] });
    } catch (error) {
      console.error('Lesson creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create lesson" });
    }
  });

  // Update a lesson
  app.put("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { title, notes, examples, cloudinaryImages, order, durationMinutes } = req.body;
      
      // Build update object with only provided fields
      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (notes !== undefined) updateData.notes = notes;
      if (examples !== undefined) updateData.examples = examples;
      if (cloudinaryImages !== undefined) updateData.cloudinaryImages = cloudinaryImages;
      if (order !== undefined) updateData.order = order;
      if (durationMinutes !== undefined) updateData.durationMinutes = durationMinutes;
      
      const updatedLesson = await db
        .update(subjectLessons)
        .set(updateData)
        .where(eq(subjectLessons.id, lessonId))
        .returning();
      
      if (updatedLesson.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: "Lesson not found" 
        });
      }
      
      res.json({ success: true, data: updatedLesson[0] });
    } catch (error) {
      console.error('Lesson update error:', error);
      res.status(500).json({ success: false, error: "Failed to update lesson" });
    }
  });

  // Create quiz exercises for a lesson
  app.post("/api/lessons/:lessonId/exercises", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { exercises } = req.body;
      
      if (!exercises || !Array.isArray(exercises)) {
        return res.status(400).json({ 
          success: false, 
          error: "Missing required field: exercises (must be an array)" 
        });
      }
      
      // Prepare exercises with lessonId and order
      const exercisesToInsert = exercises.map((exercise, index) => ({
        lessonId,
        question: exercise.question,
        options: exercise.options,
        correctAnswer: exercise.correctAnswer,
        explanation: exercise.explanation || null,
        order: index + 1,
        isActive: true
      }));
      
      const newExercises = await db
        .insert(subjectExercises)
        .values(exercisesToInsert)
        .returning();
      
      res.json({ success: true, data: newExercises });
    } catch (error) {
      console.error('Exercises creation error:', error);
      res.status(500).json({ success: false, error: "Failed to create exercises" });
    }
  });

  // ============================================
  // COURSES API (College/University/Other)
  // ============================================

  // Courses API endpoints for college/university students
  
  // Get courses (for college/university/other education levels)
  app.get("/api/courses", async (req, res) => {
    try {
      const { difficulty, category } = req.query;
      
      try {
        // Try database first
        let conditions = [eq(courses.isActive, true), eq(courses.approvalStatus, "approved")]; // Only show approved courses
        
        if (difficulty) {
          conditions.push(eq(courses.difficulty, difficulty as string));
        }
        
        if (category) {
          conditions.push(eq(courses.categoryId, category as string));
        }
        
        const coursesData = await db
          .select()
          .from(courses)
          .where(and(...conditions))
          .orderBy(courses.title);
        
        res.json({ success: true, data: coursesData, totalCount: coursesData.length });
      } catch (dbError) {
        console.error('Database error fetching courses:', dbError);
        throw dbError;
      }
    } catch (error) {
      console.error('Courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch courses" });
    }
  });

  // Get featured courses for landing page
  app.get("/api/courses/featured", async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 8;
      const featuredCourses = await storage.getFeaturedCourses(limit);
      
      res.json({ success: true, data: featuredCourses });
    } catch (error) {
      console.error('Featured courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch featured courses" });
    }
  });

  // Admin: Feature/unfeature a course
  app.patch("/api/courses/:id/feature", requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { isFeatured } = req.body;

      if (typeof isFeatured !== 'boolean') {
        return res.status(400).json({ success: false, error: "isFeatured must be a boolean" });
      }

      const updatedCourse = await storage.setCourseFeatured(id, isFeatured);

      if (!updatedCourse) {
        return res.status(404).json({ success: false, error: "Course not found" });
      }

      res.json({ success: true, data: updatedCourse });
    } catch (error) {
      console.error('Course feature update error:', error);
      res.status(500).json({ success: false, error: "Failed to update course featured status" });
    }
  });

  // Get Mathematics content (special endpoint for Grade 7 Mathematics)
  app.get("/api/mathematics/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_mathematics.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const mathBook = JSON.parse(data);
      
      res.json({ success: true, data: mathBook });
    } catch (error) {
      console.error('Mathematics content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch mathematics content" });
    }
  });

  // Get English content (special endpoint for Grade 7 English)
  app.get("/api/english/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_english.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const englishBook = JSON.parse(data);
      
      res.json({ success: true, data: englishBook });
    } catch (error) {
      console.error('English content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch english content" });
    }
  });

  // Get Science content (special endpoint for Grade 7 Science)
  app.get("/api/science/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_science.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const scienceBook = JSON.parse(data);
      
      res.json({ success: true, data: scienceBook });
    } catch (error) {
      console.error('Science content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch science content" });
    }
  });

  // Get Social Studies content (special endpoint for Grade 7 Social Studies)
  app.get("/api/social-studies/content", async (req, res) => {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const filePath = path.join(process.cwd(), 'grade7_social_studies.json');
      
      const data = await fs.readFile(filePath, 'utf8');
      const socialStudiesBook = JSON.parse(data);
      
      res.json({ success: true, data: socialStudiesBook });
    } catch (error) {
      console.error('Social Studies content fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch social studies content" });
    }
  });

  // Save quiz result for Mathematics
  app.post("/api/mathematics/quiz-result", async (req, res) => {
    try {
      const { lessonId, score, totalQuestions, answers } = req.body;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Store the result in localStorage on client side for now
      // Could be enhanced to store in database later
      res.json({ success: true, message: "Quiz result processed" });
    } catch (error) {
      console.error('Quiz result save error:', error);
      res.status(500).json({ success: false, error: "Failed to save quiz result" });
    }
  });


  // Get lessons for a course
  app.get("/api/courses/:courseId/lessons", async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // Direct PostgreSQL query bypassing Drizzle schema
      const { Client } = await import('pg');
      const client = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client.connect();
      
      const result = await client.query(`
        SELECT id, title, description, course_id, level as "chapterNumber", level as "lessonNumber", 
               content, duration_minutes as duration, 'text' as "contentType", "order" as "orderIndex",
               free_preview_flag as "isPublished"
        FROM lessons 
        WHERE course_id = $1 AND free_preview_flag = true
        ORDER BY "order"
      `, [courseId]);
      
      await client.end();
      
      res.json({ success: true, data: result.rows, totalCount: result.rows.length });
    } catch (error) {
      console.error('Course lessons fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch course lessons" });
    }
  });

  // Get specific lesson with progress tracking
  app.get("/api/lessons/:lessonId", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { userId } = req.query;
      
      // Get lesson details using direct query
      const { Client } = await import('pg');
      const client = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client.connect();
      const lessonResult = await client.query(`
        SELECT id, title, description, subject_id, course_id, level, content, duration_minutes as duration, 'text' as content_type
        FROM lessons WHERE id = $1 LIMIT 1
      `, [lessonId]);
      await client.end();
      
      const lessonData = lessonResult.rows;
      
      if (lessonData.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }
      
      let userProgress = null;
      if (userId) {
        // Get user's progress for this lesson
        const progressData = await db
          .select()
          .from(studentProgress)
          .where(and(
            eq(studentProgress.userId, userId as string),
            eq(studentProgress.lessonId, lessonId)
          ))
          .limit(1);
        
        userProgress = progressData[0] || null;
      }
      
      res.json({ 
        success: true, 
        data: {
          lesson: lessonData[0],
          progress: userProgress
        }
      });
    } catch (error) {
      console.error('Lesson fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch lesson" });
    }
  });

  // TOPICS API ENDPOINTS
  // ====================

  // Get topics for a lesson
  app.get("/api/lessons/:lessonId/topics", async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const topicsData = await db
        .select()
        .from(topics)
        .where(eq(topics.lessonId, parseInt(lessonId)))
        .orderBy(topics.order, topics.createdAt);
      
      res.json({ 
        success: true, 
        data: topicsData 
      });
    } catch (error) {
      console.error('Topics fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch topics" });
    }
  });

  // Get a single topic
  app.get("/api/topics/:topicId", async (req, res) => {
    try {
      const { topicId } = req.params;
      
      const topicData = await db
        .select()
        .from(topics)
        .where(eq(topics.id, parseInt(topicId)))
        .limit(1);
      
      if (topicData.length === 0) {
        return res.status(404).json({ success: false, error: "Topic not found" });
      }
      
      res.json({ 
        success: true, 
        data: topicData[0] 
      });
    } catch (error) {
      console.error('Topic fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch topic" });
    }
  });

  // Create a new topic (admin only)
  app.post("/api/topics", requireAuth, async (req, res) => {
    try {
      const { lessonId, title, content, mediaType, mediaUrl, order } = req.body;
      
      if (!lessonId || !title || !content) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: lessonId, title, content'
        });
      }

      // Validate media type if provided
      if (mediaType && !['image', 'video'].includes(mediaType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media type. Must be "image" or "video"'
        });
      }

      // Validate media URL format if provided
      if (mediaUrl) {
        try {
          new URL(mediaUrl);
        } catch {
          return res.status(400).json({
            success: false,
            error: 'Invalid media URL format'
          });
        }
      }

      // Check if lesson exists
      const lessonExists = await db
        .select()
        .from(lessons)
        .where(eq(lessons.id, lessonId))
        .limit(1);

      if (lessonExists.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Lesson not found'
        });
      }

      const newTopic = await db
        .insert(topics)
        .values({
          lessonId,
          title,
          content,
          mediaType: mediaType || null,
          mediaUrl: mediaUrl || null,
          order: order || 0
        })
        .returning();
      
      res.status(201).json({ 
        success: true, 
        data: newTopic[0],
        message: 'Topic created successfully'
      });
    } catch (error) {
      console.error('Topic creation error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to create topic" 
      });
    }
  });

  // Update a topic (admin only)
  app.put("/api/topics/:topicId", requireAuth, async (req, res) => {
    try {
      const { topicId } = req.params;
      const { title, content, mediaType, mediaUrl, order } = req.body;

      // Validate media type if provided
      if (mediaType && !['image', 'video'].includes(mediaType)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media type. Must be "image" or "video"'
        });
      }

      // Validate media URL format if provided
      if (mediaUrl) {
        try {
          new URL(mediaUrl);
        } catch {
          return res.status(400).json({
            success: false,
            error: 'Invalid media URL format'
          });
        }
      }

      const updateData: any = { updatedAt: new Date() };
      if (title !== undefined) updateData.title = title;
      if (content !== undefined) updateData.content = content;
      if (mediaType !== undefined) updateData.mediaType = mediaType;
      if (mediaUrl !== undefined) updateData.mediaUrl = mediaUrl;
      if (order !== undefined) updateData.order = order;

      const updatedTopic = await db
        .update(topics)
        .set(updateData)
        .where(eq(topics.id, parseInt(topicId)))
        .returning();

      if (updatedTopic.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Topic not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedTopic[0],
        message: 'Topic updated successfully'
      });
    } catch (error) {
      console.error('Topic update error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to update topic" 
      });
    }
  });

  // Delete a topic (admin only)
  app.delete("/api/topics/:topicId", requireAuth, async (req, res) => {
    try {
      const { topicId } = req.params;

      const deletedTopic = await db
        .delete(topics)
        .where(eq(topics.id, parseInt(topicId)))
        .returning();

      if (deletedTopic.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Topic not found' 
        });
      }

      res.json({ 
        success: true, 
        message: 'Topic deleted successfully'
      });
    } catch (error) {
      console.error('Topic deletion error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete topic" 
      });
    }
  });

  // SCHEDULING SYSTEM API ENDPOINTS
  // ===============================

  // Get teacher availability
  app.get("/api/teachers/:teacherId/availability", async (req, res) => {
    try {
      const { teacherId } = req.params;
      
      const availability = await db
        .select()
        .from(teacherAvailability)
        .where(and(
          eq(teacherAvailability.teacherId, teacherId),
          eq(teacherAvailability.isActive, true)
        ))
        .orderBy(teacherAvailability.dayOfWeek, teacherAvailability.startTime);
      
      res.json({ 
        success: true, 
        data: availability 
      });
    } catch (error) {
      console.error('Fetch teacher availability error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch teacher availability" });
    }
  });

  // Set/Update teacher availability (teacher only)
  app.post("/api/teachers/:teacherId/availability", requireAuth, async (req, res) => {
    try {
      const { teacherId } = req.params;
      const { dayOfWeek, startTime, endTime, timeZone, isRecurring, specificDate } = req.body;
      
      if (dayOfWeek === undefined || !startTime || !endTime) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: dayOfWeek, startTime, endTime'
        });
      }

      const newAvailability = await db
        .insert(teacherAvailability)
        .values({
          teacherId,
          dayOfWeek,
          startTime,
          endTime,
          timeZone: timeZone || 'UTC',
          isRecurring: isRecurring !== false,
          specificDate: specificDate ? new Date(specificDate) : null
        })
        .returning();
      
      res.status(201).json({ 
        success: true, 
        data: newAvailability[0],
        message: 'Availability slot created successfully'
      });
    } catch (error) {
      console.error('Create teacher availability error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to create availability slot" 
      });
    }
  });

  // Delete teacher availability slot
  app.delete("/api/teachers/availability/:slotId", requireAuth, async (req, res) => {
    try {
      const { slotId } = req.params;

      const deletedSlot = await db
        .delete(teacherAvailability)
        .where(eq(teacherAvailability.id, slotId))
        .returning();

      if (deletedSlot.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Availability slot not found' 
        });
      }

      res.json({ 
        success: true, 
        message: 'Availability slot deleted successfully'
      });
    } catch (error) {
      console.error('Delete availability slot error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to delete availability slot" 
      });
    }
  });

  // Teacher availability settings (complete form)
  app.get("/api/teacher/availability/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;

      // Get teacher's availability settings from profile
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      // Parse availability settings or return default values
      const availabilityData = profile[0].availabilitySettings ? 
        JSON.parse(profile[0].availabilitySettings) : {
          timezone: '',
          weeklyAvailability: {
            Monday: false,
            Tuesday: false,
            Wednesday: false,
            Thursday: false,
            Friday: false,
            Saturday: false,
            Sunday: false
          },
          startTime: '09:00',
          endTime: '17:00'
        };

      res.json({ 
        success: true, 
        availability: availabilityData 
      });
    } catch (error) {
      console.error('Get teacher availability settings error:', error);
      res.status(500).json({ success: false, error: "Failed to get availability settings" });
    }
  });

  // Save teacher availability settings (complete form)
  app.post("/api/teacher/availability/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const availabilityData = req.body;

      // Validate the data structure
      if (!availabilityData.timezone || !availabilityData.weeklyAvailability || 
          !availabilityData.startTime || !availabilityData.endTime) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required availability data' 
        });
      }

      // Update the profile with the availability settings
      await db.update(profiles)
        .set({ 
          availabilitySettings: JSON.stringify(availabilityData),
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId));

      res.json({ 
        success: true, 
        message: 'Availability settings updated successfully'
      });
    } catch (error) {
      console.error('Save teacher availability settings error:', error);
      res.status(500).json({ success: false, error: "Failed to save availability settings" });
    }
  });

  // Get all appointments for a user (teacher or student)
  app.get("/api/appointments/:userId", requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const { status, from, to } = req.query;
      
      // Use raw SQL to match actual database structure
      let baseQuery = sql`
        SELECT 
          a.id,
          a.title,
          a.description,
          a.start_date as "scheduledAt",
          a.end_date,
          a.teacher_id as "teacherId",
          a.student_id as "studentId",
          a.status,
          a.subject,
          a.meeting_url as "meetingLink",
          a.notes,
          a.created_at as "createdAt",
          EXTRACT(EPOCH FROM (a.end_date - a.start_date)) / 60 as duration,
          'paid' as "paymentStatus",
          t.name as "teacherName",
          s.name as "studentName"
        FROM appointments a
        LEFT JOIN profiles t ON a.teacher_id = t.user_id
        LEFT JOIN profiles s ON a.student_id = s.user_id
        WHERE (a.teacher_id = ${userId} OR a.student_id = ${userId})
      `;

      let conditions = [];
      let params = [userId];
      
      if (status) {
        conditions.push(`a.status = '${status}'`);
      }

      if (from && to) {
        conditions.push(`a.start_date BETWEEN '${from}' AND '${to}'`);
      }

      if (conditions.length > 0) {
        baseQuery = sql`${baseQuery} AND ${sql.raw(conditions.join(' AND '))}`;
      }

      baseQuery = sql`${baseQuery} ORDER BY a.start_date DESC`;

      const result = await db.execute(baseQuery);
      
      // Handle different result structures
      const appointmentsData = result.rows || result || [];
      
      res.json({ 
        success: true, 
        data: appointmentsData 
      });
    } catch (error) {
      console.error('Fetch appointments error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch appointments" });
    }
  });

  // Book an appointment (student books with teacher)
  app.post("/api/appointments", requireAuth, async (req, res) => {
    try {
      const { teacherId, studentId, subject, description, scheduledAt, duration, price } = req.body;
      
      if (!teacherId || !studentId || !scheduledAt) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: teacherId, studentId, scheduledAt'
        });
      }

      const startDate = new Date(scheduledAt);
      const endDate = new Date(startDate.getTime() + (duration || 60) * 60000); // Add duration in milliseconds

      // Check if the slot is available (no existing appointment at this time)
      const existingAppointment = await db.execute(
        sql`
          SELECT * FROM appointments 
          WHERE teacher_id = ${teacherId} 
          AND start_date = ${startDate.toISOString()}
          AND status != 'cancelled'
          LIMIT 1
        `
      );

      if (existingAppointment && existingAppointment.length > 0) {
        return res.status(409).json({
          success: false,
          error: 'This time slot is already booked'
        });
      }
      
      const newAppointment = await db.execute(
        sql`
          INSERT INTO appointments (
            title, 
            start_date, 
            end_date, 
            teacher_id, 
            student_id, 
            requester_id,
            status, 
            type,
            subject,
            description
          ) VALUES (
            ${`Tutoring Session`},
            ${startDate.toISOString()},
            ${endDate.toISOString()},
            ${teacherId},
            ${studentId},
            ${studentId},
            ${'pending'},
            ${'virtual'},
            ${subject || 'General'},
            ${description || ''}
          )
          RETURNING *
        `
      );
      
      res.status(201).json({ 
        success: true, 
        data: newAppointment && newAppointment.length > 0 ? newAppointment[0] : {},
        message: 'Appointment booked successfully'
      });
    } catch (error) {
      console.error('Book appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to book appointment" 
      });
    }
  });

  // Update appointment status
  app.put("/api/appointments/:appointmentId", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;
      const { status, notes, meetingLink } = req.body;

      const updateData: any = { updatedAt: new Date() };
      if (status !== undefined) updateData.status = status;
      if (notes !== undefined) updateData.notes = notes;
      if (meetingLink !== undefined) updateData.meetingLink = meetingLink;

      const updatedAppointment = await db
        .update(appointments)
        .set(updateData)
        .where(eq(appointments.id, appointmentId))
        .returning();

      if (updatedAppointment.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Appointment not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedAppointment[0],
        message: 'Appointment updated successfully'
      });
    } catch (error) {
      console.error('Update appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to update appointment" 
      });
    }
  });

  // Cancel appointment
  app.delete("/api/appointments/:appointmentId", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;

      const updatedAppointment = await db
        .update(appointments)
        .set({ 
          status: 'cancelled',
          updatedAt: new Date()
        })
        .where(eq(appointments.id, appointmentId))
        .returning();

      if (updatedAppointment.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Appointment not found' 
        });
      }

      res.json({ 
        success: true, 
        data: updatedAppointment[0],
        message: 'Appointment cancelled successfully'
      });
    } catch (error) {
      console.error('Cancel appointment error:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to cancel appointment" 
      });
    }
  });

  // Approve or decline appointment (teacher action)
  app.patch("/api/appointments/:appointmentId/status", requireAuth, async (req, res) => {
    try {
      const { appointmentId } = req.params;
      const { action, meetingLink } = req.body; // action: 'approve' or 'decline'
      
      if (!action || !['approve', 'decline'].includes(action)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid action. Must be "approve" or "decline"'
        });
      }

      const newStatus = action === 'approve' ? 'confirmed' : 'cancelled';
      
      // Get appointment details first
      const appointment = await db.select()
        .from(appointments)
        .where(eq(appointments.id, appointmentId))
        .limit(1);

      if (appointment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Appointment not found'
        });
      }

      // Update appointment with new status and optional meeting link
      const updateData: any = { 
        status: newStatus,
        updatedAt: new Date()
      };
      
      if (meetingLink && action === 'approve') {
        updateData.meetingUrl = meetingLink;
      }

      const updatedAppointment = await db
        .update(appointments)
        .set(updateData)
        .where(eq(appointments.id, appointmentId))
        .returning();

      // If appointment is approved, automatically create chat thread
      if (action === 'approve') {
        try {
          const teacherId = appointment[0].teacherId;
          const studentId = appointment[0].studentId;
          
          // Get teacher and student profile UUIDs for message creation
          const teacherProfile = await db.select({ id: profiles.id, name: profiles.name })
            .from(profiles)
            .where(eq(profiles.userId, teacherId))
            .limit(1);

          const studentProfile = await db.select({ id: profiles.id, name: profiles.name })
            .from(profiles)
            .where(eq(profiles.userId, studentId))
            .limit(1);

          if (teacherProfile.length > 0 && studentProfile.length > 0) {
            // Create initial chat message from teacher
            const initialMessage = `Hi ${studentProfile[0].name}! Your appointment request has been approved. This chat thread has been created for our lesson. Looking forward to working with you!`;
            
            await db.insert(messages).values({
              senderId: teacherProfile[0].id,
              receiverId: studentProfile[0].id,
              content: initialMessage,
              messageType: 'text',
              isRead: false,
              deliveredAt: new Date(),
              createdAt: new Date()
            });

            console.log(`ðŸ’¬ Auto-created chat thread for approved appointment ${appointmentId}`);

            // Send real-time notification to student via WebSocket if connected
            const wss = (global as any).wss;
            const studentTextId = await getTextIdByProfileUuid(studentProfile[0].id);
            if (wss && studentTextId) {
              const studentWs = wss.userConnections?.get(studentTextId);
              if (studentWs && studentWs.readyState === 1) { // WebSocket.OPEN = 1
                studentWs.send(JSON.stringify({
                  type: 'appointment_approved',
                  data: {
                    appointmentId,
                    message: 'Your appointment has been approved and a chat thread has been created!',
                    chatEnabled: true
                  }
                }));
              }
            }
          }
        } catch (chatError) {
          console.error('Error creating chat thread for approved appointment:', chatError);
          // Don't fail the appointment approval if chat creation fails
        }
      }

      // Send notification to student about appointment status change
      try {
        const wss = (global as any).wss;
        // Get student profile UUID first, then convert to text ID
        const studentProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, appointment[0].studentId))
          .limit(1);
        
        if (studentProfile.length > 0) {
          const studentTextId = await getTextIdByProfileUuid(studentProfile[0].id);
          if (wss && studentTextId) {
            const studentWs = wss.userConnections?.get(studentTextId);
            if (studentWs && studentWs.readyState === 1) {
              studentWs.send(JSON.stringify({
                type: 'appointment_status_update',
                data: {
                  appointmentId,
                  status: newStatus,
                  message: `Your appointment has been ${action}d by the teacher`
                }
              }));
            }
          }
        }
      } catch (notificationError) {
        console.error('Error sending appointment notification:', notificationError);
      }
      
      res.json({ 
        success: true, 
        message: `Appointment ${action}d successfully${action === 'approve' ? ' and chat thread created' : ''}`,
        appointment: updatedAppointment[0]
      });
    } catch (error) {
      console.error('Update appointment status error:', error);
      res.status(500).json({ success: false, error: "Failed to update appointment status" });
    }
  });

  // Get all teachers with their availability settings (for students to book)
  app.get("/api/teachers/available-with-settings", async (req, res) => {
    try {
      // Simple query first to check basic functionality
      const allTeachers = await db
        .select()
        .from(profiles)
        .where(eq(profiles.role, 'teacher'));

      console.log('Found teachers:', allTeachers.length);

      // Filter for teachers with availability settings
      const teachers = allTeachers.filter(teacher => 
        teacher.status === 'active' && teacher.availabilitySettings
      );

      console.log('Teachers with availability:', teachers.length);

      // Parse availability settings for each teacher
      const teachersWithAvailability = teachers.map(teacher => {
        let availability = null;
        try {
          availability = teacher.availabilitySettings ? JSON.parse(teacher.availabilitySettings) : null;
        } catch (error) {
          console.error('Error parsing availability settings for teacher:', teacher.id, error);
        }
        
        return {
          id: teacher.userId, // Use userId (which references users.id) instead of profile id
          name: teacher.name,
          email: teacher.email,
          avatarUrl: teacher.avatarUrl,
          availability: availability
        };
      }).filter(teacher => teacher.availability !== null);

      console.log('Final teachers with parsed availability:', teachersWithAvailability.length);

      res.json({
        success: true,
        data: teachersWithAvailability
      });
    } catch (error) {
      console.error('Get available teachers with settings error:', error);
      res.status(500).json({ success: false, error: "Failed to get available teachers" });
    }
  });

  // Get available teachers for booking (legacy)
  app.get("/api/teachers/available", async (req, res) => {
    try {
      const { subject, day, time } = req.query;
      
      // Get teachers with availability
      let query = db
        .select({
          teacherId: teacherAvailability.teacherId,
          teacherName: profiles.name,
          teacherEmail: profiles.email,
          avatarUrl: profiles.avatarUrl,
          dayOfWeek: teacherAvailability.dayOfWeek,
          startTime: teacherAvailability.startTime,
          endTime: teacherAvailability.endTime,
          timeZone: teacherAvailability.timeZone
        })
        .from(teacherAvailability)
        .innerJoin(profiles, eq(teacherAvailability.teacherId, profiles.userId))
        .where(and(
          eq(teacherAvailability.isActive, true),
          eq(profiles.role, 'teacher'),
          eq(profiles.status, 'active')
        ));

      if (day !== undefined) {
        query = query.where(and(
          eq(teacherAvailability.isActive, true),
          eq(teacherAvailability.dayOfWeek, parseInt(day as string))
        ));
      }

      const availableTeachers = await query;
      
      res.json({ 
        success: true, 
        data: availableTeachers 
      });
    } catch (error) {
      console.error('Fetch available teachers error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch available teachers" });
    }
  });

  // Update lesson progress (more specific than general subject progress)
  app.post("/api/lessons/:lessonId/progress", async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { progressPercentage, timeSpent, completed } = req.body;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;

      // Get lesson using direct query
      const { Client } = await import('pg');
      const client2 = new Client({
        connectionString: process.env.DATABASE_URL
      });
      
      await client2.connect();
      const lessonResult2 = await client2.query(`
        SELECT id, subject_id, course_id FROM lessons WHERE id = $1 LIMIT 1
      `, [lessonId]);
      await client2.end();
      
      const lesson = lessonResult2.rows;

      if (lesson.length === 0) {
        return res.status(404).json({ success: false, error: "Lesson not found" });
      }

      // Check if progress already exists
      const existing = await db
        .select()
        .from(studentProgress)
        .where(and(
          eq(studentProgress.userId, userId),
          eq(studentProgress.lessonId, lessonId)
        ))
        .limit(1);

      const updateData = {
        progressPercentage: progressPercentage ?? (existing[0]?.progressPercentage || 0),
        timeSpent: (existing[0]?.timeSpent || 0) + (timeSpent || 0),
        completedAt: completed || progressPercentage === 100 ? new Date() : existing[0]?.completedAt,
        lastAccessedAt: new Date(),
        updatedAt: new Date()
      };

      if (existing.length > 0) {
        // Update existing progress
        await db
          .update(studentProgress)
          .set(updateData)
          .where(eq(studentProgress.id, existing[0].id));
      } else {
        // Create new progress
        await db.insert(studentProgress).values({
          userId,
          lessonId,
          subjectId: lesson[0].subjectId || null,
          courseId: lesson[0].courseId || null,
          ...updateData
        });
      }

      res.json({ success: true, message: "Lesson progress updated successfully" });
    } catch (error) {
      console.error('Lesson progress update error:', error);
      res.status(500).json({ success: false, error: "Failed to update lesson progress" });
    }
  });

  // Check user's lesson access limits (for free users)
  app.get("/api/users/:userId/lesson-access", async (req, res) => {
    try {
      const { userId } = req.params;
      const { subjectId, courseId } = req.query;
      
      // Get user's subscription info
      const userProfile = await db
        .select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);
      
      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }
      
      const profile = userProfile[0];
      const currentTime = new Date();
      
      // Check if user has active premium subscription
      const hasActivePremium = profile.plan && 
        profile.plan !== '' && 
        profile.planExpiry && 
        profile.planExpiry > currentTime;
      
      if (hasActivePremium) {
        return res.json({ 
          success: true, 
          hasAccess: true, 
          isPremium: true,
          message: "Full access with premium subscription"
        });
      }
      
      // For free users, check lesson limits
      const educationLevel = profile.educationLevel?.toLowerCase();
      
      if (educationLevel === 'college' || educationLevel === 'university') {
        // College/University: preview-only
        return res.json({ 
          success: true, 
          hasAccess: false,
          isPremium: false,
          limitType: 'preview',
          message: "College/University courses require premium subscription"
        });
      }
      
      // Primary/High School: 2 lessons per subject
      if (subjectId) {
        const accessedLessons = await db
          .select({ count: count() })
          .from(studentProgress)
          .where(and(
            eq(studentProgress.userId, userId),
            eq(studentProgress.subjectId, subjectId),
            isNotNull(studentProgress.lessonId)
          ));
        
        const accessCount = accessedLessons[0]?.count || 0;
        const hasAccess = accessCount < 2;
        
        return res.json({ 
          success: true, 
          hasAccess,
          isPremium: false,
          limitType: 'lesson_count',
          accessedCount: accessCount,
          maxLessons: 2,
          message: hasAccess 
            ? `You have ${2 - accessCount} free lessons remaining for this subject`
            : "You've used all free lessons for this subject. Upgrade to premium for unlimited access."
        });
      }
      
      res.json({ 
        success: true, 
        hasAccess: true,
        isPremium: false,
        message: "Free access available"
      });
      
    } catch (error) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ success: false, error: "Failed to check lesson access" });
    }
  });


  // LMS Dashboard API Endpoints


  // Get enrolled courses for university students
  app.get("/api/courses/enrolled/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const enrolledCourses = await db
        .select({
          id: courses.id,
          title: courses.title,
          description: courses.description,
          courseCode: courses.courseCode,
          credits: courses.credits,
          duration: courses.duration,
          thumbnailUrl: courses.thumbnailUrl,
          progress: courseEnrollments.progress,
          instructor: sql`'Dr. Smith'`.as('instructor') // Placeholder for now
        })
        .from(courseEnrollments)
        .innerJoin(courses, eq(courseEnrollments.courseId, courses.id))
        .where(
          and(
            eq(courseEnrollments.userId, userId),
            eq(courseEnrollments.isActive, true)
          )
        )
        .orderBy(desc(courseEnrollments.enrolledAt));

      res.json({ success: true, data: enrolledCourses });
    } catch (error) {
      console.error('Enrolled courses fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch enrolled courses" });
    }
  });

  // Get continue watching lessons
  app.get("/api/lessons/continue-watching/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const continueLessons = await db
        .select({
          id: lessons.id,
          title: lessons.title,
          description: lessons.description,
          duration: lessons.durationMinutes,
          contentType: lessons.contentType,
          progress: studentProgress.progressPercentage,
          isCompleted: sql`${studentProgress.progressPercentage} = 100`.as('isCompleted'),
          lastAccessedAt: studentProgress.lastAccessedAt
        })
        .from(studentProgress)
        .innerJoin(lessons, eq(studentProgress.lessonId, lessons.id))
        .where(
          and(
            eq(studentProgress.userId, userId),
            gt(studentProgress.progressPercentage, 0),
            lt(studentProgress.progressPercentage, 100)
          )
        )
        .orderBy(desc(studentProgress.lastAccessedAt))
        .limit(6);

      res.json({ success: true, data: continueLessons });
    } catch (error) {
      console.error('Continue watching fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch continue watching lessons" });
    }
  });

  // Get available teachers/mentors
  app.get("/api/teachers/available", async (req, res) => {
    try {
      const teachers = await db
        .select({
          id: profiles.id,
          name: profiles.name,
          subject: sql`'Mathematics'`.as('subject'), // Placeholder
          avatarUrl: profiles.avatarUrl,
          rating: sql`4.5`.as('rating'), // Placeholder
          isOnline: sql`true`.as('isOnline') // Placeholder
        })
        .from(profiles)
        .where(eq(profiles.role, 'teacher'))
        .limit(10);

      res.json({ success: true, data: teachers });
    } catch (error) {
      console.error('Teachers fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch teachers" });
    }
  });

  // Get student statistics
  app.get("/api/student/statistics/:userId", async (req, res) => {
    try {
      const { userId } = req.params;

      const stats = await db
        .select({
          totalLessons: count(studentProgress.id),
          completedLessons: sql`COUNT(CASE WHEN ${studentProgress.progressPercentage} = 100 THEN 1 END)`.as('completedLessons'),
          timeSpent: sum(studentProgress.timeSpent),
          averageScore: avg(studentProgress.score)
        })
        .from(studentProgress)
        .where(eq(studentProgress.userId, userId));

      const result = stats[0] || {
        totalLessons: 0,
        completedLessons: 0,
        timeSpent: 0,
        averageScore: 0
      };

      res.json({ success: true, data: result });
    } catch (error) {
      console.error('Student statistics fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch student statistics" });
    }
  });


  // Create sample lessons and courses for demo
  app.post("/api/demo/seed", async (req, res) => {
    try {
      // Create sample lessons
      const sampleLessons = [
        {
          title: "Introduction to Algebra",
          description: "Learn the basics of algebraic expressions and equations",
          subjectId: null,
          courseId: null,
          chapterNumber: 1,
          lessonNumber: 1,
          contentType: "text",
          content: "Algebra is a branch of mathematics dealing with symbols and the rules for manipulating those symbols.",
          duration: 45,
          isPublished: true,
          orderIndex: 1
        },
        {
          title: "Linear Equations",
          description: "Solve linear equations with one variable",
          subjectId: null,
          courseId: null,
          chapterNumber: 1,
          lessonNumber: 2,
          contentType: "video",
          content: "A linear equation is an equation that makes a straight line when it is graphed.",
          videoUrl: "https://example.com/linear-equations.mp4",
          duration: 30,
          isPublished: true,
          orderIndex: 2
        },
        {
          title: "Quadratic Functions",
          description: "Understanding parabolas and quadratic equations",
          subjectId: null,
          courseId: null,
          chapterNumber: 2,
          lessonNumber: 1,
          contentType: "interactive",
          content: "Quadratic functions form parabolas when graphed and have the form y = axÂ² + bx + c.",
          duration: 60,
          isPublished: true,
          orderIndex: 3
        }
      ];

      await db.insert(lessons).values(sampleLessons);

      // Create sample courses
      const sampleCourses = [
        {
          title: "Advanced Mathematics",
          description: "Comprehensive course covering algebra, geometry, and calculus",
          courseCode: "MATH301",
          credits: 4,
          duration: 16,
          difficulty: "advanced",
          prerequisites: ["MATH201", "MATH202"],
          learningObjectives: ["Master advanced algebraic concepts", "Understand geometric proofs", "Apply calculus to real-world problems"],
          price: "299.99"
        },
        {
          title: "Computer Science Fundamentals",
          description: "Introduction to programming, algorithms, and data structures",
          courseCode: "CS101",
          credits: 3,
          duration: 12,
          difficulty: "beginner",
          prerequisites: [],
          learningObjectives: ["Learn basic programming concepts", "Understand algorithms", "Work with data structures"],
          price: "199.99"
        }
      ];

      await db.insert(courses).values(sampleCourses);

      // Create a sample banner
      const sampleBanner = {
        title: "Welcome to EduFiliova LMS",
        content: "Start your learning journey today with our comprehensive courses and expert instructors!",
        bannerType: "announcement",
        backgroundColor: "#3b82f6",
        textColor: "#ffffff",
        targetAudience: "all",
        createdBy: "system",
        isActive: true
      };

      await db.insert(banners).values(sampleBanner);

      res.json({ success: true, message: "Demo data seeded successfully" });
    } catch (error) {
      console.error('Demo seed error:', error);
      res.status(500).json({ success: false, error: "Failed to seed demo data" });
    }
  });

  // Subscription status endpoint
  app.get('/api/subscription-status', async (req, res) => {
    try {
      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userSession[0].userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      const profile = userProfile[0];
      const hasActiveSubscription = profile.stripeSubscriptionId !== null;

      if (!hasActiveSubscription) {
        return res.json({
          success: true,
          hasActiveSubscription: false,
          subscriptionStatus: 'inactive',
          message: 'No active subscription found'
        });
      }

      // If Stripe is configured, get subscription details
      if (stripe && profile.stripeSubscriptionId) {
        try {
          const subscription = await stripe.subscriptions.retrieve(profile.stripeSubscriptionId);
          return res.json({
            success: true,
            hasActiveSubscription: subscription.status === 'active',
            subscriptionStatus: subscription.status,
            currentPeriodEnd: subscription.current_period_end,
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
            priceId: subscription.items.data[0]?.price.id
          });
        } catch (stripeError) {
          console.error('Stripe subscription fetch error:', stripeError);
          return res.json({
            success: true,
            hasActiveSubscription: false,
            subscriptionStatus: 'error',
            message: 'Could not verify subscription status'
          });
        }
      }

      return res.json({
        success: true,
        hasActiveSubscription: true,
        subscriptionStatus: 'active',
        message: 'Subscription active (Stripe not configured)'
      });

    } catch (error) {
      console.error('Subscription status error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch subscription status' 
      });
    }
  });

  // Cancel subscription endpoint
  app.post('/api/cancel-subscription', async (req, res) => {
    try {
      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userSession[0].userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      const profile = userProfile[0];

      if (!profile.stripeSubscriptionId) {
        return res.status(400).json({ 
          success: false, 
          error: 'No active subscription to cancel' 
        });
      }

      // Cancel subscription with Stripe
      if (stripe) {
        try {
          const subscription = await stripe.subscriptions.update(
            profile.stripeSubscriptionId,
            { cancel_at_period_end: true }
          );

          return res.json({
            success: true,
            message: 'Subscription will be cancelled at the end of your current billing period',
            cancelAtPeriodEnd: subscription.cancel_at_period_end,
            currentPeriodEnd: subscription.current_period_end
          });
        } catch (stripeError) {
          console.error('Stripe cancellation error:', stripeError);
          return res.status(500).json({
            success: false,
            error: 'Failed to cancel subscription with payment provider'
          });
        }
      }

      return res.status(500).json({
        success: false,
        error: 'Payment provider not configured'
      });

    } catch (error) {
      console.error('Cancel subscription error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to cancel subscription' 
      });
    }
  });

  // Update profile endpoint
  app.put('/api/profile/update', async (req, res) => {
    try {
      const { name, age, grade, country, educationLevel } = req.body;

      // Check if user is logged in via session
      const sessionId = req.headers['x-session-id'] || req.cookies.sessionId;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'Not authenticated' });
      }

      // Get user from session
      const userSession = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid session' });
      }

      // Validate input
      if (!name || !age || !grade || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Update profile
      const updatedProfile = await db.update(profiles)
        .set({
          name,
          age: parseInt(age),
          grade: parseInt(grade),
          country,
          educationLevel: educationLevel || 'grade',
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userSession[0].userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Profile updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update profile' 
      });
    }
  });

  // Complete survey endpoint - first-time profile completion
  app.post('/api/profile/complete-survey', async (req, res) => {
    try {
      const { userId, country, countryId, educationLevel, grade, pronouns, avatarUrl } = req.body;

      // Validate required fields
      if (!userId || !country || !educationLevel) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Update the profile with survey data
      const updatedProfile = await db.update(profiles)
        .set({
          country,
          countryId: countryId || null,
          educationLevel,
          grade: grade && !isNaN(parseInt(grade)) ? parseInt(grade) : 0,
          pronouns: pronouns || null,
          avatarUrl: avatarUrl || null,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Survey completed successfully',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Survey completion error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to complete survey' 
      });
    }
  });

  // Update user grade/education level (with premium restriction)
  app.post('/api/profile/update-grade', async (req, res) => {
    try {
      const { userId, grade, educationLevel } = req.body;

      // Validate required fields
      if (!userId || (!grade && !educationLevel)) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Get current user profile to check premium status
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      const userProfile = profile[0];
      const currentTime = new Date();

      // Check if user has active premium subscription
      const hasActivePremium = userProfile.plan && 
        userProfile.plan !== '' && 
        userProfile.planExpiry && 
        userProfile.planExpiry > currentTime;

      // Only premium users can change grade/education level
      if (!hasActivePremium) {
        return res.status(403).json({
          success: false,
          error: 'Premium subscription required',
          message: 'Only users with an active premium subscription can change their grade or education level. Please upgrade to continue.',
          requiredAction: 'upgrade',
          restrictions: [
            'Change grade level',
            'Switch education systems', 
            'Access advanced courses',
            'Download course materials'
          ]
        });
      }

      // Update the user's grade/education level
      const updateData: any = { updatedAt: new Date() };
      if (grade !== undefined) updateData.grade = parseInt(grade);
      if (educationLevel !== undefined) updateData.educationLevel = educationLevel;

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      res.json({
        success: true,
        message: 'Grade/education level updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Grade update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update grade/education level' 
      });
    }
  });

  // Update profile cover image
  app.post('/api/profile/cover-image', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { coverImageUrl } = req.body;
      const userId = req.user!.id;

      // Validate cover image URL
      if (!coverImageUrl || typeof coverImageUrl !== 'string') {
        return res.status(400).json({ 
          success: false, 
          error: 'Valid cover image URL is required' 
        });
      }

      // Update the profile with new cover image
      const updatedProfile = await db.update(profiles)
        .set({
          coverImageUrl,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Cover image updated successfully',
        coverImageUrl: updatedProfile[0].coverImageUrl
      });

    } catch (error) {
      console.error('Cover image update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update cover image' 
      });
    }
  });

  // Remove profile cover image
  app.delete('/api/profile/cover-image', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;

      // Remove cover image from profile
      const updatedProfile = await db.update(profiles)
        .set({
          coverImageUrl: null,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Cover image removed successfully'
      });

    } catch (error) {
      console.error('Cover image removal error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to remove cover image' 
      });
    }
  });

  // Upgrade to Student Account
  app.post('/api/profile/upgrade-to-student', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { gradeLevel, school, educationLevel, country, interests } = req.body;

      // Validate required fields
      if (!gradeLevel || !school || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Grade level, school, and country are required' 
        });
      }

      // Update profile to student role with student-specific fields
      const updateData: any = {
        role: 'student',
        gradeLevel,
        educationLevel: educationLevel || 'grade',
        country,
        updatedAt: new Date()
      };

      // Parse grade number from grade level
      const gradeNum = parseInt(gradeLevel);
      if (!isNaN(gradeNum)) {
        updateData.grade = gradeNum;
      } else if (gradeLevel === 'college') {
        updateData.grade = 13;
      } else if (gradeLevel === 'university') {
        updateData.grade = 14;
      }

      // Add interests to bio if provided
      if (interests) {
        updateData.bio = interests;
      }

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Successfully upgraded to student account',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Upgrade to student error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to upgrade to student account' 
      });
    }
  });

  // Upgrade to Freelancer Account
  app.post('/api/profile/upgrade-to-freelancer', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const { professionalTitle, skills, experience, portfolio, bio, country } = req.body;

      // Validate required fields
      if (!professionalTitle || !skills || !bio || !country) {
        return res.status(400).json({ 
          success: false, 
          error: 'Professional title, skills, bio, and country are required' 
        });
      }

      // Parse portfolio links if provided (comma-separated)
      let portfolioLinks: string[] = [];
      if (portfolio && portfolio.trim()) {
        portfolioLinks = portfolio.split(',').map((link: string) => link.trim()).filter((link: string) => link);
      }

      // Parse skills (comma-separated or newline-separated)
      let skillsArray: string[] = [];
      if (skills && skills.trim()) {
        skillsArray = skills.split(/[,\n]/).map((skill: string) => skill.trim()).filter((skill: string) => skill);
      }

      // Update profile to freelancer role with freelancer-specific fields
      const updateData: any = {
        role: 'freelancer',
        professionalTitle,
        skills: skillsArray,
        bio,
        location: country,
        country,
        updatedAt: new Date(),
        approvalStatus: 'pending' // Freelancers may need approval
      };

      if (portfolioLinks.length > 0) {
        updateData.portfolioLinks = portfolioLinks;
      }

      if (experience) {
        const yearsExp = parseInt(experience);
        if (!isNaN(yearsExp)) {
          updateData.yearsOfExperience = yearsExp;
          updateData.experience = `${yearsExp} years of experience`;
        }
      }

      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Successfully upgraded to freelancer account',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Upgrade to freelancer error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to upgrade to freelancer account' 
      });
    }
  });

  // Update user plan endpoint
  app.post('/api/profile/update-plan', async (req, res) => {
    try {
      const { userId, plan, planName, billingCycle, lastPricingShown } = req.body;

      // Validate required fields
      if (!userId || !plan) {
        return res.status(400).json({ 
          success: false, 
          error: 'Missing required fields' 
        });
      }

      // Build update object
      const updateData: any = {
        plan,
        updatedAt: new Date()
      };

      // Add lastPricingShown if provided
      if (lastPricingShown) {
        updateData.lastPricingShown = new Date(lastPricingShown);
      }

      // Update the user's plan
      const updatedProfile = await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, userId))
        .returning();

      if (updatedProfile.length === 0) {
        return res.status(404).json({ 
          success: false, 
          error: 'Profile not found' 
        });
      }

      res.json({
        success: true,
        message: 'Plan updated successfully',
        profile: updatedProfile[0]
      });

    } catch (error) {
      console.error('Plan update error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to update plan' 
      });
    }
  });

  // ======================= STRIPE PAYMENT ROUTES =======================
  
  // Create subscription for education levels
  app.post('/api/create-subscription', requireAuth, async (req, res) => {
    const stripe = await getStripeInstance();
    if (!stripe) {
      return res.status(500).json({ error: 'Stripe not configured' });
    }

    try {
      const { planType, courseId, billingCycle = 'monthly' } = req.body;
      
      // SECURITY: Use authenticated user ID from session, never trust client
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }
      
      // Validate billing cycle
      if (!['monthly', 'yearly'].includes(billingCycle)) {
        return res.status(400).json({ error: 'Invalid billing cycle' });
      }

      // Get user profile
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ error: 'User profile not found' });
      }

      const profile = userProfile[0];

      // Grade-based subscription pricing with Stripe price IDs
      const gradePriceMap: { [key: string]: { priceId: { monthly: string, yearly: string }, pricing: { monthly: number, yearly: number }, type: string } } = {
        "elementary": { 
          priceId: { monthly: "price_elementary_monthly", yearly: "price_elementary_yearly" }, 
          pricing: { monthly: 5.99, yearly: 54.99 }, 
          type: "subscription" 
        },
        "high_school": { 
          priceId: { monthly: "price_high_school_monthly", yearly: "price_high_school_yearly" }, 
          pricing: { monthly: 9.99, yearly: 99.90 }, 
          type: "subscription" 
        },
        "college_university": { 
          priceId: { monthly: "price_college_university_monthly", yearly: "price_college_university_yearly" }, 
          pricing: { monthly: 39.00, yearly: 399.00 }, 
          type: "subscription" 
        }
      };

      const planDetails = gradePriceMap[planType];
      if (!planDetails) {
        return res.status(400).json({ error: 'Invalid subscription tier selected' });
      }

      // Get the correct Stripe price ID based on billing cycle
      const stripePriceId = planDetails.priceId[billingCycle as keyof typeof planDetails.priceId];
      const planAmount = planDetails.pricing[billingCycle as keyof typeof planDetails.pricing];

      let customer;
      
      // Check if customer exists
      if (profile.stripeCustomerId) {
        customer = await stripe.customers.retrieve(profile.stripeCustomerId);
      } else {
        // Create new customer
        const user = await db.select()
          .from(users)
          .where(eq(users.id, userId))
          .limit(1);

        customer = await stripe.customers.create({
          email: user[0].email,
          name: profile.name,
        });

        // Update profile with customer ID
        await db.update(profiles)
          .set({ stripeCustomerId: customer.id })
          .where(eq(profiles.userId, userId));
      }

      if (planDetails.type === "subscription") {
        // Create recurring subscription for Primary/High School
        const subscription = await stripe.subscriptions.create({
          customer: customer.id,
          items: [{ price: planDetails.priceId }],
          payment_behavior: 'default_incomplete',
          payment_settings: { save_default_payment_method: 'on_subscription' },
          expand: ['latest_invoice.payment_intent'],
        });

        // Update profile with subscription details
        const planExpiry = new Date();
        planExpiry.setMonth(planExpiry.getMonth() + 1); // 1 month from now

        await db.update(profiles)
          .set({ 
            stripeSubscriptionId: subscription.id,
            plan: planType,
            subscriptionTier: planType === 'primary_basic' ? 'basic' : 'premium',
            planExpiry: planExpiry
          })
          .where(eq(profiles.userId, userId));

        res.json({
          subscriptionId: subscription.id,
          clientSecret: subscription.latest_invoice?.payment_intent?.client_secret,
          type: 'subscription',
          amount: planDetails.amount
        });
      } else {
        // Create one-time payment for College courses
        const paymentIntent = await stripe.paymentIntents.create({
          amount: Math.round(planDetails.amount * 100), // Convert to cents
          currency: 'usd',
          customer: customer.id,
          metadata: {
            plan_type: planType,
            user_id: userId,
            course_id: courseId || 'general'
          }
        });

        res.json({
          paymentIntentId: paymentIntent.id,
          clientSecret: paymentIntent.client_secret,
          type: 'one_time',
          amount: planDetails.amount
        });
      }
    } catch (error: any) {
      console.error('Subscription creation error:', error);
      res.status(500).json({ error: error.message });
    }
  });

  // Get pricing plans based on education level
  app.get('/api/pricing-plans/:educationLevel', async (req, res) => {
    try {
      const { educationLevel } = req.params;
      const { grade } = req.query;

      // Get appropriate pricing plan
      let planName = '';
      if (educationLevel === 'primary' || (grade && parseInt(grade as string) <= 7)) {
        planName = 'primary_basic';
      } else if (educationLevel === 'secondary' || (grade && parseInt(grade as string) > 7 && parseInt(grade as string) <= 12)) {
        planName = 'high_school_basic';
      } else if (educationLevel === 'college' || educationLevel === 'university') {
        planName = 'college_course';
      }

      const plan = await db.select()
        .from(pricingPlans)
        .where(eq(pricingPlans.name, planName))
        .limit(1);

      if (plan.length === 0) {
        return res.status(404).json({ error: 'No pricing plan found for this education level' });
      }

      res.json({
        success: true,
        plan: plan[0]
      });
    } catch (error: any) {
      console.error('Pricing plans error:', error);
      res.status(500).json({ error: 'Failed to fetch pricing plans' });
    }
  });

  // Check lesson access for user (REMOVED ALL RESTRICTIONS - OPEN ACCESS)
  app.get('/api/check-lesson-access/:userId/:subjectId/:lessonId', async (req, res) => {
    try {
      // Always return full access - no restrictions
      return res.json({
        success: true,
        hasAccess: true,
        reason: 'unrestricted_access'
      });
    } catch (error: any) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ error: 'Failed to check lesson access' });
    }
  });

  // Stripe webhook for payment confirmation
  app.post('/api/stripe/webhook', express.raw({type: 'application/json'}), async (req, res) => {
    const stripe = await getStripeInstance();
    if (!stripe) {
      return res.status(500).json({ error: 'Stripe not configured' });
    }

    try {
      const sig = req.headers['stripe-signature'];
      let event;

      // Verify webhook signature (add your endpoint secret)
      // event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET);

      // For now, parse the event directly (in production, always verify signature)
      event = JSON.parse(req.body);

      switch (event.type) {
        case 'customer.subscription.created':
        case 'customer.subscription.updated':
        case 'invoice.payment_succeeded':
          const invoice = event.data.object;
          const customerId = invoice.customer;
          const subscriptionId = invoice.subscription;

          // Find user by Stripe customer ID
          const userProfile = await db.select()
            .from(profiles)
            .where(eq(profiles.stripeCustomerId, customerId))
            .limit(1);

          if (userProfile.length > 0) {
            const profile = userProfile[0];
            
            // Get subscription details from Stripe
            const subscription = await stripe.subscriptions.retrieve(subscriptionId);
            
            // Determine plan type based on subscription price
            let planType = 'primary_basic';
            if (subscription.items.data[0]?.price?.id === 'price_highschool_999') {
              planType = 'high_school_basic';
            } else if (subscription.items.data[0]?.price?.id === 'price_primary_5') {
              planType = 'primary_basic';
            }

            // Update subscription status with proper expiry date
            const planExpiry = new Date(subscription.current_period_end * 1000);

            await db.update(profiles)
              .set({ 
                plan: planType,
                subscriptionTier: 'premium',
                planExpiry: planExpiry,
                stripeSubscriptionId: subscription.id
              })
              .where(eq(profiles.userId, profile.userId));
          }
          break;

        case 'customer.subscription.deleted':
          const deletedSubscription = event.data.object;
          const deletedCustomerId = deletedSubscription.customer;

          // Cancel user's subscription
          const deletedUserProfile = await db.select()
            .from(profiles)
            .where(eq(profiles.stripeCustomerId, deletedCustomerId))
            .limit(1);

          if (deletedUserProfile.length > 0) {
            await db.update(profiles)
              .set({ 
                plan: '',
                subscriptionTier: 'free',
                planExpiry: null,
                stripeSubscriptionId: null
              })
              .where(eq(profiles.userId, deletedUserProfile[0].userId));
          }
          break;

        case 'payment_intent.succeeded':
          const paymentIntent = event.data.object;
          const planType = paymentIntent.metadata?.plan_type;
          const userId = paymentIntent.metadata?.user_id;

          if (planType === 'college_course' && userId) {
            // For one-time college course payments, give lifetime access to that course
            const courseExpiry = new Date();
            courseExpiry.setFullYear(courseExpiry.getFullYear() + 10); // 10 years access

            await db.update(profiles)
              .set({ 
                plan: 'college_course',
                subscriptionTier: 'premium',
                planExpiry: courseExpiry
              })
              .where(eq(profiles.userId, userId));
          }
          break;
      }

      res.json({received: true});
    } catch (error: any) {
      console.error('Webhook error:', error);
      res.status(500).json({ error: 'Webhook failed' });
    }
  });

  // ======================= DASHBOARD ROUTES =======================
  
  // Check lesson access based on subscription and education level (UNRESTRICTED ACCESS)
  app.get("/api/check-lesson-access/:userId/:subjectId/:lessonId", async (req, res) => {
    try {
      // Always return full access - no restrictions
      return res.json({
        success: true,
        hasAccess: true,
        reason: 'unrestricted_access'
      });
    } catch (error: any) {
      console.error('Lesson access check error:', error);
      res.status(500).json({ error: 'Failed to check lesson access' });
    }
  });

  // Check subject progress (for dashboard)
  app.get("/api/check-lesson-access/:userId/:subjectId/check", async (req, res) => {
    try {
      const { userId, subjectId } = req.params;

      // Count lessons accessed in this subject
      const accessedLessons = await db.select({ count: sql<number>`count(*)` })
        .from(studentProgress)
        .where(and(
          eq(studentProgress.userId, userId),
          eq(studentProgress.subjectId, subjectId),
          isNotNull(studentProgress.completedAt)
        ));

      const lessonsAccessed = accessedLessons[0]?.count || 0;

      res.json({
        success: true,
        accessedLessons: lessonsAccessed
      });

    } catch (error) {
      console.error('Subject progress check error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to check subject progress' 
      });
    }
  });
  
  // Get student dashboard data
  app.get("/api/dashboard/student", async (req, res) => {
    try {
      const sessionId = req.headers['x-session-id'] as string;
      if (!sessionId) {
        return res.status(401).json({ success: false, error: 'No session ID provided' });
      }

      // Verify session and get user
      const userSession = await db.select({
        userId: userLoginSessions.userId,
        sessionId: userLoginSessions.sessionId,
        expiresAt: userLoginSessions.expiresAt,
      })
      .from(userLoginSessions)
      .where(and(
        eq(userLoginSessions.sessionId, sessionId),
        eq(userLoginSessions.isActive, true),
        gt(userLoginSessions.expiresAt, new Date())
      ))
      .limit(1);

      if (userSession.length === 0) {
        return res.status(401).json({ success: false, error: 'Invalid or expired session' });
      }

      // Get user profile
      const profile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, userSession[0].userId))
        .limit(1);

      if (profile.length === 0) {
        return res.status(404).json({ success: false, error: 'Profile not found' });
      }

      // Get student progress for courses
      const progress = await db.select()
        .from(studentProgress)
        .where(eq(studentProgress.userId, userSession[0].userId))
        .limit(20);

      // Get user's tasks/assignments
      const assignments = await db.select()
        .from(tasks)
        .where(eq(tasks.userId, userSession[0].userId))
        .orderBy(desc(tasks.createdAt))
        .limit(10);

      res.json({
        success: true,
        data: {
          profile: profile[0],
          subjects: [], // No subjects available
          progress: progress,
          assignments: assignments
        }
      });

    } catch (error) {
      console.error('Dashboard data error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch dashboard data' });
    }
  });

  // ======================= MESSAGING ROUTES =======================
  
  // Get user profile with role for messaging permissions (handles profile UUIDs, auth UUIDs, and text user IDs)
  const getUserWithProfile = async (userIdOrTextId: string) => {
    try {
      // First try to find by text user ID (like "ADMIN00001", "HJOR2AC54I")
      const textIdResult = await db.select({
        id: users.id,
        userId: users.userId,     // Text ID field (for permission checks)
        textUserId: users.userId, // Text ID field
        name: profiles.name,
        role: profiles.role,
        pronouns: profiles.pronouns,
        avatarUrl: profiles.avatarUrl,
        verificationBadge: profiles.verificationBadge
      })
      .from(users)
      .innerJoin(profiles, eq(users.id, profiles.userId))
      .where(eq(users.userId, userIdOrTextId))
      .limit(1);
      
      if (textIdResult.length > 0) {
        const user = textIdResult[0];
        // Auto-assign blue badge for accountant and customer_service roles
        if (user.role === 'accountant' || user.role === 'customer_service') {
          user.verificationBadge = 'blue';
        }
        return user;
      }
      
      // Try by profile UUID (for conversations API)
      const profileResult = await db.select({
        id: users.id,
        userId: users.userId,     // Text ID field (for permission checks)
        textUserId: users.userId, // Text ID field
        name: profiles.name,
        role: profiles.role,
        pronouns: profiles.pronouns,
        avatarUrl: profiles.avatarUrl,
        verificationBadge: profiles.verificationBadge
      })
      .from(profiles)
      .innerJoin(users, eq(profiles.userId, users.id))
      .where(eq(profiles.id, userIdOrTextId))
      .limit(1);
      
      if (profileResult.length > 0) {
        const user = profileResult[0];
        // Auto-assign blue badge for accountant and customer_service roles
        if (user.role === 'accountant' || user.role === 'customer_service') {
          user.verificationBadge = 'blue';
        }
        return user;
      }
      
      // If not found by text ID or profile UUID, try with auth user UUID (for session compatibility)
      const uuidResult = await db.select({
        id: users.id,
        userId: users.userId,     // Text ID field (for permission checks)
        textUserId: users.userId, // Text ID field
        name: profiles.name,
        role: profiles.role,
        pronouns: profiles.pronouns,
        avatarUrl: profiles.avatarUrl,
        verificationBadge: profiles.verificationBadge
      })
      .from(users)
      .innerJoin(profiles, eq(users.id, profiles.userId))
      .where(eq(users.id, userIdOrTextId))
      .limit(1);
      
      if (uuidResult.length > 0 && uuidResult[0]) {
        const user = uuidResult[0];
        // Auto-assign blue badge for accountant and customer_service roles
        if (user.role === 'accountant' || user.role === 'customer_service') {
          user.verificationBadge = 'blue';
        }
        return user;
      }
      
      return null;
    } catch (error) {
      console.error('Error in getUserWithProfile:', error);
      return null;
    }
  };

  // Get available contacts based on role
  app.get("/api/messages/contacts", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const currentUser = await getUserWithProfile(session[0].userId);
      if (!currentUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      let contacts = [];

      if (currentUser.role === 'student' || currentUser.role === 'user') {
        // Students can see teachers, admins, and other students (with friendship status)
        const allContacts = await db.select({
          id: profiles.id, // Profile UUID for message matching
          authUserId: users.id, // Auth user UUID for friendship lookup
          userId: users.userId,
          name: profiles.name,
          role: profiles.role,
          pronouns: profiles.pronouns,
          avatarUrl: profiles.avatarUrl,
          isOnline: profiles.isOnline,
          lastSeen: profiles.lastSeen,
          verificationBadge: profiles.verificationBadge
        })
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(
          or(eq(profiles.role, 'teacher'), eq(profiles.role, 'admin'), eq(profiles.role, 'student'), eq(profiles.role, 'user')),
          ne(users.userId, currentUser.userId) // Exclude current user
        ));

        // Get current user's auth UUID for friendship lookup
        const currentUserAuth = await db.select({ id: users.id })
          .from(users)
          .where(eq(users.userId, currentUser.userId))
          .limit(1);
        
        const currentUserAuthId = currentUserAuth[0]?.id;

        // For each contact, check friendship status
        contacts = await Promise.all(allContacts.map(async (contact) => {
          let friendshipStatus = 'none';
          
          // Only check friendship for student-to-student relationships (including 'user' role)
          if ((contact.role === 'student' || contact.role === 'user') && currentUserAuthId) {
            const friendship = await db.select({ status: friendships.status })
              .from(friendships)
              .where(and(
                or(
                  and(eq(friendships.requesterId, currentUserAuthId), eq(friendships.receiverId, contact.authUserId)),
                  and(eq(friendships.requesterId, contact.authUserId), eq(friendships.receiverId, currentUserAuthId))
                )
              ))
              .limit(1);
            
            if (friendship.length > 0) {
              friendshipStatus = friendship[0].status;
            }
          } else {
            // Teachers and admins are always "accessible" 
            friendshipStatus = 'accessible';
          }

          return {
            ...contact,
            friendshipStatus
          };
        }));

      } else if (currentUser.role === 'teacher') {
        // Teachers only see admins and students who have messaged them
        // First get all admins (support is always visible)
        const adminContacts = await db.select({
          id: profiles.id, // Profile UUID for message matching
          userId: users.userId,
          name: profiles.name,
          role: profiles.role,
          pronouns: profiles.pronouns,
          avatarUrl: profiles.avatarUrl,
          isOnline: profiles.isOnline,
          lastSeen: profiles.lastSeen,
          verificationBadge: profiles.verificationBadge
        })
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(
          eq(profiles.role, 'admin'),
          ne(users.userId, currentUser.userId) // Exclude current user
        ));

        // Get current teacher's profile UUID for message lookup
        const currentTeacherProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, currentUser.id))
          .limit(1);

        const currentTeacherProfileId = currentTeacherProfile[0]?.id;

        // Get students who have sent messages to this teacher
        const studentMessages = await db.select({
          senderId: messages.senderId,
          receiverId: messages.receiverId
        })
        .from(messages)
        .where(and(
          or(
            eq(messages.receiverId, currentTeacherProfileId), // Messages sent TO teacher
            eq(messages.senderId, currentTeacherProfileId)    // Messages sent FROM teacher
          )
        ));

        // Extract unique student profile IDs who have conversation with this teacher
        const studentProfileIds = new Set();
        studentMessages.forEach(msg => {
          if (msg.senderId !== currentTeacherProfileId) {
            studentProfileIds.add(msg.senderId);
          }
          if (msg.receiverId !== currentTeacherProfileId) {
            studentProfileIds.add(msg.receiverId);
          }
        });

        // Get student contacts who have messaged this teacher
        let studentContacts = [];
        if (studentProfileIds.size > 0) {
          studentContacts = await db.select({
            id: profiles.id, // Profile UUID for message matching
            userId: users.userId,
            name: profiles.name,
            role: profiles.role,
            pronouns: profiles.pronouns,
            avatarUrl: profiles.avatarUrl,
            isOnline: profiles.isOnline,
            lastSeen: profiles.lastSeen,
            verificationBadge: profiles.verificationBadge
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(and(
            or(eq(profiles.role, 'student'), eq(profiles.role, 'user')),
            inArray(profiles.id, Array.from(studentProfileIds))
          ));
        }

        // Combine admin contacts and student contacts who have messaged teacher
        const allContacts = [...adminContacts, ...studentContacts];

        // Teachers can message these contacts, so all are accessible
        contacts = allContacts.map(contact => ({
          ...contact,
          friendshipStatus: 'accessible'
        }));

      } else if (currentUser.role === 'admin') {
        // Admins can see everyone
        const allContacts = await db.select({
          id: profiles.id, // Profile UUID for message matching
          userId: users.userId,
          name: profiles.name,
          role: profiles.role,
          pronouns: profiles.pronouns,
          avatarUrl: profiles.avatarUrl,
          isOnline: profiles.isOnline,
          lastSeen: profiles.lastSeen,
          verificationBadge: profiles.verificationBadge
        })
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(ne(users.userId, currentUser.userId));

        // Admins can message anyone, so all contacts are accessible
        contacts = allContacts.map(contact => ({
          ...contact,
          friendshipStatus: 'accessible'
        }));
      } else if (currentUser.role === 'freelancer') {
        // Freelancers only see users they have had conversations with
        // Get current freelancer's profile UUID for message lookup
        const currentFreelancerProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, currentUser.id))
          .limit(1);

        const currentFreelancerProfileId = currentFreelancerProfile[0]?.id;

        // Get all users who have sent or received messages from this freelancer
        const conversationMessages = await db.select({
          senderId: messages.senderId,
          receiverId: messages.receiverId
        })
        .from(messages)
        .where(and(
          or(
            eq(messages.receiverId, currentFreelancerProfileId), // Messages sent TO freelancer
            eq(messages.senderId, currentFreelancerProfileId)    // Messages sent FROM freelancer
          )
        ));

        // Extract unique profile IDs who have conversation with this freelancer
        const conversationProfileIds = new Set();
        conversationMessages.forEach(msg => {
          if (msg.senderId !== currentFreelancerProfileId) {
            conversationProfileIds.add(msg.senderId);
          }
          if (msg.receiverId !== currentFreelancerProfileId) {
            conversationProfileIds.add(msg.receiverId);
          }
        });

        // Get contacts who have conversed with this freelancer
        let conversationContacts = [];
        if (conversationProfileIds.size > 0) {
          conversationContacts = await db.select({
            id: profiles.id, // Profile UUID for message matching
            userId: users.userId,
            name: profiles.name,
            role: profiles.role,
            pronouns: profiles.pronouns,
            avatarUrl: profiles.avatarUrl,
            isOnline: profiles.isOnline,
            lastSeen: profiles.lastSeen,
            verificationBadge: profiles.verificationBadge
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(inArray(profiles.id, Array.from(conversationProfileIds)));
        }

        // Freelancers can message these contacts, so all are accessible
        contacts = conversationContacts.map(contact => ({
          ...contact,
          friendshipStatus: 'accessible'
        }));
      } else if (currentUser.role === 'accountant' || currentUser.role === 'customer_service') {
        // Support staff see users they've conversed with, but can search and initiate with anyone
        // Get query params for filtering
        const roleFilter = req.query.roleFilter as string | undefined; // 'student', 'freelancer', 'teacher'
        const searchQuery = req.query.search as string | undefined;

        // Get current support staff's profile UUID for message lookup
        const currentSupportProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, currentUser.id))
          .limit(1);

        const currentSupportProfileId = currentSupportProfile[0]?.id;

        // Get users they've had conversations with
        const conversationMessages = await db.select({
          senderId: messages.senderId,
          receiverId: messages.receiverId
        })
        .from(messages)
        .where(and(
          or(
            eq(messages.receiverId, currentSupportProfileId),
            eq(messages.senderId, currentSupportProfileId)
          )
        ));

        const conversationProfileIds = new Set();
        conversationMessages.forEach(msg => {
          if (msg.senderId !== currentSupportProfileId) {
            conversationProfileIds.add(msg.senderId);
          }
          if (msg.receiverId !== currentSupportProfileId) {
            conversationProfileIds.add(msg.receiverId);
          }
        });

        // Build query conditions
        let queryConditions = [ne(users.userId, currentUser.userId)];
        
        // Add role filter if specified
        if (roleFilter) {
          queryConditions.push(eq(profiles.role, roleFilter));
        }

        // If searching, get all users matching search, otherwise only show conversations
        let allContacts;
        if (searchQuery && searchQuery.trim()) {
          // When searching, show all users matching the search (filtered by role if specified)
          queryConditions.push(
            or(
              sql`LOWER(${profiles.name}) LIKE LOWER(${`%${searchQuery}%`})`,
              sql`LOWER(${users.userId}) LIKE LOWER(${`%${searchQuery}%`})`
            )
          );
          
          allContacts = await db.select({
            id: profiles.id,
            userId: users.userId,
            name: profiles.name,
            role: profiles.role,
            pronouns: profiles.pronouns,
            avatarUrl: profiles.avatarUrl,
            isOnline: profiles.isOnline,
            lastSeen: profiles.lastSeen,
            verificationBadge: profiles.verificationBadge
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(and(...queryConditions));
        } else {
          // Without search, only show conversations (filtered by role if specified)
          if (conversationProfileIds.size > 0) {
            queryConditions.push(inArray(profiles.id, Array.from(conversationProfileIds)));
            
            allContacts = await db.select({
              id: profiles.id,
              userId: users.userId,
              name: profiles.name,
              role: profiles.role,
              pronouns: profiles.pronouns,
              avatarUrl: profiles.avatarUrl,
              isOnline: profiles.isOnline,
              lastSeen: profiles.lastSeen,
              verificationBadge: profiles.verificationBadge
            })
            .from(users)
            .innerJoin(profiles, eq(users.id, profiles.userId))
            .where(and(...queryConditions));
          } else {
            allContacts = [];
          }
        }

        // Support staff can message anyone, so all contacts are accessible
        contacts = (allContacts || []).map(contact => ({
          ...contact,
          friendshipStatus: 'accessible'
        }));
      }

      // Automatically assign blue badge to accountant and customer_service roles
      contacts = contacts.map(contact => ({
        ...contact,
        verificationBadge: (contact.role === 'accountant' || contact.role === 'customer_service') 
          ? 'blue' 
          : contact.verificationBadge
      }));

      console.log('ðŸ” Contacts API Debug:', {
        currentUserRole: currentUser.role,
        contactsFound: contacts.length,
        contacts: contacts.map(c => ({ userId: c.userId, role: c.role, name: c.name }))
      });
      
      res.json({ success: true, data: contacts });

    } catch (error) {
      console.error('Contacts fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch contacts" });
    }
  });

  // Get user profile details for friend request preview
  app.get("/api/users/:userId/profile-preview", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const { userId } = req.params;

      // Get user profile details including country info
      const userProfile = await db
        .select({
          userId: users.userId,
          name: profiles.name,
          avatarUrl: profiles.avatarUrl,
          role: profiles.role,
          pronouns: profiles.pronouns,
          bio: profiles.bio,
          age: profiles.age,
          grade: profiles.grade,
          country: profiles.country,
          educationLevel: profiles.educationLevel,
          createdAt: users.createdAt
        })
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(users.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      res.json({ success: true, data: userProfile[0] });

    } catch (error) {
      console.error('Profile preview fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch user profile" });
    }
  });

  // Get pending friend requests for messaging interface
  app.get("/api/messages/friend-requests", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const currentUser = await getUserWithProfile(session[0].userId);
      if (!currentUser) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Get pending friend requests where current user is the receiver
      const pendingRequests = await db.select({
        id: friendships.id,
        requesterId: friendships.requesterId,
        receiverId: friendships.receiverId,
        status: friendships.status,
        requestMessage: friendships.requestMessage,
        createdAt: friendships.createdAt,
        // Requester info
        requesterUserId: users.userId,
        requesterName: profiles.name,
        requesterAvatarUrl: profiles.avatarUrl,
        requesterRole: profiles.role
      })
      .from(friendships)
      .innerJoin(users, eq(friendships.requesterId, users.id))
      .innerJoin(profiles, eq(users.id, profiles.userId))
      .where(and(
        eq(friendships.receiverId, currentUser.id),
        eq(friendships.status, 'pending')
      ))
      .orderBy(desc(friendships.createdAt));

      res.json({ success: true, data: pendingRequests });

    } catch (error) {
      console.error('Pending friend requests fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch pending friend requests" });
    }
  });


  // Get conversations with unread counts
  app.get("/api/messages/conversations", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const authUserId = session[0].userId; // auth_users UUID
      
      // Get current user's profile UUID  
      const currentUserProfile = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, authUserId)).limit(1);
      if (currentUserProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User profile not found" });
      }
      const uuidUserId = currentUserProfile[0].id; // profile UUID

      // Get all conversations using profile UUID - select only needed columns
      const allMessages = await db
        .select({
          id: messages.id,
          senderId: messages.senderId,
          receiverId: messages.receiverId,
          content: messages.content,
          fileType: messages.fileType,
          readAt: messages.readAt,
          createdAt: messages.createdAt
        })
        .from(messages)
        .where(or(
          eq(messages.senderId, uuidUserId),
          eq(messages.receiverId, uuidUserId)
        ))
        .orderBy(desc(messages.createdAt));

      // Process conversations in JavaScript to avoid SQL complexity
      const conversationMap = new Map<string, {
        otherUserId: string;
        lastMessage: string;
        lastMessageTime: Date;
        unreadCount: number;
      }>();

      allMessages.forEach(msg => {
        const otherUserId = msg.senderId === uuidUserId ? msg.receiverId : msg.senderId;
        
        if (!conversationMap.has(otherUserId)) {
          conversationMap.set(otherUserId, {
            otherUserId,
            lastMessage: msg.content || (msg.fileType ? `Sent a ${msg.fileType}` : 'Message'),
            lastMessageTime: msg.createdAt,
            unreadCount: 0
          });
        }

        // Count unread messages
        if (msg.receiverId === uuidUserId && !msg.readAt) {
          const conv = conversationMap.get(otherUserId)!;
          conv.unreadCount++;
        }
      });

      const conversations = Array.from(conversationMap.values())
        .sort((a, b) => new Date(b.lastMessageTime).getTime() - new Date(a.lastMessageTime).getTime());

      // Get user details for each conversation
      const conversationDetails = await Promise.all(
        conversations.map(async (conv) => {
          // otherUserId is already a UUID since we changed the messages table  
          const otherUser = await getUserWithProfile(conv.otherUserId);
          return {
            ...conv,
            otherUser
          };
        })
      );


      res.json({ success: true, data: conversationDetails });

    } catch (error) {
      console.error('Conversations fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch conversations" });
    }
  });

  // Get unified conversations (regular + support chats) - NEW UNIFIED ENDPOINT
  app.get("/api/messages/unified-conversations", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const authUserId = session[0].userId; // auth_users UUID
      
      // Get current user's profile UUID  
      const currentUserProfile = await db.select({ 
        id: profiles.id, 
        role: profiles.role 
      }).from(profiles).where(eq(profiles.userId, authUserId)).limit(1);
      
      if (currentUserProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User profile not found" });
      }
      
      const uuidUserId = currentUserProfile[0].id; // profile UUID
      const userRole = currentUserProfile[0].role;

      const unifiedConversations = [];

      // 1. Get regular user conversations from messages table
      const allMessages = await db
        .select({
          id: messages.id,
          senderId: messages.senderId,
          receiverId: messages.receiverId,
          content: messages.content,
          fileType: messages.fileType,
          readAt: messages.readAt,
          createdAt: messages.createdAt
        })
        .from(messages)
        .where(or(
          eq(messages.senderId, uuidUserId),
          eq(messages.receiverId, uuidUserId)
        ))
        .orderBy(desc(messages.createdAt));

      // Process regular conversations
      const conversationMap = new Map<string, {
        id: string;
        type: 'direct' | 'group' | 'support';
        title: string;
        otherUserId: string;
        lastMessage: string;
        lastMessageTime: Date;
        unreadCount: number;
        avatarUrl?: string;
        participants?: any[];
      }>();

      allMessages.forEach(msg => {
        const otherUserId = msg.senderId === uuidUserId ? msg.receiverId : msg.senderId;
        const conversationId = `direct_${otherUserId}`;
        
        if (!conversationMap.has(conversationId)) {
          conversationMap.set(conversationId, {
            id: conversationId,
            type: 'direct',
            title: '', // Will be filled with user name later
            otherUserId,
            lastMessage: msg.content || (msg.fileType ? `Sent a ${msg.fileType}` : 'Message'),
            lastMessageTime: msg.createdAt,
            unreadCount: 0
          });
        }

        // Count unread messages
        if (msg.receiverId === uuidUserId && !msg.readAt) {
          const conv = conversationMap.get(conversationId)!;
          conv.unreadCount++;
        }
      });

      // 1.5. Get freelancer chat threads (for both freelancers and customers/users)
      const chatThreadsForUser = await db
        .select({
          id: chatThreads.id,
          freelancerId: chatThreads.freelancerId,
          customerId: chatThreads.customerId,
          lastMessageAt: chatThreads.lastMessageAt,
          lastMessagePreview: chatThreads.lastMessagePreview,
          status: chatThreads.status
        })
        .from(chatThreads)
        .where(or(
          eq(chatThreads.freelancerId, authUserId),
          eq(chatThreads.customerId, authUserId)
        ))
        .orderBy(desc(chatThreads.lastMessageAt));

      console.log('ðŸ” Chat threads found:', chatThreadsForUser.length);

      // Process chat threads and add to conversationMap
      for (const thread of chatThreadsForUser) {
        // Determine the other user (if current user is freelancer, other is customer, and vice versa)
        const otherUserId = thread.freelancerId === authUserId ? thread.customerId : thread.freelancerId;
        
        // Get the other user's profile UUID - fallback to auth UUID if profile doesn't exist
        const otherProfile = await db.select({ id: profiles.id })
          .from(profiles)
          .where(eq(profiles.userId, otherUserId))
          .limit(1);
        
        // Use profile UUID if exists, otherwise fall back to auth UUID
        // This ensures conversations with support/admin accounts (who may not have profiles) still appear
        const otherProfileUuid = otherProfile.length > 0 ? otherProfile[0].id : otherUserId;
        
        if (!otherProfileUuid) {
          console.warn(`âš ï¸ Skipping thread ${thread.id}: Could not resolve profile or auth UUID for user ${otherUserId}`);
          continue;
        }
        
        const conversationId = `direct_${otherProfileUuid}`;
        
        // Count unread messages for this thread
        const unreadMessages = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(messages)
          .where(and(
            eq(messages.threadId, thread.id),
            eq(messages.receiverId, uuidUserId),
            isNull(messages.readAt)
          ));
        
        const unreadCount = unreadMessages[0]?.count || 0;
        
        // Only add if not already in the map (to avoid duplicates from regular messages)
        // But update if we have more recent information from chatThreads
        const existingConv = conversationMap.get(conversationId);
        const threadLastMessageTime = thread.lastMessageAt || new Date(0);
        
        if (!existingConv || (existingConv && new Date(existingConv.lastMessageTime) < threadLastMessageTime)) {
          conversationMap.set(conversationId, {
            id: conversationId,
            type: 'direct',
            title: '', // Will be filled with user name later
            otherUserId: otherProfileUuid,
            lastMessage: thread.lastMessagePreview || 'Start a conversation',
            lastMessageTime: thread.lastMessageAt || new Date(),
            unreadCount: existingConv?.unreadCount || unreadCount
          });
          console.log(`âœ… Added/updated chat thread conversation: ${conversationId} (profile: ${otherProfile.length > 0 ? 'found' : 'using auth UUID'})`);
        }
      }

      // 2. Get support chat conversations (for admins and users who had support chats)
      if (userRole === 'admin') {
        // Admin: Get all active support sessions they're involved in
        const supportSessions = await db
          .select({
            id: supportChatSessions.id,
            guestId: supportChatSessions.guestId,
            assignedAgentId: supportChatSessions.assignedAgentId,
            adminTakenOver: supportChatSessions.adminTakenOver,
            adminUserId: supportChatSessions.adminUserId,
            lastActivityAt: supportChatSessions.lastActivityAt,
            isActive: supportChatSessions.isActive,
            // Get latest message for this session
            agentName: supportAgents.name,
            agentAvatar: supportAgents.avatarUrl
          })
          .from(supportChatSessions)
          .leftJoin(supportAgents, eq(supportChatSessions.assignedAgentId, supportAgents.id))
          .where(
            and(
              eq(supportChatSessions.isActive, true),
              or(
                eq(supportChatSessions.adminUserId, authUserId),
                isNull(supportChatSessions.adminUserId) // Available to be taken over
              )
            )
          )
          .orderBy(desc(supportChatSessions.lastActivityAt));

        // Get latest message for each support session
        for (const session of supportSessions) {
          const latestMessage = await db
            .select({
              message: helpChatMessages.message,
              createdAt: helpChatMessages.createdAt,
              sender: helpChatMessages.sender
            })
            .from(helpChatMessages)
            .where(eq(helpChatMessages.guestId, session.guestId))
            .orderBy(desc(helpChatMessages.createdAt))
            .limit(1);

          const conversationId = `support_${session.guestId}`;
          const lastMsg = latestMessage[0];
          
          conversationMap.set(conversationId, {
            id: conversationId,
            type: 'support',
            title: `Support Chat (${session.guestId.substring(0, 8)}...)`,
            otherUserId: session.guestId,
            lastMessage: lastMsg?.message || 'No messages yet',
            lastMessageTime: lastMsg?.createdAt || session.lastActivityAt,
            unreadCount: 0, // TODO: Implement support chat unread counts
            avatarUrl: session.agentAvatar || '/default-support-avatar.png'
          });
        }
      } else {
        // Regular users (students, teachers, freelancers): Add Support and Tech Support contacts
        console.log('ðŸ” Adding support contacts for user role:', userRole);
        
        // Add Support contact (ADMIN00001)
        const supportAdmin = await db
          .select({
            id: profiles.id,
            name: profiles.name,
            avatarUrl: profiles.avatarUrl,
            userId: users.userId
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(eq(users.userId, 'ADMIN00001'))
          .limit(1);

        console.log('ðŸ” Support admin found:', supportAdmin.length > 0 ? supportAdmin[0] : 'Not found');

        if (supportAdmin.length > 0) {
          const supportConversationId = `direct_${supportAdmin[0].id}`;
          conversationMap.set(supportConversationId, {
            id: supportConversationId,
            type: 'direct',
            title: supportAdmin[0].name || 'Support',
            otherUserId: supportAdmin[0].id,
            lastMessage: 'Chat with our support team',
            lastMessageTime: new Date(),
            unreadCount: 0,
            avatarUrl: supportAdmin[0].avatarUrl || '/default-support-avatar.png'
          });
          console.log('âœ… Added Support contact to conversations');
        }

        // Add Tech Support contact (ADMIN00002)
        const techSupportAdmin = await db
          .select({
            id: profiles.id,
            name: profiles.name,
            avatarUrl: profiles.avatarUrl,
            userId: users.userId
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(eq(users.userId, 'ADMIN00002'))
          .limit(1);

        console.log('ðŸ” Tech Support admin found:', techSupportAdmin.length > 0 ? techSupportAdmin[0] : 'Not found');

        if (techSupportAdmin.length > 0) {
          const techSupportConversationId = `direct_${techSupportAdmin[0].id}`;
          conversationMap.set(techSupportConversationId, {
            id: techSupportConversationId,
            type: 'direct',
            title: techSupportAdmin[0].name || 'Tech Support',
            otherUserId: techSupportAdmin[0].id,
            lastMessage: 'Get technical assistance',
            lastMessageTime: new Date(),
            unreadCount: 0,
            avatarUrl: techSupportAdmin[0].avatarUrl || '/src/assets/tech-support-logo.jpg'
          });
          console.log('âœ… Added Tech Support contact to conversations');
        }
      }

      // Convert map to array and get user details
      const conversations = Array.from(conversationMap.values())
        .sort((a, b) => new Date(b.lastMessageTime).getTime() - new Date(a.lastMessageTime).getTime());

      console.log('ðŸ” Total conversations before user details:', conversations.length);
      console.log('ðŸ” Conversation types:', conversations.map(c => ({ id: c.id, type: c.type, title: c.title })));

      // Get user details for direct conversations
      const conversationDetails = await Promise.all(
        conversations.map(async (conv) => {
          if (conv.type === 'direct') {
            const otherUser = await getUserWithProfile(conv.otherUserId);
            console.log('ðŸ” Processing conversation:', conv.id, 'otherUser:', otherUser ? { name: otherUser.name, role: otherUser.role } : 'Not found');
            return {
              ...conv,
              title: conv.title || otherUser?.name || 'Unknown User', // Keep existing title for support contacts
              avatarUrl: conv.avatarUrl || otherUser?.avatarUrl || '/default-avatar.png',
              otherUser
            };
          }
          return conv; // Support conversations already have title and avatar
        })
      );

      console.log('ðŸ” Final conversation details to send:', conversationDetails.map(c => ({ id: c.id, title: c.title, type: c.type })));

      res.json({ success: true, data: conversationDetails });

    } catch (error) {
      console.error('Unified conversations fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch unified conversations" });
    }
  });

  // Get messages for a specific conversation
  app.get("/api/messages/conversation/:otherUserId", async (req, res) => {
    try {
      let { otherUserId } = req.params;
      const { page = 1, limit = 50 } = req.query;
      
      // Strip conversation ID prefixes (direct_, support_, etc.)
      if (otherUserId.startsWith('direct_')) {
        otherUserId = otherUserId.replace('direct_', '');
      } else if (otherUserId.startsWith('support_')) {
        otherUserId = otherUserId.replace('support_', '');
      }
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const authUserId = session[0].userId; // This is auth_users UUID
      
      // Get current user's profile UUID
      const currentUserProfile = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, authUserId)).limit(1);
      if (currentUserProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User profile not found" });
      }
      const userId = currentUserProfile[0].id; // This is profile UUID
      
      // Convert otherUserId from text ID to profile UUID
      let otherUserUuid;
      if (otherUserId.length === 36 && otherUserId.includes('-')) {
        // It's already a UUID, check if it's profile UUID or auth UUID
        const profileCheck = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.id, otherUserId)).limit(1);
        if (profileCheck.length > 0) {
          otherUserUuid = otherUserId; // It's a profile UUID
        } else {
          // It might be an auth UUID, convert to profile UUID
          const profileByAuth = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, otherUserId)).limit(1);
          if (profileByAuth.length === 0) {
            return res.status(404).json({ success: false, error: "User profile not found" });
          }
          otherUserUuid = profileByAuth[0].id;
        }
      } else {
        // It's a text ID, convert to profile UUID
        const otherAuthUser = await db.select({ id: users.id }).from(users).where(eq(users.userId, otherUserId)).limit(1);
        if (otherAuthUser.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        const otherProfile = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, otherAuthUser[0].id)).limit(1);
        if (otherProfile.length === 0) {
          return res.status(404).json({ success: false, error: "User profile not found" });
        }
        otherUserUuid = otherProfile[0].id;
      }
      
      console.log('ðŸ” Conversation Debug:', {
        currentUserId: userId,
        otherUserId: otherUserId,
        otherUserUuid: otherUserUuid,
        isCurrentUserUuid: userId.length === 36 && userId.includes('-'),
        isOtherUserUuid: otherUserUuid.length === 36 && otherUserUuid.includes('-')
      });
      
      // Get messages between the two users using UUID format - select only needed columns
      const conversationMessages = await db.select({
        id: messages.id,
        senderId: messages.senderId,
        receiverId: messages.receiverId,
        content: messages.content,
        messageType: messages.messageType,
        fileUrl: messages.fileUrl,
        fileType: messages.fileType,
        isRead: messages.isRead,
        deliveredAt: messages.deliveredAt,
        readAt: messages.readAt,
        createdAt: messages.createdAt
      })
        .from(messages)
        .where(or(
          and(eq(messages.senderId, userId), eq(messages.receiverId, otherUserUuid)),
          and(eq(messages.senderId, otherUserUuid), eq(messages.receiverId, userId))
        ))
        .orderBy(messages.createdAt) // Order oldest first for proper chat chronology
        .limit(Number(limit))
        .offset((Number(page) - 1) * Number(limit));
        
      console.log('ðŸ” Query result:', {
        messageCount: conversationMessages.length,
        queryParams: { userId, otherUserUuid, page, limit },
        firstMessage: conversationMessages[0] ? {
          id: conversationMessages[0].id,
          content: conversationMessages[0].content?.substring(0, 50) + '...',
          senderId: conversationMessages[0].senderId,
          receiverId: conversationMessages[0].receiverId
        } : null
      });

      // Mark messages as read
      await db.update(messages)
        .set({ readAt: new Date() })
        .where(and(
          eq(messages.senderId, otherUserUuid),
          eq(messages.receiverId, userId),
          isNull(messages.readAt)
        ));

      // Transform messages to include fileMetadata for media messages
      const transformedMessages = conversationMessages.map(msg => ({
        ...msg,
        fileMetadata: msg.fileUrl && msg.fileType ? {
          url: msg.fileUrl,
          fileName: msg.content || `${msg.fileType}-file`,
          fileSize: 0, // Size not stored in current schema
          mimeType: getMimeTypeFromFileType(msg.fileType)
        } : null
      }));

      console.log('ðŸ“¤ Sending response with', transformedMessages.length, 'messages');
      res.json({ success: true, data: transformedMessages });

    } catch (error) {
      console.error('Conversation messages fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch conversation messages" });
    }
  });

  // Clear chat history for a specific conversation
  app.delete("/api/messages/conversation/:otherUserId", async (req, res) => {
    try {
      const { otherUserId } = req.params;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Convert otherUserId from text ID to UUID if needed
      let otherUserUuid;
      if (otherUserId.length === 36 && otherUserId.includes('-')) {
        // It's already a UUID
        otherUserUuid = otherUserId;
      } else {
        // It's a text ID, convert to UUID
        const otherUserRecord = await db.select({ id: users.id }).from(users).where(eq(users.userId, otherUserId)).limit(1);
        if (otherUserRecord.length === 0) {
          return res.status(404).json({ success: false, error: "User not found" });
        }
        otherUserUuid = otherUserRecord[0].id;
      }
      
      // Delete all messages between the two users
      await db.delete(messages)
        .where(or(
          and(eq(messages.senderId, userId), eq(messages.receiverId, otherUserUuid)),
          and(eq(messages.senderId, otherUserUuid), eq(messages.receiverId, userId))
        ));

      res.json({ success: true, message: "Chat history cleared successfully" });

    } catch (error) {
      console.error('Clear chat error:', error);
      res.status(500).json({ success: false, error: "Failed to clear chat history" });
    }
  });

  // Check messaging permissions helper
  const checkMessagingPermissions = async (sender: any, receiver: any) => {
    if (sender.role === 'admin') {
      return true; // Admins can message anyone
    }
    
    // Accountant and customer service can message anyone
    if (sender.role === 'accountant' || sender.role === 'customer_service') {
      return true; // Support staff can message anyone
    }
    
    // Anyone can message accountant or customer service for support
    if (receiver.role === 'accountant' || receiver.role === 'customer_service') {
      return true; // Anyone can contact support staff
    }
    
    if ((sender.role === 'student' || sender.role === 'user') && receiver.role === 'admin') {
      return true; // Students/users can message admin for support
    }
    
    if ((sender.role === 'student' || sender.role === 'user') && receiver.role === 'teacher') {
      return true; // Students/users can message teachers
    }
    
    if (sender.role === 'teacher' && (receiver.role === 'student' || receiver.role === 'user')) {
      // Teachers can message any student or user - no restrictions
      return true;
    }
    
    if (sender.role === 'teacher' && receiver.role === 'teacher') {
      return true; // Teachers can message other teachers
    }
    
    if (sender.role === 'teacher' && receiver.role === 'admin') {
      return true; // Teachers can message admin
    }
    
    // Freelancer permissions
    if (sender.role === 'freelancer' && receiver.role === 'admin') {
      return true; // Freelancers can message admins for support
    }
    
    if (sender.role === 'freelancer' && receiver.role === 'teacher') {
      return true; // Freelancers can message teachers
    }
    
    if ((receiver.role === 'freelancer') && (sender.role === 'student' || sender.role === 'user')) {
      return true; // Students/users can contact freelancers
    }
    
    if (sender.role === 'freelancer' && (receiver.role === 'student' || receiver.role === 'user')) {
      return true; // Freelancers can message students/users
    }
    
    if (sender.role === 'freelancer' && receiver.role === 'freelancer') {
      return true; // Freelancers can message other freelancers
    }
    
    if (sender.role === 'teacher' && receiver.role === 'freelancer') {
      return true; // Teachers can message freelancers
    }
    
    // Student-to-student messaging requires accepted friendship
    if ((sender.role === 'student' || sender.role === 'user') && (receiver.role === 'student' || receiver.role === 'user')) {
      // Get auth UUIDs for both users to check friendship
      const senderAuthUser = await db.select({ id: users.id }).from(users).where(eq(users.userId, sender.userId)).limit(1);
      const receiverAuthUser = await db.select({ id: users.id }).from(users).where(eq(users.userId, receiver.userId)).limit(1);
      
      if (senderAuthUser.length === 0 || receiverAuthUser.length === 0) {
        return false; // Can't find auth users
      }
      
      const senderAuthId = senderAuthUser[0].id;
      const receiverAuthId = receiverAuthUser[0].id;
      
      // Check for accepted friendship between the two users using auth UUIDs
      const friendship = await db.select()
        .from(friendships)
        .where(and(
          or(
            and(eq(friendships.requesterId, senderAuthId), eq(friendships.receiverId, receiverAuthId)),
            and(eq(friendships.requesterId, receiverAuthId), eq(friendships.receiverId, senderAuthId))
          ),
          eq(friendships.status, 'accepted')
        ))
        .limit(1);
      
      return friendship.length > 0;
    }
    
    return false; // All other cases are not permitted
  };

  // Send a message with role-based permissions
  app.post("/api/messages", async (req, res) => {
    try {
      const { receiverId, content, messageType = 'text', threadId } = req.body;

      if (!receiverId || !content) {
        return res.status(400).json({ success: false, error: 'Receiver ID and content are required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const senderAuthUuid = session[0].userId;

      // Get sender's text ID from auth_users table
      const senderAuth = await db.select({ userId: users.userId }).from(users).where(eq(users.id, senderAuthUuid)).limit(1);
      if (senderAuth.length === 0) {
        return res.status(404).json({ success: false, error: "Sender not found" });
      }
      const senderTextId = senderAuth[0].userId;

      // Get sender's profile UUID (needed for messages table foreign key)
      const senderProfile = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, senderAuthUuid)).limit(1);
      if (senderProfile.length === 0) {
        return res.status(404).json({ success: false, error: "Sender profile not found" });
      }
      const senderProfileUuid = senderProfile[0].id;

      // Debug: Log what receiverId we're trying to look up
      console.log('ðŸ” /api/messages - Looking up receiver with ID:', receiverId, 'Type:', typeof receiverId);

      // Verify messaging permissions
      console.log('ðŸ”Ž Looking up sender with textId:', senderTextId);
      const sender = await getUserWithProfile(senderTextId);
      console.log('ðŸ”Ž Sender result:', sender);
      
      console.log('ðŸ”Ž Looking up receiver with id:', receiverId);
      const receiver = await getUserWithProfile(receiverId);
      console.log('ðŸ”Ž Receiver result:', receiver);

      if (!sender || !receiver) {
        console.log('âŒ User lookup failed - Sender:', !!sender, 'Receiver:', !!receiver);
        return res.status(404).json({ success: false, error: "User not found" });
      }

      console.log('ðŸ‘¥ Permission check - Sender:', { name: sender.name, role: sender.role, textUserId: sender.textUserId });
      console.log('ðŸ‘¥ Permission check - Receiver:', { name: receiver.name, role: receiver.role, textUserId: receiver.textUserId });
      
      // TEMPORARY: Allow all freelancer messaging
      const canMessage = sender.role === 'freelancer' || receiver.role === 'freelancer' ? true : await checkMessagingPermissions(sender, receiver);
      console.log('âœ… Permission check result:', canMessage);
      
      if (!canMessage) {
        return res.status(403).json({ success: false, error: "Not authorized to message this user" });
      }

      // Get receiver's profile UUID for database insertion
      // receiverId can be either a text ID (like "HJOR2AC54I") or a UUID (auth user ID)
      // Try text ID first, then UUID
      let receiverAuthUser = await db.select({ id: users.id }).from(users).where(eq(users.userId, receiverId)).limit(1);
      
      if (receiverAuthUser.length === 0) {
        // Try as UUID
        receiverAuthUser = await db.select({ id: users.id }).from(users).where(eq(users.id, receiverId)).limit(1);
      }
      
      if (receiverAuthUser.length === 0) {
        return res.status(404).json({ success: false, error: "Receiver not found" });
      }
      
      const receiverProfile = await db.select({ id: profiles.id }).from(profiles).where(eq(profiles.userId, receiverAuthUser[0].id)).limit(1);
      if (receiverProfile.length === 0) {
        return res.status(404).json({ success: false, error: "Receiver profile not found" });
      }
      const receiverProfileUuid = receiverProfile[0].id;
      
      // Create new message using profile UUIDs for foreign key compliance
      const newMessage = await db.insert(messages).values({
        senderId: senderProfileUuid,
        receiverId: receiverProfileUuid,
        content,
        fileType: messageType === 'text' ? null : messageType,
        threadId: threadId || null
      }).returning();

      // Update chat thread if this message belongs to a thread
      if (threadId) {
        await db.update(chatThreads)
          .set({
            lastMessageAt: new Date(),
            lastMessagePreview: content.substring(0, 100)
          })
          .where(eq(chatThreads.id, threadId));
      }

      // Send via WebSocket if receiver is online (use receiver's text ID)
      try {
        const receiverTextId = receiver.textUserId;
        const receiverWs = (global as any).wsClients?.get(receiverTextId);
        console.log(`ðŸ“¨ HTTP API: Looking for receiver ${receiverTextId}, connection found: ${!!receiverWs}, state: ${receiverWs?.readyState}`);
        if (receiverWs && receiverWs.readyState === 1) { // WebSocket.OPEN = 1
          receiverWs.send(JSON.stringify({
            type: 'new_message',
            data: {
              ...newMessage[0],
              senderName: sender.name,
              senderAvatarUrl: sender.avatarUrl
            }
          }));
          console.log(`âœ… HTTP API: Message sent to receiver ${receiverTextId} via WebSocket`);
        } else {
          console.log(`âŒ HTTP API: Receiver ${receiverTextId} not connected or connection closed`);
        }
      } catch (wsError) {
        console.log('WebSocket notification failed:', wsError);
        // Continue without WebSocket notification
      }

      res.json({
        success: true,
        message: newMessage[0]
      });

    } catch (error) {
      console.error('Send message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send message' });
    }
  });

  // Admin welcome messages removed - using real conversations only

  // General file upload endpoint for assignments and other features
  app.post("/api/upload", upload.single('file'), async (req, res) => {
    try {
      const { type } = req.body;
      const authHeader = req.headers.authorization;
      
      // Define allowed guest upload types
      const allowedGuestUploadTypes = ['banner', 'design-inquiries'];
      
      console.log('ðŸ” Upload attempt:', { type, hasAuth: !!authHeader });
      
      // Allow guest uploads for banner advertisements and design inquiries
      if (!authHeader && !allowedGuestUploadTypes.includes(type)) {
        console.log('âŒ Upload rejected: No auth and type is not in allowed guest types:', allowedGuestUploadTypes);
        return res.status(401).json({ success: false, error: "Authorization required" });
      }
      
      console.log('âœ… Upload allowed:', allowedGuestUploadTypes.includes(type) ? `Guest ${type} upload` : 'Authenticated upload');

      // Only validate session if authentication is required (not for allowed guest upload types)
      console.log('ðŸ” Session validation check:', { authHeader: !!authHeader, type, shouldValidate: !!(authHeader && !allowedGuestUploadTypes.includes(type)) });
      
      if (authHeader && !allowedGuestUploadTypes.includes(type)) {
        console.log('ðŸ” Validating session...');
        const session = await db
          .select()
          .from(userLoginSessions)
          .where(and(
            eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
            eq(userLoginSessions.isActive, true),
            gt(userLoginSessions.expiresAt, new Date())
          ))
          .limit(1);

        if (session.length === 0) {
          console.log('âŒ Session validation failed');
          return res.status(401).json({ success: false, error: "Invalid session" });
        }
        console.log('âœ… Session validated successfully');
      } else {
        console.log('â­ï¸ Skipping session validation for guest upload type:', type);
      }

      if (!req.file) {
        return res.status(400).json({ success: false, error: 'No file uploaded' });
      }

      const file = req.file;
      
      // Determine folder based on type
      let folder = 'documents';
      if (type === 'assignment-attachment') {
        folder = 'assignments';
      } else if (type === 'profile-image') {
        folder = 'avatars';
      } else if (type === 'banner') {
        folder = 'banners';
      } else if (type === 'hero') {
        folder = 'hero-sections';
      } else if (type === 'portfolio') {
        folder = 'portfolio';
      }

      try {
        const detectedFileType = getFileType(file.mimetype);
        validateFile(file, detectedFileType);
        
        console.log('ðŸ“Ž General upload:', {
          originalname: file.originalname,
          mimetype: file.mimetype,
          size: file.size,
          folder: folder
        });

        // Upload to Cloudinary
        const result = await cloudinaryStorage.uploadFile(
          file.buffer,
          file.originalname,
          file.mimetype,
          folder
        );

        if (!result.success || !result.url) {
          return res.status(500).json({ 
            success: false, 
            error: result.error || 'Upload failed'
          });
        }

        res.json({
          success: true,
          url: result.url,
          fileName: file.originalname,
          fileSize: file.size,
          mimeType: file.mimetype
        });

      } catch (error) {
        console.error('File upload error:', error);
        res.status(400).json({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Upload failed' 
        });
      }

    } catch (error) {
      console.error('Upload endpoint error:', error);
      res.status(500).json({ success: false, error: 'Server error during upload' });
    }
  });

  // Multiple files upload endpoint for portfolio and other features
  app.post("/api/upload/multiple", upload.array('files', 10), async (req, res) => {
    try {
      const { type } = req.body;
      const authHeader = req.headers.authorization;
      
      console.log('ðŸ” Multiple files upload attempt:', { type, hasAuth: !!authHeader, fileCount: req.files?.length });
      
      // Require authentication for multiple file uploads
      if (!authHeader) {
        console.log('âŒ Multiple upload rejected: No auth');
        return res.status(401).json({ success: false, error: "Authorization required" });
      }
      
      console.log('ðŸ” Validating session...');
      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        console.log('âŒ Session validation failed');
        return res.status(401).json({ success: false, error: "Invalid session" });
      }
      console.log('âœ… Session validated successfully');

      if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
        return res.status(400).json({ success: false, error: 'No files uploaded' });
      }

      const files = req.files as Express.Multer.File[];
      
      // Determine folder based on type
      let folder = 'documents';
      if (type === 'portfolio') {
        folder = 'portfolio';
      } else if (type === 'products') {
        folder = 'products';
      }

      try {
        const uploadedFiles = [];
        
        for (const file of files) {
          const detectedFileType = getFileType(file.mimetype);
          validateFile(file, detectedFileType);
          
          console.log('ðŸ“Ž Uploading file:', {
            originalname: file.originalname,
            mimetype: file.mimetype,
            size: file.size,
            folder: folder
          });

          // Upload to Cloudinary
          const result = await cloudinaryStorage.uploadFile(
            file.buffer,
            file.originalname,
            file.mimetype,
            folder
          );

          if (!result.success || !result.url) {
            console.error('Failed to upload file:', file.originalname, result.error);
            continue; // Skip this file but continue with others
          }

          uploadedFiles.push({
            url: result.url,
            fileName: file.originalname,
            fileSize: file.size,
            mimetype: file.mimetype
          });
        }

        if (uploadedFiles.length === 0) {
          return res.status(500).json({ 
            success: false, 
            error: 'All file uploads failed'
          });
        }

        res.json({
          success: true,
          files: uploadedFiles
        });

      } catch (error) {
        console.error('Multiple file upload error:', error);
        res.status(400).json({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Upload failed' 
        });
      }

    } catch (error) {
      console.error('Multiple upload endpoint error:', error);
      res.status(500).json({ success: false, error: 'Server error during upload' });
    }
  });


  // Enhanced messaging - Send file/media message
  app.post("/api/messages/file", upload.single('file'), async (req, res) => {
    try {
      const { receiverId, messageType, content = '', fileType } = req.body;
      const file = req.file;

      if (!receiverId) {
        return res.status(400).json({ success: false, error: 'Receiver ID is required' });
      }

      if (!file && !content) {
        return res.status(400).json({ success: false, error: 'File or content is required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const senderUuid = session[0].userId;

      // Get sender's text ID from auth_users table
      const senderAuth = await db.select({ userId: users.userId }).from(users).where(eq(users.id, senderUuid)).limit(1);
      if (senderAuth.length === 0) {
        return res.status(404).json({ success: false, error: "Sender not found" });
      }
      const senderTextId = senderAuth[0].userId;

      // Verify messaging permissions
      const sender = await getUserWithProfile(senderUuid);
      const receiver = await getUserWithProfile(receiverId);

      if (!sender || !receiver) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const canMessage = await checkMessagingPermissions(sender, receiver);
      if (!canMessage) {
        return res.status(403).json({ success: false, error: "Not authorized to message this user" });
      }

      let fileMetadata: FileMetadata | null = null;

      // Handle file upload if present
      if (file) {
        const detectedFileType = req.body.detectedFileType || getFileType(file.mimetype);
        
        try {
          validateFile(file, detectedFileType);
          
          // Debug logging for file buffer
          console.log('ðŸ“Ž File upload debug:', {
            hasBuffer: !!file.buffer,
            bufferLength: file.buffer?.length,
            originalname: file.originalname,
            mimetype: file.mimetype,
            size: file.size,
            detectedFileType
          });

          // Check if buffer exists
          if (!file.buffer) {
            throw new Error('File buffer is missing - multer memory storage may not be configured correctly');
          }
          
          // Upload to Cloudinary
          const uploadResult = await cloudinaryStorage.uploadFile(
            file.buffer,
            file.originalname,
            file.mimetype,
            FILE_CONFIGS[detectedFileType].folder
          );

          if (!uploadResult.success) {
            throw new Error(uploadResult.error || 'Upload failed');
          }

          fileMetadata = {
            url: uploadResult.url!,
            fileName: file.originalname,
            fileSize: file.size,
            mimeType: file.mimetype,
          };
        } catch (uploadError) {
          return res.status(400).json({ 
            success: false, 
            error: uploadError instanceof Error ? uploadError.message : 'File upload failed' 
          });
        }
      }

      // Convert text IDs to profile UUIDs for database insertion
      const receiverUuid = await getUserUuidByUserId(receiverId);
      
      if (!receiverUuid) {
        console.log(`âŒ Receiver profile UUID not found for text ID: ${receiverId}`);
        return res.status(404).json({ success: false, error: "Receiver not found" });
      }

      // Verify receiver profile exists
      const receiverProfileCheck = await db
        .select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.id, receiverUuid))
        .limit(1);

      if (receiverProfileCheck.length === 0) {
        console.log(`âŒ Receiver profile does not exist in profiles table: ${receiverUuid}`);
        return res.status(404).json({ success: false, error: "Receiver profile not found" });
      }

      // Get sender's profile UUID (messages.senderId references profiles.id, not users.id)
      const senderProfileUuid = await db
        .select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, senderUuid))
        .limit(1);

      if (senderProfileUuid.length === 0) {
        return res.status(404).json({ success: false, error: "Sender profile not found" });
      }
      
      // Determine the correct message type
      const finalMessageType = messageType || (fileMetadata ? getFileType(fileMetadata.mimeType) : 'text');
      
      // Create new message using UUIDs and new schema
      const newMessage = await db.insert(messages).values({
        senderId: senderProfileUuid[0].id,
        receiverId: receiverUuid,
        content: content || (fileMetadata ? fileMetadata.fileName : 'Media message'),
        messageType: finalMessageType, // Add the missing messageType field
        fileUrl: fileMetadata?.url || null,
        fileType: messageType || (fileMetadata ? getFileType(fileMetadata.mimeType) : null)
      }).returning();

      // Send via WebSocket if receiver is online (receiverId is already text ID)
      try {
        const receiverWs = (global as any).wsClients?.get(receiverId);
        console.log(`ðŸ“¨ File API: Looking for receiver ${receiverId}, connection found: ${!!receiverWs}, state: ${receiverWs?.readyState}`);
        if (receiverWs && receiverWs.readyState === 1) { // WebSocket.OPEN = 1
          receiverWs.send(JSON.stringify({
            type: 'new_message',
            data: {
              ...newMessage[0],
              senderName: sender.name,
              senderAvatarUrl: sender.avatarUrl,
              fileMetadata
            }
          }));
          console.log(`âœ… File API: Message sent to receiver ${receiverId} via WebSocket`);
        } else {
          console.log(`âŒ File API: Receiver ${receiverId} not connected or connection closed`);
        }
      } catch (wsError) {
        console.log('WebSocket notification failed:', wsError);
      }

      res.json({
        success: true,
        message: {
          ...newMessage[0],
          fileMetadata
        }
      });

    } catch (error) {
      console.error('Send file message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send message' });
    }
  });

  // Enhanced messaging - Send location message
  app.post("/api/messages/location", async (req, res) => {
    try {
      const { receiverId, latitude, longitude, address, content = '' } = req.body;

      if (!receiverId || !latitude || !longitude) {
        return res.status(400).json({ success: false, error: 'Receiver ID, latitude, and longitude are required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const senderUuid = session[0].userId;

      // Get sender's text ID from auth_users table
      const senderAuth = await db.select({ userId: users.userId }).from(users).where(eq(users.id, senderUuid)).limit(1);
      if (senderAuth.length === 0) {
        return res.status(404).json({ success: false, error: "Sender not found" });
      }
      const senderTextId = senderAuth[0].userId;

      // Verify messaging permissions
      const sender = await getUserWithProfile(senderUuid);
      const receiver = await getUserWithProfile(receiverId);

      if (!sender || !receiver) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      const canMessage = await checkMessagingPermissions(sender, receiver);
      if (!canMessage) {
        return res.status(403).json({ success: false, error: "Not authorized to message this user" });
      }

      // Create location data
      const locationData = {
        latitude: parseFloat(latitude),
        longitude: parseFloat(longitude),
        address: address || null
      };

      // Convert text IDs to UUIDs for database insertion
      const receiverUuid = await getUserUuidByUserId(receiverId);
      
      if (!receiverUuid) {
        return res.status(404).json({ success: false, error: "Receiver not found" });
      }
      
      // Create new message using UUIDs and new schema
      const newMessage = await db.insert(messages).values({
        senderId: senderUuid,
        receiverId: receiverUuid,
        content: JSON.stringify(locationData),
        fileType: 'location'
      }).returning();

      // Send via WebSocket if receiver is online (receiverId is already text ID)
      try {
        const receiverWs = (global as any).wsClients?.get(receiverId);
        console.log(`ðŸ“¨ Location API: Looking for receiver ${receiverId}, connection found: ${!!receiverWs}, state: ${receiverWs?.readyState}`);
        if (receiverWs && receiverWs.readyState === 1) { // WebSocket.OPEN = 1
          receiverWs.send(JSON.stringify({
            type: 'new_message',
            data: {
              ...newMessage[0],
              senderName: sender.name,
              senderAvatarUrl: sender.avatarUrl,
              locationData
            }
          }));
          console.log(`âœ… Location API: Message sent to receiver ${receiverId} via WebSocket`);
        } else {
          console.log(`âŒ Location API: Receiver ${receiverId} not connected or connection closed`);
        }
      } catch (wsError) {
        console.log('WebSocket notification failed:', wsError);
      }

      res.json({
        success: true,
        message: {
          ...newMessage[0],
          locationData
        }
      });

    } catch (error) {
      console.error('Send location message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send location message' });
    }
  });

  // Enhanced messaging - Mark message as delivered
  app.patch("/api/messages/:messageId/delivered", async (req, res) => {
    try {
      const { messageId } = req.params;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;

      // Update message as delivered (only if user is the receiver)
      const updatedMessage = await db
        .update(messages)
        .set({ 
          deliveredAt: new Date() 
        })
        .where(and(
          eq(messages.id, messageId),
          eq(messages.receiverId, userId),
          isNull(messages.deliveredAt)
        ))
        .returning();

      if (updatedMessage.length === 0) {
        return res.status(404).json({ success: false, error: "Message not found or already delivered" });
      }

      // Notify sender via WebSocket
      try {
        const senderWs = (global as any).wsClients?.get(updatedMessage[0].senderId);
        if (senderWs && senderWs.readyState === 1) {
          senderWs.send(JSON.stringify({
            type: 'message_delivered',
            messageId,
            deliveredAt: updatedMessage[0].deliveredAt
          }));
        }
      } catch (wsError) {
        console.log('WebSocket notification failed:', wsError);
      }

      res.json({
        success: true,
        message: 'Message marked as delivered'
      });

    } catch (error) {
      console.error('Mark delivered error:', error);
      res.status(500).json({ success: false, error: 'Failed to mark message as delivered' });
    }
  });

  // Enhanced messaging - Mark message as read
  app.patch("/api/messages/:messageId/read", async (req, res) => {
    try {
      const { messageId } = req.params;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;

      // Update message as read (only if user is the receiver)
      const updatedMessage = await db
        .update(messages)
        .set({ 
          readAt: new Date(),
          deliveredAt: new Date(), // Ensure delivered is also set
          isRead: true // Legacy compatibility
        })
        .where(and(
          eq(messages.id, messageId),
          eq(messages.receiverId, userId)
        ))
        .returning();

      if (updatedMessage.length === 0) {
        return res.status(404).json({ success: false, error: "Message not found" });
      }

      // Notify sender via WebSocket
      try {
        const senderWs = (global as any).wsClients?.get(updatedMessage[0].senderId);
        if (senderWs && senderWs.readyState === 1) {
          senderWs.send(JSON.stringify({
            type: 'message_read',
            messageId,
            readAt: updatedMessage[0].readAt
          }));
        }
      } catch (wsError) {
        console.log('WebSocket notification failed:', wsError);
      }

      res.json({
        success: true,
        message: 'Message marked as read'
      });

    } catch (error) {
      console.error('Mark read error:', error);
      res.status(500).json({ success: false, error: 'Failed to mark message as read' });
    }
  });

  // Get pending friend requests (for messaging interface)
  app.get("/api/messages/friend-requests", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const user = await getUserFromSession(authHeader);
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Get pending friend requests where current user is the receiver
      const requests = await db.select({
        id: friendships.id,
        requesterId: friendships.requesterId,
        receiverId: friendships.receiverId,
        status: friendships.status,
        requestMessage: friendships.requestMessage,
        createdAt: friendships.createdAt,
        requesterName: sql<string>`COALESCE(${profiles.name}, ${profiles.displayName}, 'Unknown User')`.as('requesterName'),
        requesterAvatarUrl: profiles.avatarUrl
      })
      .from(friendships)
      .leftJoin(profiles, eq(friendships.requesterId, profiles.userId))
      .where(
        and(
          eq(friendships.receiverId, user.id),
          eq(friendships.status, 'pending')
        )
      )
      .orderBy(desc(friendships.createdAt));

      res.json({ success: true, data: requests });

    } catch (error) {
      console.error('Get friend requests error:', error);
      res.status(500).json({ success: false, error: 'Failed to get friend requests' });
    }
  });

  // Respond to friend request (accept/reject)
  app.post("/api/messages/friend-requests/:requestId/respond", async (req, res) => {
    try {
      const { requestId } = req.params;
      const { action } = req.body;
      
      console.log('ðŸ” Friend request response debug:', { 
        requestId, 
        action, 
        body: req.body,
        hasAction: !!action,
        actionType: typeof action 
      });

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const user = await getUserFromSession(authHeader);
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      if (!['accept', 'reject'].includes(action)) {
        return res.status(400).json({ success: false, error: 'Invalid action. Must be accept or reject' });
      }

      // Check if the friendship request exists and user is the receiver
      const friendship = await db.select()
        .from(friendships)
        .where(
          and(
            eq(friendships.id, requestId),
            eq(friendships.receiverId, user.id),
            eq(friendships.status, 'pending')
          )
        )
        .limit(1);

      if (friendship.length === 0) {
        return res.status(404).json({ success: false, error: 'Friend request not found or already responded' });
      }

      // Update friendship status
      const [updatedFriendship] = await db.update(friendships)
        .set({ 
          status: action === 'accept' ? 'accepted' : 'rejected',
          updatedAt: new Date()
        })
        .where(eq(friendships.id, requestId))
        .returning();

      // Send real-time notification to the requester
      try {
        const wss = (global as any).wss;
        if (wss) {
          // Get responder's profile information for the notification
          const responderProfile = await db.select({
            name: profiles.name,
            userId: users.userId
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(eq(users.id, user.id))
          .limit(1);

          const requesterProfile = await db.select({
            userId: users.userId
          })
          .from(users)
          .where(eq(users.id, friendship[0].requesterId))
          .limit(1);

          if (responderProfile.length > 0 && requesterProfile.length > 0) {
            const requesterWs = wss.userConnections.get(requesterProfile[0].userId);
            if (requesterWs && requesterWs.readyState === 1) { // WebSocket.OPEN = 1
              requesterWs.send(JSON.stringify({
                type: 'friend_request_response',
                responderId: responderProfile[0].userId,
                responderName: responderProfile[0].name,
                action: action,
                message: action === 'accept' 
                  ? `${responderProfile[0].name} accepted your friend request`
                  : `${responderProfile[0].name} declined your friend request`,
                friendshipId: updatedFriendship.id
              }));
              console.log(`ðŸ‘¥ Real-time friend request ${action} notification sent to ${requesterProfile[0].userId}`);
            }
          }
        }
      } catch (notificationError) {
        console.error('Failed to send friend request response notification:', notificationError);
        // Don't fail the request if notification fails
      }

      res.json({ 
        success: true, 
        message: `Friend request ${action}ed successfully`,
        data: updatedFriendship
      });

    } catch (error) {
      console.error('Respond to friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to respond to friend request' });
    }
  });

  // Helper function to get profile UUID by text userId
  const getUserUuidByUserId = async (textUserId: string): Promise<string | null> => {
    try {
      // First get the user UUID from auth_users
      const authUser = await db
        .select({ id: users.id })
        .from(users)
        .where(eq(users.userId, textUserId))
        .limit(1);
      
      if (authUser.length === 0) return null;
      
      // Then get the profile UUID
      const profile = await db
        .select({ id: profiles.id })
        .from(profiles) 
        .where(eq(profiles.userId, authUser[0].id))
        .limit(1);
        
      return profile.length > 0 ? profile[0].id : null;
    } catch (error) {
      console.error('Error getting profile UUID:', error);
      return null;
    }
  };

  // Ensure admin user exists
  const ensureAdminUserExists = async () => {
    try {
      // Create ADMIN00001 (Support)
      const existingAdmin = await db
        .select()
        .from(users)
        .where(eq(users.userId, 'ADMIN00001'))
        .limit(1);
      
      if (existingAdmin.length === 0) {
        console.log('ðŸ”§ Creating admin user ADMIN00001...');
        
        const [newAdmin] = await db.insert(users).values({
          userId: 'ADMIN00001',
          email: 'support@edufiliova.com',
          passwordHash: await bcrypt.hash('AdminEduFiliova2025!', 10),
          educationLevel: 'other',
          createdAt: new Date(),
          updatedAt: new Date()
        }).returning();

        // Create admin profile  
        await db.insert(profiles).values({
          userId: newAdmin.id, // Use the UUID from the users table
          name: 'Support',
          age: 30,
          grade: 13,
          avatarUrl: null,
          country: 'Global',
          educationLevel: 'other',
          role: 'admin',
          pronouns: 'they/them',
          lastSeen: new Date(),
          createdAt: new Date(),
          updatedAt: new Date()
        }).onConflictDoNothing();

        console.log('âœ… Admin user ADMIN00001 created successfully');
      } else {
        console.log('âœ… Admin user ADMIN00001 already exists');
        
        // Ensure the admin profile exists too and update name
        const existingProfile = await db
          .select()
          .from(profiles)
          .where(eq(profiles.userId, existingAdmin[0].id))
          .limit(1);
          
        if (existingProfile.length === 0) {
          console.log('ðŸ”§ Creating missing admin profile...');
          await db.insert(profiles).values({
            userId: existingAdmin[0].id,
            name: 'Support',
            age: 30,
            grade: 13,
            avatarUrl: null,
            country: 'Global',
            educationLevel: 'other',
            role: 'admin',
            pronouns: 'they/them',
            lastSeen: new Date(),
            createdAt: new Date(),
            updatedAt: new Date()
          }).onConflictDoNothing();
          console.log('âœ… Admin profile created successfully');
        } else {
          // Update the existing profile name and ensure role is admin
          await db.update(profiles)
            .set({
              name: 'Support',
              role: 'admin',
              updatedAt: new Date()
            })
            .where(eq(profiles.userId, existingAdmin[0].id));
        }
        
        // Also ensure email is correct
        await db.update(users)
          .set({
            email: 'support@edufiliova.com',
            updatedAt: new Date()
          })
          .where(eq(users.userId, 'ADMIN00001'));
      }

      // Create ADMIN00002 (Tech Support)
      const existingAdmin2 = await db
        .select()
        .from(users)
        .where(eq(users.userId, 'ADMIN00002'))
        .limit(1);
      
      if (existingAdmin2.length === 0) {
        console.log('ðŸ”§ Creating admin user ADMIN00002...');
        
        const [newAdmin2] = await db.insert(users).values({
          userId: 'ADMIN00002',
          email: 'techverify@edufiliova.com',
          passwordHash: await bcrypt.hash('AdminEduFiliova2025!', 10),
          educationLevel: 'other',
          createdAt: new Date(),
          updatedAt: new Date()
        }).returning();

        // Create admin profile with Tech Support logo
        await db.insert(profiles).values({
          userId: newAdmin2.id,
          name: 'Tech Support',
          age: 30,
          grade: 13,
          avatarUrl: '/src/assets/tech-support-logo.jpg',
          country: 'Global',
          educationLevel: 'other',
          role: 'admin',
          pronouns: 'they/them',
          lastSeen: new Date(),
          createdAt: new Date(),
          updatedAt: new Date()
        }).onConflictDoNothing();

        console.log('âœ… Admin user ADMIN00002 created successfully');
      } else {
        console.log('âœ… Admin user ADMIN00002 already exists');
        
        // Update the existing ADMIN00002 profile to use the new name and logo
        await db.update(profiles)
          .set({
            name: 'Tech Support',
            avatarUrl: '/src/assets/tech-support-logo.jpg',
            updatedAt: new Date()
          })
          .where(eq(profiles.userId, existingAdmin2[0].id));
        
        console.log('âœ… Updated ADMIN00002 profile with new name and logo');
      }
    } catch (error) {
      console.error('âŒ Error ensuring admin user exists:', error);
    }
  };

  // Initialize admin user on startup
  ensureAdminUserExists();

  // Enhanced messaging - Get conversation with delivery/read status
  app.get("/api/messages/enhanced/:otherUserId", async (req, res) => {
    try {
      let { otherUserId } = req.params;
      const { page = 1, limit = 50 } = req.query;

      // Strip conversation ID prefixes (direct_, support_, etc.)
      if (otherUserId.startsWith('direct_')) {
        otherUserId = otherUserId.replace('direct_', '');
      } else if (otherUserId.startsWith('support_')) {
        otherUserId = otherUserId.replace('support_', '');
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const currentUserId = session[0].userId;

      // Get UUID IDs for both users
      const currentUserUuid = await getUserUuidByUserId(currentUserId);
      
      // Check if otherUserId is already a UUID (profile ID) or a text ID
      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      let otherUserUuid: string | null;
      
      if (uuidRegex.test(otherUserId)) {
        // It's already a UUID (profile ID), use it directly
        otherUserUuid = otherUserId;
      } else {
        // It's a text ID, convert it to UUID
        otherUserUuid = await getUserUuidByUserId(otherUserId);
      }

      if (!currentUserUuid || !otherUserUuid) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      // Get conversation messages with enhanced fields
      const conversation = await db
        .select({
          id: messages.id,
          senderId: messages.senderId,
          receiverId: messages.receiverId,
          content: messages.content,
          fileUrl: messages.fileUrl,
          fileType: messages.fileType,
          deliveredAt: messages.deliveredAt,
          readAt: messages.readAt,
          createdAt: messages.createdAt,
          senderProfile: {
            name: sql<string>`sender_profile.name`,
            avatarUrl: sql<string>`sender_profile.avatar_url`
          },
          receiverProfile: {
            name: sql<string>`receiver_profile.name`,
            avatarUrl: sql<string>`receiver_profile.avatar_url`
          }
        })
        .from(messages)
        .leftJoin(sql`profiles AS sender_profile`, eq(messages.senderId, sql`sender_profile.id`))
        .leftJoin(sql`profiles AS receiver_profile`, eq(messages.receiverId, sql`receiver_profile.id`))
        .where(
          or(
            and(eq(messages.senderId, currentUserUuid), eq(messages.receiverId, otherUserUuid)),
            and(eq(messages.senderId, otherUserUuid), eq(messages.receiverId, currentUserUuid))
          )
        )
        .orderBy(desc(messages.createdAt))
        .limit(parseInt(limit as string))
        .offset((parseInt(page as string) - 1) * parseInt(limit as string));

      // Mark messages as delivered if they haven't been already
      const undeliveredMessages = conversation
        .filter(msg => msg.receiverId === currentUserUuid && !msg.deliveredAt)
        .map(msg => msg.id);

      if (undeliveredMessages.length > 0) {
        await db
          .update(messages)
          .set({ deliveredAt: new Date() })
          .where(inArray(messages.id, undeliveredMessages));

        // Notify sender via WebSocket
        try {
          const senderWs = (global as any).wsClients?.get(otherUserId);
          if (senderWs && senderWs.readyState === 1) {
            senderWs.send(JSON.stringify({
              type: 'messages_delivered',
              messageIds: undeliveredMessages,
              deliveredAt: new Date()
            }));
          }
        } catch (wsError) {
          console.log('WebSocket notification failed:', wsError);
        }
      }

      res.json({
        success: true,
        conversation: conversation.reverse(), // Oldest first for chat display
        pagination: {
          page: parseInt(page as string),
          limit: parseInt(limit as string),
          hasMore: conversation.length === parseInt(limit as string)
        }
      });

    } catch (error) {
      console.error('Get enhanced conversation error:', error);
      res.status(500).json({ success: false, error: 'Failed to get conversation' });
    }
  });

  // Group conversation routes
  
  
  // Get messages for a specific group
  app.get("/api/messages/group/:groupId", async (req, res) => {
    try {
      const { groupId } = req.params;
      const { page = 1, limit = 50 } = req.query;
      
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userId = session[0].userId;
      
      // Verify user is a member of the group
      const membership = await db
        .select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, userId)
        ))
        .limit(1);
        
      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: "Not a member of this group" });
      }
      
      // Get group messages
      const groupMessages = await db.select({
        id: messages.id,
        senderId: messages.senderId,
        groupId: messages.groupId,
        content: messages.content,
        fileUrl: messages.fileUrl,
        fileType: messages.fileType,
        deliveredAt: messages.deliveredAt,
        readAt: messages.readAt,
        createdAt: messages.createdAt
      })
        .from(messages)
        .where(eq(messages.groupId, groupId))
        .orderBy(asc(messages.createdAt))
        .limit(Number(limit))
        .offset((Number(page) - 1) * Number(limit));

      console.log(`ðŸ“¨ Returning ${groupMessages.length} group messages for group ${groupId}`);
      res.json({ success: true, data: groupMessages });

    } catch (error) {
      console.error('Group messages fetch error:', error);
      res.status(500).json({ success: false, error: "Failed to fetch group messages" });
    }
  });

  // Send message to group
  app.post("/api/messages/group", async (req, res) => {
    try {
      const { groupId, content, fileType } = req.body;

      if (!groupId || !content) {
        return res.status(400).json({ success: false, error: 'Group ID and content are required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const userUuid = session[0].userId;
      
      // Get profile UUID for this user
      const userProfile = await db.select({ profileId: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, userUuid))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: "User profile not found" });
      }

      const senderProfileUuid = userProfile[0].profileId;
      
      // Verify user is a member of the group
      const membership = await db
        .select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, userUuid)
        ))
        .limit(1);
        
      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: "Not a member of this group" });
      }
      
      // Create new group message
      const newMessage = await db.insert(messages).values({
        senderId: senderProfileUuid,
        groupId: groupId,
        content,
        fileType: fileType || null
      }).returning();

      // Broadcast message to all group members via WebSocket
      try {
        // Get all group members
        const groupMembers = await db.select({ userId: communityGroupMembers.userId })
          .from(communityGroupMembers)
          .where(eq(communityGroupMembers.groupId, groupId));
        
        let sentCount = 0;
        for (const member of groupMembers) {
          // Get user's text ID for WebSocket lookup
          const memberUser = await db.select({ userId: users.userId })
            .from(users)
            .where(eq(users.id, member.userId))
            .limit(1);
          
          if (memberUser.length > 0) {
            const memberTextId = memberUser[0].userId;
            const memberWs = (global as any).wsClients?.get(memberTextId);
            
            if (memberWs && memberWs.readyState === 1) {
              memberWs.send(JSON.stringify({
                type: 'new_message',
                data: newMessage[0]
              }));
              sentCount++;
            }
          }
        }
        
        console.log(`âœ… Group message broadcasted to ${sentCount} online members`);
      } catch (wsError) {
        console.log('WebSocket broadcast failed:', wsError);
      }

      res.json({
        success: true,
        message: newMessage[0]
      });

    } catch (error) {
      console.error('Send group message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send group message' });
    }
  });

  // Start freelancer chat
  app.post("/api/messages/start-freelancer-chat", async (req, res) => {
    try {
      const { freelancerId } = req.body;

      if (!freelancerId) {
        return res.status(400).json({ success: false, error: 'Freelancer ID is required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const customerUuid = session[0].userId;
      
      // Prevent self-contact
      if (customerUuid === freelancerId) {
        return res.status(400).json({ success: false, error: "Cannot start a chat with yourself" });
      }

      // Get customer profile UUID and role
      const customerProfile = await db.select({ profileId: profiles.id, role: profiles.role })
        .from(profiles)
        .where(eq(profiles.userId, customerUuid))
        .limit(1);

      if (customerProfile.length === 0) {
        return res.status(404).json({ success: false, error: "Customer profile not found" });
      }

      const customerProfileUuid = customerProfile[0].profileId;
      const customerRole = customerProfile[0].role;

      // Get freelancer profile UUID and role
      const freelancerProfile = await db.select({ profileId: profiles.id, role: profiles.role })
        .from(profiles)
        .where(eq(profiles.userId, freelancerId))
        .limit(1);

      if (freelancerProfile.length === 0) {
        return res.status(404).json({ success: false, error: "Freelancer not found" });
      }

      const freelancerProfileUuid = freelancerProfile[0].profileId;
      const freelancerRole = freelancerProfile[0].role;

      // Use transaction-based upsert to prevent race conditions
      let threadId;
      let isNewThread = false;
      
      try {
        // Try to create new chat thread - will fail if duplicate due to unique constraint
        const result = await db.transaction(async (tx) => {
          // Attempt to insert new thread
          const newThread = await tx.insert(chatThreads).values({
            customerId: customerUuid,
            freelancerId: freelancerId,
            status: 'open'
          }).returning();
          
          const createdThreadId = newThread[0].id;
          
          // Insert participants idempotently using onConflictDoNothing with explicit target
          await tx.insert(chatParticipants).values([
            {
              threadId: createdThreadId,
              userId: customerUuid,
              role: customerRole
            },
            {
              threadId: createdThreadId,
              userId: freelancerId,
              role: freelancerRole
            }
          ]).onConflictDoNothing({ target: [chatParticipants.threadId, chatParticipants.userId] });
          
          return { threadId: createdThreadId, isNew: true };
        });
        
        threadId = result.threadId;
        isNewThread = result.isNew;
        console.log(`âœ¨ Created new chat thread ${threadId} between customer ${customerUuid} and freelancer ${freelancerId}`);
        
      } catch (error: any) {
        // Check if this is a unique constraint violation
        if (error.code === '23505' || error.message?.includes('unique_freelancer_customer')) {
          // Thread already exists due to race condition, fetch it
          const existingThread = await db
            .select()
            .from(chatThreads)
            .where(
              and(
                eq(chatThreads.customerId, customerUuid),
                eq(chatThreads.freelancerId, freelancerId)
              )
            )
            .limit(1);
            
          if (existingThread.length > 0) {
            threadId = existingThread[0].id;
            isNewThread = false;
            console.log(`ðŸ“¬ Using existing chat thread ${threadId} between customer ${customerUuid} and freelancer ${freelancerId} (race condition resolved)`);
          } else {
            // Unexpected state - thread should exist but we can't find it
            throw new Error('Thread creation failed and existing thread not found');
          }
        } else {
          // Re-throw other errors
          throw error;
        }
      }

      console.log(`ðŸ¤ Started/accessed freelancer chat between customer ${customerUuid} and freelancer ${freelancerId}`);

      // Format conversation ID to match the unified-conversations format
      // IMPORTANT: Use freelancerProfileUuid (profile UUID) to match unified-conversations API
      const conversationId = `direct_${freelancerProfileUuid}`;

      res.json({
        success: true,
        conversationId: conversationId,
        threadId: threadId,
        isNewThread: isNewThread
      });

    } catch (error) {
      console.error('Start freelancer chat error:', error);
      res.status(500).json({ success: false, error: 'Failed to start chat with freelancer' });
    }
  });

  // Teacher Announcements - Create announcement
  app.post("/api/announcements", async (req, res) => {
    try {
      const { title, content, priority = 'normal', targetAudience = 'all_students', targetGrade, targetStudentIds, expiresAt } = req.body;

      if (!title || !content) {
        return res.status(400).json({ success: false, error: 'Title and content are required' });
      }

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const teacher = await getUserWithProfile(session[0].userId);
      if (!teacher || teacher.role !== 'teacher') {
        return res.status(403).json({ success: false, error: "Only teachers can create announcements" });
      }

      const newAnnouncement = await db.insert(announcements).values({
        teacherId: teacher.userId,
        title,
        content,
        priority,
        targetAudience,
        targetGrade: targetGrade || null,
        targetStudentIds: targetStudentIds || [],
        expiresAt: expiresAt ? new Date(expiresAt) : null
      }).returning();

      res.json({ success: true, data: newAnnouncement[0] });

    } catch (error) {
      console.error('Create announcement error:', error);
      res.status(500).json({ success: false, error: 'Failed to create announcement' });
    }
  });

  // Get announcements for student
  app.get("/api/announcements", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const user = await getUserWithProfile(session[0].userId);
      if (!user) {
        return res.status(404).json({ success: false, error: "User not found" });
      }

      let userAnnouncements;

      if (user.role === 'student') {
        // Get announcements targeted to this student
        userAnnouncements = await db.select({
          id: announcements.id,
          teacherId: announcements.teacherId,
          title: announcements.title,
          content: announcements.content,
          priority: announcements.priority,
          createdAt: announcements.createdAt,
          teacherName: sql<string>`teacher_profile.name`
        })
        .from(announcements)
        .leftJoin(sql`profiles AS teacher_profile`, sql`teacher_profile."userId" = ${announcements.teacherId}`)
        .where(and(
          eq(announcements.isActive, true),
          or(
            isNull(announcements.expiresAt),
            gt(announcements.expiresAt, new Date())
          ),
          or(
            eq(announcements.targetAudience, 'all_students'),
            and(
              eq(announcements.targetAudience, 'specific_grade'),
              eq(announcements.targetGrade, user.grade)
            ),
            and(
              eq(announcements.targetAudience, 'specific_students'),
              sql`${user.userId} = ANY(${announcements.targetStudentIds})`
            )
          )
        ))
        .orderBy(desc(announcements.createdAt));

      } else if (user.role === 'teacher') {
        // Get announcements created by this teacher
        userAnnouncements = await db.select()
          .from(announcements)
          .where(eq(announcements.teacherId, user.userId))
          .orderBy(desc(announcements.createdAt));

      } else if (user.role === 'admin') {
        // Admins can see all announcements
        userAnnouncements = await db.select({
          id: announcements.id,
          teacherId: announcements.teacherId,
          title: announcements.title,
          content: announcements.content,
          priority: announcements.priority,
          targetAudience: announcements.targetAudience,
          targetGrade: announcements.targetGrade,
          isActive: announcements.isActive,
          createdAt: announcements.createdAt,
          teacherName: sql<string>`teacher_profile.name`
        })
        .from(announcements)
        .leftJoin(sql`profiles AS teacher_profile`, sql`teacher_profile."userId" = ${announcements.teacherId}`)
        .orderBy(desc(announcements.createdAt));
      }

      res.json({ success: true, data: userAnnouncements });

    } catch (error) {
      console.error('Get announcements error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch announcements' });
    }
  });

  // Teacher Dashboard - Get assigned students
  app.get("/api/teacher/students", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const teacher = await getUserWithProfile(session[0].userId);
      if (!teacher || teacher.role !== 'teacher') {
        return res.status(403).json({ success: false, error: "Only teachers can access this endpoint" });
      }

      // Use teacher.userId (UUID) for database operations
      const teacherUuid = teacher.userId;

      // Get students who have accepted appointments (confirmed status)
      const studentsWithAppointments = await db.select({
        studentId: appointments.studentId,
        name: profiles.name,
        pronouns: profiles.pronouns,
        avatarUrl: profiles.avatarUrl,
        grade: profiles.grade,
        country: profiles.country,
        appointmentDate: appointments.startDate,
        appointmentStatus: appointments.status,
        subject: appointments.subject,
        lastMessageTime: sql<Date | null>`(
          SELECT MAX(created_at) 
          FROM messages 
          WHERE (sender_id = ${teacherUuid} AND receiver_id = ${appointments.studentId})
             OR (sender_id = ${appointments.studentId} AND receiver_id = ${teacherUuid})
        )`,
        unreadCount: sql<number>`(
          SELECT COUNT(*) 
          FROM messages 
          WHERE sender_id = ${appointments.studentId} 
            AND receiver_id = ${teacherUuid} 
            AND is_read = false
        )`
      })
      .from(appointments)
      .innerJoin(profiles, eq(appointments.studentId, profiles.userId))
      .where(and(
        eq(appointments.teacherId, teacherUuid),
        eq(appointments.status, 'confirmed')
      ))
      .orderBy(desc(appointments.startDate));

      res.json({ success: true, data: studentsWithAppointments });

    } catch (error) {
      console.error('Get teacher students error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assigned students' });
    }
  });

  // Get detailed student progress for teachers
  app.get("/api/teacher/students/progress", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const teacher = await getUserWithProfile(session[0].userId);
      if (!teacher || teacher.role !== 'teacher') {
        return res.status(403).json({ success: false, error: "Only teachers can access this endpoint" });
      }

      // Use teacher.userId (UUID) for database operations
      const teacherUuid = teacher.userId;

      // Get students with confirmed appointments and their progress details
      const rawStudentsData = await db.select({
        studentId: appointments.studentId,
        name: profiles.name,
        pronouns: profiles.pronouns,
        avatarUrl: profiles.avatarUrl,
        grade: profiles.grade,
        country: profiles.country,
        appointmentDate: appointments.startDate,
        appointmentStatus: appointments.status,
        subject: appointments.subject,
        assignedAt: appointments.createdAt, // Use appointment creation as assignment date
        notes: appointments.notes,
        lastMessageTime: sql<Date | null>`(
          SELECT MAX(created_at) 
          FROM messages 
          WHERE (sender_id = ${teacherUuid} AND receiver_id = ${appointments.studentId})
             OR (sender_id = ${appointments.studentId} AND receiver_id = ${teacherUuid})
        )`,
        unreadCount: sql<number>`(
          SELECT COUNT(*) 
          FROM messages 
          WHERE sender_id = ${appointments.studentId} 
            AND receiver_id = ${teacherUuid} 
            AND is_read = false
        )`,
        totalLessonsStarted: sql<number>`(
          SELECT COUNT(DISTINCT lesson_id) 
          FROM lesson_progress 
          WHERE user_id = ${appointments.studentId}
        )`,
        completedLessons: sql<number>`(
          SELECT COUNT(DISTINCT lesson_id) 
          FROM lesson_progress 
          WHERE user_id = ${appointments.studentId} 
            AND completed_at IS NOT NULL
        )`,
        averageProgress: sql<number>`(
          SELECT COALESCE(AVG(progress_percent), 0) 
          FROM lesson_progress 
          WHERE user_id = ${appointments.studentId}
        )`,
        lastActiveAt: sql<Date | null>`(
          SELECT MAX(updated_at) 
          FROM lesson_progress 
          WHERE user_id = ${appointments.studentId}
        )`
      })
      .from(appointments)
      .innerJoin(profiles, eq(appointments.studentId, profiles.userId))
      .where(and(
        eq(appointments.teacherId, teacherUuid),
        eq(appointments.status, 'confirmed')
      ))
      .orderBy(desc(appointments.startDate));

      // Group students by studentId and aggregate subjects
      const studentsWithProgress = rawStudentsData.reduce((acc, student) => {
        const existingStudent = acc.find(s => s.studentId === student.studentId);
        
        if (existingStudent) {
          // Add subject to existing student if not already present
          if (student.subject && !existingStudent.subjects.includes(student.subject)) {
            existingStudent.subjects.push(student.subject);
          }
          // Update to most recent appointment date if newer
          if (student.appointmentDate > existingStudent.appointmentDate) {
            existingStudent.appointmentDate = student.appointmentDate;
            existingStudent.assignedAt = student.assignedAt;
            existingStudent.notes = student.notes;
          }
        } else {
          // Create new student entry with subjects array
          acc.push({
            ...student,
            subjects: student.subject ? [student.subject] : [],
            // Keep subject field for backward compatibility, use first subject
            subject: student.subject
          });
        }
        
        return acc;
      }, [] as any[]);

      res.json({ success: true, data: studentsWithProgress });

    } catch (error) {
      console.error('Get student progress error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch student progress' });
    }
  });

  // =======================
  // ASSIGNMENT SYSTEM API ROUTES
  // =======================

  // Teacher: Get all assignments created by this teacher
  app.get("/api/teacher/assignments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { status, subject } = req.query;

      let query = db
        .select({
          id: assignments.id,
          title: assignments.title,
          description: assignments.description,
          instructions: assignments.instructions,
          dueDate: assignments.dueDate,
          attachments: assignments.attachments,
          targetType: assignments.targetType,
          targetStudents: assignments.targetStudents,
          subject: assignments.subject,
          grade: assignments.grade,
          maxGrade: assignments.maxGrade,
          allowLateSubmission: assignments.allowLateSubmission,
          allowResubmission: assignments.allowResubmission,
          questions: assignments.questions,
          status: assignments.status,
          createdAt: assignments.createdAt,
          updatedAt: assignments.updatedAt,
          submissionCount: count(assignmentSubmissions.id)
        })
        .from(assignments)
        .leftJoin(assignmentSubmissions, eq(assignments.id, assignmentSubmissions.assignmentId))
        .where(eq(assignments.teacherId, teacherUuid))
        .groupBy(assignments.id)
        .orderBy(desc(assignments.createdAt));

      // Apply filters
      if (status && status !== 'all') {
        query = query.where(and(
          eq(assignments.teacherId, teacherUuid),
          eq(assignments.status, status as any)
        ));
      }

      if (subject && subject !== 'all') {
        query = query.where(and(
          eq(assignments.teacherId, teacherUuid),
          eq(assignments.subject, subject as string)
        ));
      }

      const assignmentList = await query;
      res.json({ success: true, data: assignmentList });

    } catch (error) {
      console.error('Get teacher assignments error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assignments' });
    }
  });

  // Teacher: Create new assignment
  app.post("/api/teacher/assignments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const {
        title,
        description,
        instructions,
        dueDate,
        attachments,
        questions,
        targetType = 'all',
        targetStudents,
        subject,
        grade,
        maxGrade = 100,
        allowLateSubmission = false,
        allowResubmission = false
      } = req.body;

      if (!title || !description || !dueDate || !subject || !grade) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: title, description, dueDate, subject, grade'
        });
      }

      const newAssignment = await db
        .insert(assignments)
        .values({
          teacherId: teacherUuid,
          title,
          description,
          instructions,
          dueDate: new Date(dueDate),
          attachments,
          questions,
          targetType,
          targetStudents,
          subject,
          grade: parseInt(grade),
          maxGrade,
          allowLateSubmission,
          allowResubmission,
          status: 'draft'
        })
        .returning();

      res.json({
        success: true,
        data: newAssignment[0],
        message: 'Assignment created successfully'
      });

    } catch (error) {
      console.error('Create assignment error:', error);
      res.status(500).json({ success: false, error: 'Failed to create assignment' });
    }
  });

  // Teacher: Update assignment
  app.put("/api/teacher/assignments/:assignmentId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { assignmentId } = req.params;
      const updateData = { ...req.body, updatedAt: new Date() };

      // Verify teacher owns this assignment
      const assignment = await db
        .select()
        .from(assignments)
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.teacherId, teacherUuid)
        ))
        .limit(1);

      if (assignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or unauthorized'
        });
      }

      const updatedAssignment = await db
        .update(assignments)
        .set(updateData)
        .where(eq(assignments.id, assignmentId))
        .returning();

      res.json({
        success: true,
        data: updatedAssignment[0],
        message: 'Assignment updated successfully'
      });

    } catch (error) {
      console.error('Update assignment error:', error);
      res.status(500).json({ success: false, error: 'Failed to update assignment' });
    }
  });

  // Teacher: Delete assignment
  app.delete("/api/teacher/assignments/:assignmentId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { assignmentId } = req.params;

      // Verify teacher owns this assignment
      const assignment = await db
        .select()
        .from(assignments)
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.teacherId, teacherUuid)
        ))
        .limit(1);

      if (assignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or unauthorized'
        });
      }

      // Delete related records first to handle foreign key constraints
      // Delete assignment comments first (they reference submissions)
      await db.delete(assignmentComments).where(
        eq(assignmentComments.submissionId, 
          sql`(SELECT id FROM ${assignmentSubmissions} WHERE assignment_id = ${assignmentId})`
        )
      );

      // Delete assignment submissions
      await db.delete(assignmentSubmissions).where(eq(assignmentSubmissions.assignmentId, assignmentId));

      // Finally delete the assignment
      await db.delete(assignments).where(eq(assignments.id, assignmentId));

      res.json({
        success: true,
        message: 'Assignment deleted successfully'
      });

    } catch (error) {
      console.error('Delete assignment error:', error);
      res.status(500).json({ success: false, error: 'Failed to delete assignment' });
    }
  });

  // Teacher: Publish assignment
  app.patch("/api/teacher/assignments/:assignmentId/publish", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { assignmentId } = req.params;

      const updatedAssignment = await db
        .update(assignments)
        .set({ 
          status: 'published',
          updatedAt: new Date()
        })
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.teacherId, teacherUuid)
        ))
        .returning();

      if (updatedAssignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or unauthorized'
        });
      }

      res.json({
        success: true,
        data: updatedAssignment[0],
        message: 'Assignment published successfully'
      });

    } catch (error) {
      console.error('Publish assignment error:', error);
      res.status(500).json({ success: false, error: 'Failed to publish assignment' });
    }
  });

  // Teacher: Get assignment submissions and grade them
  app.get("/api/teacher/assignments/:assignmentId/submissions", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { assignmentId } = req.params;

      // Verify teacher owns this assignment
      const assignment = await db
        .select()
        .from(assignments)
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.teacherId, teacherUuid)
        ))
        .limit(1);

      if (assignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or unauthorized'
        });
      }

      // Get all submissions for this assignment
      const submissions = await db
        .select({
          id: assignmentSubmissions.id,
          studentId: assignmentSubmissions.studentId,
          studentName: profiles.name,
          fileUrls: assignmentSubmissions.fileUrls,
          textContent: assignmentSubmissions.textContent,
          questionAnswers: assignmentSubmissions.questionAnswers,
          submittedAt: assignmentSubmissions.submittedAt,
          grade: assignmentSubmissions.grade,
          numericGrade: assignmentSubmissions.numericGrade,
          feedback: assignmentSubmissions.feedback,
          status: assignmentSubmissions.status,
          isLate: assignmentSubmissions.isLate,
          resubmissionCount: assignmentSubmissions.resubmissionCount,
          gradedAt: assignmentSubmissions.gradedAt
        })
        .from(assignmentSubmissions)
        .innerJoin(profiles, eq(assignmentSubmissions.studentId, profiles.userId))
        .where(eq(assignmentSubmissions.assignmentId, assignmentId))
        .orderBy(desc(assignmentSubmissions.submittedAt));

      res.json({ success: true, data: submissions });

    } catch (error) {
      console.error('Get assignment submissions error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch submissions' });
    }
  });

  // Teacher: Grade submission
  app.patch("/api/teacher/assignments/:assignmentId/submissions/:submissionId/grade", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'teacher') {
        return res.status(403).json({ success: false, error: 'Access denied. Teacher access required.' });
      }

      const teacherUuid = req.user.id;
      const { assignmentId, submissionId } = req.params;
      const { grade, numericGrade, feedback, allowResubmission } = req.body;

      // Verify teacher owns this assignment
      const assignment = await db
        .select()
        .from(assignments)
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.teacherId, teacherUuid)
        ))
        .limit(1);

      if (assignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or unauthorized'
        });
      }

      const gradedSubmission = await db
        .update(assignmentSubmissions)
        .set({
          grade,
          numericGrade,
          feedback,
          status: allowResubmission ? 'resubmit' : 'graded',
          gradedAt: new Date(),
          gradedBy: teacherUuid,
          updatedAt: new Date()
        })
        .where(and(
          eq(assignmentSubmissions.id, submissionId),
          eq(assignmentSubmissions.assignmentId, assignmentId)
        ))
        .returning();

      if (gradedSubmission.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Submission not found'
        });
      }

      res.json({
        success: true,
        data: gradedSubmission[0],
        message: 'Submission graded successfully'
      });

    } catch (error) {
      console.error('Grade submission error:', error);
      res.status(500).json({ success: false, error: 'Failed to grade submission' });
    }
  });

  // Student: Get assignments assigned to this student
  app.get("/api/student/assignments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'student') {
        return res.status(403).json({ success: false, error: 'Access denied. Student access required.' });
      }

      const studentUuid = req.user.id;
      const { status, subject } = req.query;

      // Get student's grade from their profile
      const studentProfile = await db
        .select({ grade: profiles.grade })
        .from(profiles)
        .where(eq(profiles.userId, studentUuid))
        .limit(1);

      if (studentProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Student profile not found' });
      }

      const studentGrade = studentProfile[0].grade;

      let query = db
        .select({
          id: assignments.id,
          title: assignments.title,
          description: assignments.description,
          instructions: assignments.instructions,
          dueDate: assignments.dueDate,
          attachments: assignments.attachments,
          questions: assignments.questions,
          subject: assignments.subject,
          assignmentGrade: assignments.grade,
          maxGrade: assignments.maxGrade,
          allowLateSubmission: assignments.allowLateSubmission,
          allowResubmission: assignments.allowResubmission,
          createdAt: assignments.createdAt,
          teacherName: profiles.name,
          submissionId: assignmentSubmissions.id,
          submissionStatus: assignmentSubmissions.status,
          receivedGrade: assignmentSubmissions.grade,
          feedback: assignmentSubmissions.feedback,
          submittedAt: assignmentSubmissions.submittedAt,
          gradedAt: assignmentSubmissions.gradedAt
        })
        .from(assignments)
        .innerJoin(profiles, eq(assignments.teacherId, profiles.userId))
        .leftJoin(assignmentSubmissions, and(
          eq(assignments.id, assignmentSubmissions.assignmentId),
          eq(assignmentSubmissions.studentId, studentUuid)
        ))
        .where(and(
          eq(assignments.status, 'published'),
          eq(assignments.grade, studentGrade), // Only show assignments for student's grade
          or(
            eq(assignments.targetType, 'all'),
            sql`${assignments.targetStudents} @> ${JSON.stringify([studentUuid])}`
          )
        ))
        .orderBy(desc(assignments.createdAt));

      // Apply filters
      if (status && status !== 'all') {
        if (status === 'pending') {
          query = query.where(and(
            eq(assignments.status, 'published'),
            isNull(assignmentSubmissions.id)
          ));
        } else if (status === 'submitted') {
          query = query.where(and(
            eq(assignments.status, 'published'),
            eq(assignmentSubmissions.status, 'submitted')
          ));
        } else if (status === 'graded') {
          query = query.where(and(
            eq(assignments.status, 'published'),
            eq(assignmentSubmissions.status, 'graded')
          ));
        }
      }

      if (subject && subject !== 'all') {
        query = query.where(and(
          eq(assignments.status, 'published'),
          eq(assignments.subject, subject as string)
        ));
      }

      const studentAssignments = await query;
      res.json({ success: true, data: studentAssignments });

    } catch (error) {
      console.error('Get student assignments error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assignments' });
    }
  });

  // Student: Submit assignment
  app.post("/api/student/assignments/:assignmentId/submit", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'student') {
        return res.status(403).json({ success: false, error: 'Access denied. Student access required.' });
      }

      const studentUuid = req.user.id;
      const { assignmentId } = req.params;
      const { fileUrls, textContent, questionAnswers } = req.body;


      // Check if assignment exists and is published first to determine validation
      const assignment = await db
        .select()
        .from(assignments)
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.status, 'published')
        ))
        .limit(1);

      if (assignment.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or not available'
        });
      }

      const assignmentData = assignment[0];
      const hasQuestions = assignmentData.questions && Array.isArray(assignmentData.questions) && assignmentData.questions.length > 0;
      
      // Validate submission content based on assignment type
      if (!hasQuestions && !fileUrls && !textContent) {
        return res.status(400).json({
          success: false,
          error: 'Either file uploads or text content is required'
        });
      }

      if (hasQuestions && !questionAnswers && !fileUrls && !textContent) {
        return res.status(400).json({
          success: false,
          error: 'Please answer the questions or provide text content/files'
        });
      }
      
      // Check if assignment is targeted to this student
      const isTargeted = assignmentData.targetType === 'all' || 
        (assignmentData.targetStudents && 
         Array.isArray(assignmentData.targetStudents) && 
         assignmentData.targetStudents.includes(studentUuid));

      if (!isTargeted) {
        return res.status(403).json({
          success: false,
          error: 'You are not assigned to this assignment'
        });
      }

      // Check for existing submission
      const existingSubmission = await db
        .select()
        .from(assignmentSubmissions)
        .where(and(
          eq(assignmentSubmissions.assignmentId, assignmentId),
          eq(assignmentSubmissions.studentId, studentUuid)
        ))
        .limit(1);

      const isLate = new Date() > new Date(assignmentData.dueDate);
      const now = new Date();

      if (existingSubmission.length > 0) {
        // Check if resubmission is allowed
        if (existingSubmission[0].status === 'graded' && !assignmentData.allowResubmission) {
          return res.status(400).json({
            success: false,
            error: 'Resubmission not allowed for this assignment'
          });
        }

        // Update existing submission
        const updatedSubmission = await db
          .update(assignmentSubmissions)
          .set({
            fileUrls,
            textContent,
            questionAnswers,
            status: 'submitted',
            isLate,
            resubmissionCount: sql`${assignmentSubmissions.resubmissionCount} + 1`,
            submittedAt: now,
            updatedAt: now
          })
          .where(eq(assignmentSubmissions.id, existingSubmission[0].id))
          .returning();

        res.json({
          success: true,
          data: updatedSubmission[0],
          message: 'Assignment resubmitted successfully'
        });
      } else {
        // Create new submission
        const newSubmission = await db
          .insert(assignmentSubmissions)
          .values({
            assignmentId,
            studentId: studentUuid,
            fileUrls,
            textContent,
            questionAnswers,
            submittedAt: now,
            isLate,
            status: 'submitted'
          })
          .returning();

        res.json({
          success: true,
          data: newSubmission[0],
          message: 'Assignment submitted successfully'
        });
      }

    } catch (error) {
      console.error('Submit assignment error:', error);
      res.status(500).json({ success: false, error: 'Failed to submit assignment' });
    }
  });

  // Student: Get assignment details
  app.get("/api/student/assignments/:assignmentId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'student') {
        return res.status(403).json({ success: false, error: 'Access denied. Student access required.' });
      }

      const studentUuid = req.user.id;
      const { assignmentId } = req.params;

      // Get assignment with teacher info and student's submission
      const assignmentDetails = await db
        .select({
          id: assignments.id,
          title: assignments.title,
          description: assignments.description,
          instructions: assignments.instructions,
          dueDate: assignments.dueDate,
          attachments: assignments.attachments,
          subject: assignments.subject,
          maxGrade: assignments.maxGrade,
          allowLateSubmission: assignments.allowLateSubmission,
          allowResubmission: assignments.allowResubmission,
          createdAt: assignments.createdAt,
          teacherName: profiles.name,
          teacherEmail: profiles.email,
          submissionId: assignmentSubmissions.id,
          submissionStatus: assignmentSubmissions.status,
          fileUrls: assignmentSubmissions.fileUrls,
          textContent: assignmentSubmissions.textContent,
          grade: assignmentSubmissions.grade,
          numericGrade: assignmentSubmissions.numericGrade,
          feedback: assignmentSubmissions.feedback,
          submittedAt: assignmentSubmissions.submittedAt,
          gradedAt: assignmentSubmissions.gradedAt,
          resubmissionCount: assignmentSubmissions.resubmissionCount
        })
        .from(assignments)
        .innerJoin(profiles, eq(assignments.teacherId, profiles.userId))
        .leftJoin(assignmentSubmissions, and(
          eq(assignments.id, assignmentSubmissions.assignmentId),
          eq(assignmentSubmissions.studentId, studentUuid)
        ))
        .where(and(
          eq(assignments.id, assignmentId),
          eq(assignments.status, 'published'),
          or(
            eq(assignments.targetType, 'all'),
            sql`${assignments.targetStudents} @> ${JSON.stringify([studentUuid])}`
          )
        ))
        .limit(1);

      if (assignmentDetails.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Assignment not found or not accessible'
        });
      }

      res.json({ success: true, data: assignmentDetails[0] });

    } catch (error) {
      console.error('Get assignment details error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assignment details' });
    }
  });

  // Assignment Comments - Add comment to submission
  app.post("/api/assignments/submissions/:submissionId/comments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { submissionId } = req.params;
      const { content, isPrivate = false } = req.body;
      const authorId = req.user.id;

      if (!content) {
        return res.status(400).json({
          success: false,
          error: 'Content is required'
        });
      }

      // Verify user has access to this submission
      const submission = await db
        .select({
          id: assignmentSubmissions.id,
          studentId: assignmentSubmissions.studentId,
          teacherId: assignments.teacherId
        })
        .from(assignmentSubmissions)
        .innerJoin(assignments, eq(assignmentSubmissions.assignmentId, assignments.id))
        .where(eq(assignmentSubmissions.id, submissionId))
        .limit(1);

      if (submission.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Submission not found'
        });
      }

      const submissionData = submission[0];
      const hasAccess = authorId === submissionData.studentId || 
                       authorId === submissionData.teacherId ||
                       req.user.role === 'admin';

      if (!hasAccess) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      const newComment = await db
        .insert(assignmentComments)
        .values({
          submissionId,
          authorId,
          content,
          isPrivate
        })
        .returning();

      res.json({
        success: true,
        data: newComment[0],
        message: 'Comment added successfully'
      });

    } catch (error) {
      console.error('Add comment error:', error);
      res.status(500).json({ success: false, error: 'Failed to add comment' });
    }
  });

  // Assignment Comments - Get comments for submission
  app.get("/api/assignments/submissions/:submissionId/comments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { submissionId } = req.params;
      const userId = req.user.id;

      // Verify user has access to this submission
      const submission = await db
        .select({
          id: assignmentSubmissions.id,
          studentId: assignmentSubmissions.studentId,
          teacherId: assignments.teacherId
        })
        .from(assignmentSubmissions)
        .innerJoin(assignments, eq(assignmentSubmissions.assignmentId, assignments.id))
        .where(eq(assignmentSubmissions.id, submissionId))
        .limit(1);

      if (submission.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Submission not found'
        });
      }

      const submissionData = submission[0];
      const hasAccess = userId === submissionData.studentId || 
                       userId === submissionData.teacherId ||
                       req.user.role === 'admin';

      if (!hasAccess) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      // Get comments with author info
      const comments = await db
        .select({
          id: assignmentComments.id,
          content: assignmentComments.content,
          isPrivate: assignmentComments.isPrivate,
          createdAt: assignmentComments.createdAt,
          authorId: assignmentComments.authorId,
          authorName: profiles.name,
          authorRole: profiles.role
        })
        .from(assignmentComments)
        .innerJoin(profiles, eq(assignmentComments.authorId, profiles.userId))
        .where(eq(assignmentComments.submissionId, submissionId))
        .orderBy(asc(assignmentComments.createdAt));

      res.json({ success: true, data: comments });

    } catch (error) {
      console.error('Get comments error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch comments' });
    }
  });

  // Admin: Get all assignments overview
  app.get("/api/admin/assignments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Access denied. Admin access required.' });
      }

      const { page = 1, limit = 20, status, subject, teacherId } = req.query;
      const offset = (parseInt(page as string) - 1) * parseInt(limit as string);

      let whereConditions = [];
      
      if (status && status !== 'all') {
        whereConditions.push(eq(assignments.status, status as any));
      }
      
      if (subject && subject !== 'all') {
        whereConditions.push(eq(assignments.subject, subject as string));
      }
      
      if (teacherId) {
        whereConditions.push(eq(assignments.teacherId, teacherId as string));
      }

      const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

      // Get assignments with teacher info and submission counts
      const assignmentsList = await db
        .select({
          id: assignments.id,
          title: assignments.title,
          description: assignments.description,
          subject: assignments.subject,
          dueDate: assignments.dueDate,
          status: assignments.status,
          createdAt: assignments.createdAt,
          teacherId: assignments.teacherId,
          teacherName: profiles.name,
          submissionCount: count(assignmentSubmissions.id),
          gradedCount: sql`COUNT(CASE WHEN ${assignmentSubmissions.status} = 'graded' THEN 1 END)`,
          avgGrade: avg(assignmentSubmissions.numericGrade)
        })
        .from(assignments)
        .innerJoin(profiles, eq(assignments.teacherId, profiles.userId))
        .leftJoin(assignmentSubmissions, eq(assignments.id, assignmentSubmissions.assignmentId))
        .where(whereClause)
        .groupBy(assignments.id, profiles.name)
        .orderBy(desc(assignments.createdAt))
        .limit(parseInt(limit as string))
        .offset(offset);

      // Get total count for pagination
      const totalCountResult = await db
        .select({ count: count() })
        .from(assignments)
        .where(whereClause);

      const totalCount = totalCountResult[0]?.count || 0;

      res.json({
        success: true,
        data: assignmentsList,
        pagination: {
          page: parseInt(page as string),
          limit: parseInt(limit as string),
          total: totalCount,
          totalPages: Math.ceil(totalCount / parseInt(limit as string))
        }
      });

    } catch (error) {
      console.error('Get admin assignments error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assignments overview' });
    }
  });

  // Admin: Get assignment analytics
  app.get("/api/admin/assignments/analytics", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      if (req.user?.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Access denied. Admin access required.' });
      }

      // Get overall statistics
      const stats = await db
        .select({
          totalAssignments: count(assignments.id),
          publishedAssignments: sql`COUNT(CASE WHEN ${assignments.status} = 'published' THEN 1 END)`,
          totalSubmissions: count(assignmentSubmissions.id),
          gradedSubmissions: sql`COUNT(CASE WHEN ${assignmentSubmissions.status} = 'graded' THEN 1 END)`,
          averageGrade: avg(assignmentSubmissions.numericGrade)
        })
        .from(assignments)
        .leftJoin(assignmentSubmissions, eq(assignments.id, assignmentSubmissions.assignmentId));

      // Get submissions by subject
      const subjectStats = await db
        .select({
          subject: assignments.subject,
          assignmentCount: count(assignments.id),
          submissionCount: count(assignmentSubmissions.id),
          averageGrade: avg(assignmentSubmissions.numericGrade)
        })
        .from(assignments)
        .leftJoin(assignmentSubmissions, eq(assignments.id, assignmentSubmissions.assignmentId))
        .groupBy(assignments.subject)
        .orderBy(desc(count(assignments.id)));

      // Get monthly submission trends (last 6 months)
      const monthlyTrends = await db
        .select({
          month: sql`DATE_TRUNC('month', ${assignmentSubmissions.submittedAt})`,
          submissionCount: count(assignmentSubmissions.id)
        })
        .from(assignmentSubmissions)
        .where(gte(assignmentSubmissions.submittedAt, sql`NOW() - INTERVAL '6 months'`))
        .groupBy(sql`DATE_TRUNC('month', ${assignmentSubmissions.submittedAt})`)
        .orderBy(sql`DATE_TRUNC('month', ${assignmentSubmissions.submittedAt})`);

      res.json({
        success: true,
        data: {
          overview: stats[0],
          subjectBreakdown: subjectStats,
          monthlyTrends
        }
      });

    } catch (error) {
      console.error('Get assignment analytics error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch assignment analytics' });
    }
  });

  // Admin Moderation - Search messages
  app.get("/api/admin/messages/search", async (req, res) => {
    try {
      const { query, userId, startDate, endDate, page = 1, limit = 50 } = req.query;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const admin = await getUserWithProfile(session[0].userId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ success: false, error: "Admin access required" });
      }

      // Build search conditions
      let conditions = [];
      
      if (query) {
        conditions.push(sql`${messages.content} ILIKE ${'%' + query + '%'}`);
      }
      
      if (userId) {
        conditions.push(or(
          eq(messages.senderId, userId as string),
          eq(messages.receiverId, userId as string)
        ));
      }
      
      if (startDate) {
        conditions.push(gte(messages.createdAt, new Date(startDate as string)));
      }
      
      if (endDate) {
        conditions.push(lte(messages.createdAt, new Date(endDate as string)));
      }

      const senderProfile = alias(profiles, 'senderProfile');
      const receiverProfile = alias(profiles, 'receiverProfile');

      const searchResults = await db.select({
        id: messages.id,
        senderId: messages.senderId,
        receiverId: messages.receiverId,
        content: messages.content,
        messageType: messages.messageType,
        isRead: messages.isRead,
        createdAt: messages.createdAt,
        senderName: sql<string>`COALESCE(${senderProfile.name}, 'Unknown User')`,
        senderRole: sql<string>`COALESCE(${senderProfile.role}, 'unknown')`,
        receiverName: sql<string>`COALESCE(${receiverProfile.name}, 'Unknown User')`,
        receiverRole: sql<string>`COALESCE(${receiverProfile.role}, 'unknown')`
      })
      .from(messages)
      .leftJoin(senderProfile, eq(senderProfile.userId, messages.senderId))
      .leftJoin(receiverProfile, eq(receiverProfile.userId, messages.receiverId))
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(desc(messages.createdAt))
      .limit(Number(limit))
      .offset((Number(page) - 1) * Number(limit));

      res.json({ success: true, data: searchResults });

    } catch (error) {
      console.error('Admin message search error:', error);
      res.status(500).json({ success: false, error: 'Failed to search messages' });
    }
  });

  // Admin Moderation - Delete message
  app.delete("/api/admin/messages/:messageId", async (req, res) => {
    try {
      const { messageId } = req.params;
      const { reason } = req.body;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const admin = await getUserWithProfile(session[0].userId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ success: false, error: "Admin access required" });
      }

      // Get message before deletion for logging
      const messageToDelete = await db.select()
        .from(messages)
        .where(eq(messages.id, messageId))
        .limit(1);

      if (messageToDelete.length === 0) {
        return res.status(404).json({ success: false, error: "Message not found" });
      }

      // Log moderation action
      await db.insert(moderationLogs).values({
        moderatorId: admin.userId,
        actionType: 'message_delete',
        targetType: 'message',
        targetId: messageId,
        reason: reason || 'No reason provided',
        originalContent: messageToDelete[0].content,
        details: { messageType: messageToDelete[0].messageType }
      });

      // Delete the message
      await db.delete(messages).where(eq(messages.id, messageId));

      res.json({ success: true, message: 'Message deleted successfully' });

    } catch (error) {
      console.error('Admin delete message error:', error);
      res.status(500).json({ success: false, error: 'Failed to delete message' });
    }
  });

  // Admin Moderation - Flag message
  app.post("/api/admin/messages/:messageId/flag", async (req, res) => {
    try {
      const { messageId } = req.params;
      const { reason, severity = 'medium' } = req.body;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const admin = await getUserWithProfile(session[0].userId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ success: false, error: "Admin access required" });
      }

      // Get message for logging
      const messageToFlag = await db.select()
        .from(messages)
        .where(eq(messages.id, messageId))
        .limit(1);

      if (messageToFlag.length === 0) {
        return res.status(404).json({ success: false, error: "Message not found" });
      }

      // Log moderation action
      await db.insert(moderationLogs).values({
        moderatorId: admin.userId,
        actionType: 'message_flag',
        targetType: 'message',
        targetId: messageId,
        reason: reason || 'Flagged for review',
        originalContent: messageToFlag[0].content,
        details: { severity, messageType: messageToFlag[0].messageType }
      });

      res.json({ success: true, message: 'Message flagged successfully' });

    } catch (error) {
      console.error('Admin flag message error:', error);
      res.status(500).json({ success: false, error: 'Failed to flag message' });
    }
  });

  // Admin - Get moderation logs
  app.get("/api/admin/moderation-logs", async (req, res) => {
    try {
      const { page = 1, limit = 50, actionType, moderatorId } = req.query;

      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const admin = await getUserWithProfile(session[0].userId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ success: false, error: "Admin access required" });
      }

      let conditions = [];
      
      if (actionType) {
        conditions.push(eq(moderationLogs.actionType, actionType as string));
      }
      
      if (moderatorId) {
        conditions.push(eq(moderationLogs.moderatorId, moderatorId as string));
      }

      const logs = await db.select({
        id: moderationLogs.id,
        moderatorId: moderationLogs.moderatorId,
        actionType: moderationLogs.actionType,
        targetType: moderationLogs.targetType,
        targetId: moderationLogs.targetId,
        reason: moderationLogs.reason,
        details: moderationLogs.details,
        originalContent: moderationLogs.originalContent,
        createdAt: moderationLogs.createdAt,
        moderatorName: sql<string>`moderator_profile.name`
      })
      .from(moderationLogs)
      .leftJoin(sql`profiles AS moderator_profile`, sql`moderator_profile.user_id = ${moderationLogs.moderatorId}`)
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(desc(moderationLogs.createdAt))
      .limit(Number(limit))
      .offset((Number(page) - 1) * Number(limit));

      res.json({ success: true, data: logs });

    } catch (error) {
      console.error('Get moderation logs error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch moderation logs' });
    }
  });

  // ======================= ENHANCED COMMUNITY ROUTES =======================
  
  // Get community groups
  app.get("/api/community/groups", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Get all public community groups with member info
      const groupsData = await db
        .select({
          id: communityGroups.id,
          name: communityGroups.name,
          description: communityGroups.description,
          createdBy: communityGroups.createdBy,
          memberCount: communityGroups.memberCount,
          postCount: communityGroups.postCount,
          isPrivate: communityGroups.isPrivate,
          tags: communityGroups.tags,
          avatarUrl: communityGroups.avatarUrl,
          createdAt: communityGroups.createdAt,
          creatorName: sql<string>`creator_profile.name`,
          creatorAvatar: sql<string>`creator_profile.avatar_url`,
          isMember: sql<boolean>`user_membership.user_id IS NOT NULL`
        })
        .from(communityGroups)
        .leftJoin(sql`profiles AS creator_profile`, sql`creator_profile.user_id = ${communityGroups.createdBy}`)
        .leftJoin(sql`community_group_members AS user_membership`, sql`user_membership.group_id = ${communityGroups.id} AND user_membership.user_id = ${user.id}`)
        .where(and(
          eq(communityGroups.isActive, true),
          or(
            eq(communityGroups.isPrivate, false), // Public groups
            sql`user_membership.user_id IS NOT NULL` // Or groups user is member of
          )
        ))
        .orderBy(desc(communityGroups.createdAt));

      res.json({
        success: true,
        data: groupsData
      });

    } catch (error) {
      console.error('Community groups error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch community groups' });
    }
  });

  // Create community group
  app.post("/api/community/groups", createRateLimit(60000, 2), async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // All students can create community groups

      const { name, description, isPrivate = false, tags = [] } = req.body;

      if (!name || !name.trim()) {
        return res.status(400).json({ success: false, error: 'Group name is required' });
      }

      // Create the group
      const [newGroup] = await db.insert(communityGroups).values({
        name: name.trim(),
        description: description?.trim() || null,
        createdBy: user.id,
        isPrivate,
        isPublic: !isPrivate,
        tags: tags.length > 0 ? tags : null,
        memberCount: 1,
        postCount: 0
      }).returning();

      // Add creator as first member
      await db.insert(communityGroupMembers).values({
        groupId: newGroup.id,
        userId: user.id,
        role: 'admin'
      });

      res.json({
        success: true,
        data: {
          ...newGroup,
          creatorName: user.name,
          creatorAvatar: user.avatarUrl,
          isMember: true
        }
      });

    } catch (error) {
      console.error('Create group error:', error);
      res.status(500).json({ success: false, error: 'Failed to create group' });
    }
  });

  // Join community group
  app.post("/api/community/groups/:groupId/join", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;

      // Check if group exists and is active
      const group = await db.select()
        .from(communityGroups)
        .where(and(
          eq(communityGroups.id, groupId),
          eq(communityGroups.isActive, true)
        ))
        .limit(1);

      if (group.length === 0) {
        return res.status(404).json({ success: false, error: 'Group not found' });
      }

      // Check if user is already a member
      const existingMembership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (existingMembership.length > 0) {
        return res.status(400).json({ success: false, error: 'Already a member of this group' });
      }

      // Add user to group
      await db.insert(communityGroupMembers).values({
        groupId,
        userId: user.id,
        role: 'member'
      });

      // Update member count
      await db.update(communityGroups)
        .set({ 
          memberCount: sql`${communityGroups.memberCount} + 1`,
          updatedAt: new Date()
        })
        .where(eq(communityGroups.id, groupId));

      res.json({
        success: true,
        message: 'Successfully joined group'
      });

    } catch (error) {
      console.error('Join group error:', error);
      res.status(500).json({ success: false, error: 'Failed to join group' });
    }
  });

  // Leave/Quit community group
  app.post("/api/community/groups/:groupId/leave", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;

      // Check if user is a member
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(400).json({ success: false, error: 'Not a member of this group' });
      }

      // Check if user is the group creator/admin
      const group = await db.select()
        .from(communityGroups)
        .where(eq(communityGroups.id, groupId))
        .limit(1);

      if (group.length > 0 && group[0].createdBy === user.id) {
        return res.status(400).json({ success: false, error: 'Group creator cannot leave the group. Transfer ownership or delete the group instead.' });
      }

      // Remove user from group
      await db.delete(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ));

      // Update member count
      await db.update(communityGroups)
        .set({ 
          memberCount: sql`${communityGroups.memberCount} - 1`,
          updatedAt: new Date()
        })
        .where(eq(communityGroups.id, groupId));

      res.json({
        success: true,
        message: 'Successfully left group'
      });

    } catch (error) {
      console.error('Leave group error:', error);
      res.status(500).json({ success: false, error: 'Failed to leave group' });
    }
  });

  // Remove user from group (Group admin/creator only)
  app.post("/api/community/groups/:groupId/remove-user", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({ success: false, error: 'User ID is required' });
      }

      // Check if current user is group admin or creator
      const userMembership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      const group = await db.select()
        .from(communityGroups)
        .where(eq(communityGroups.id, groupId))
        .limit(1);

      if (group.length === 0) {
        return res.status(404).json({ success: false, error: 'Group not found' });
      }

      const isCreator = group[0].createdBy === user.id;
      const isAdmin = userMembership.length > 0 && userMembership[0].role === 'admin';

      if (!isCreator && !isAdmin) {
        return res.status(403).json({ success: false, error: 'Only group admins can remove users' });
      }

      // Prevent removing the group creator
      if (group[0].createdBy === userId) {
        return res.status(400).json({ success: false, error: 'Cannot remove the group creator' });
      }

      // Check if target user is a member
      const targetMembership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, userId)
        ))
        .limit(1);

      if (targetMembership.length === 0) {
        return res.status(400).json({ success: false, error: 'User is not a member of this group' });
      }

      // Remove user from group
      await db.delete(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, userId)
        ));

      // Update member count
      await db.update(communityGroups)
        .set({ 
          memberCount: sql`${communityGroups.memberCount} - 1`,
          updatedAt: new Date()
        })
        .where(eq(communityGroups.id, groupId));

      res.json({
        success: true,
        message: 'User successfully removed from group'
      });

    } catch (error) {
      console.error('Remove user from group error:', error);
      res.status(500).json({ success: false, error: 'Failed to remove user from group' });
    }
  });

  // Delete community group (Admin only or group creator)
  app.delete("/api/community/groups/:groupId", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;

      // Check if group exists
      const group = await db.select()
        .from(communityGroups)
        .where(eq(communityGroups.id, groupId))
        .limit(1);

      if (group.length === 0) {
        return res.status(404).json({ success: false, error: 'Group not found' });
      }

      // Check if user is admin or group creator
      const isAdmin = user.role === 'admin';
      const isCreator = group[0].createdBy === user.id;

      if (!isAdmin && !isCreator) {
        return res.status(403).json({ success: false, error: 'Only admins or group creators can delete groups' });
      }

      // Delete group members first (foreign key constraint)
      await db.delete(communityGroupMembers)
        .where(eq(communityGroupMembers.groupId, groupId));

      // Delete group posts
      await db.delete(communityPosts)
        .where(eq(communityPosts.groupId, groupId));

      // Delete the group
      await db.delete(communityGroups)
        .where(eq(communityGroups.id, groupId));

      res.json({
        success: true,
        message: 'Group successfully deleted'
      });

    } catch (error) {
      console.error('Delete group error:', error);
      res.status(500).json({ success: false, error: 'Failed to delete group' });
    }
  });

  // Get group members
  app.get("/api/community/groups/:groupId/members", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;

      // Check if user is a member of the group or admin
      const userMembership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (userMembership.length === 0 && user.role !== 'admin') {
        return res.status(403).json({ success: false, error: 'Only group members can view member list' });
      }

      // Get all group members with their profile info
      const members = await db
        .select({
          id: communityGroupMembers.id,
          userId: communityGroupMembers.userId,
          role: communityGroupMembers.role,
          joinedAt: communityGroupMembers.joinedAt,
          name: sql<string>`profile.name`,
          avatarUrl: sql<string>`profile.avatar_url`,
          email: sql<string>`profile.email`
        })
        .from(communityGroupMembers)
        .leftJoin(sql`profiles AS profile`, sql`profile.user_id = ${communityGroupMembers.userId}`)
        .where(eq(communityGroupMembers.groupId, groupId))
        .orderBy(desc(communityGroupMembers.joinedAt));

      res.json({
        success: true,
        data: members
      });

    } catch (error) {
      console.error('Get group members error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch group members' });
    }
  });

  // Add reaction to post or reply
  app.post("/api/community/reactions", createRateLimit(1000, 30), async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { targetType, targetId, emoji } = req.body;

      if (!targetType || !targetId || !emoji) {
        return res.status(400).json({ success: false, error: 'Missing required fields' });
      }

      if (!['post', 'reply'].includes(targetType)) {
        return res.status(400).json({ success: false, error: 'Invalid target type' });
      }

      // Check if user already reacted with this emoji
      const existingReaction = await db.select()
        .from(communityReactions)
        .where(and(
          eq(communityReactions.userId, user.id),
          eq(communityReactions.targetType, targetType),
          eq(communityReactions.targetId, targetId),
          eq(communityReactions.emoji, emoji)
        ))
        .limit(1);

      if (existingReaction.length > 0) {
        // Remove existing reaction (toggle off)
        await db.delete(communityReactions)
          .where(eq(communityReactions.id, existingReaction[0].id));
      } else {
        // Add new reaction
        await db.insert(communityReactions).values({
          userId: user.id,
          targetType,
          targetId,
          emoji
        });
      }

      res.json({
        success: true,
        message: existingReaction.length > 0 ? 'Reaction removed' : 'Reaction added'
      });

    } catch (error) {
      console.error('Add reaction error:', error);
      res.status(500).json({ success: false, error: 'Failed to add reaction' });
    }
  });

  // Add reply to post
  app.post("/api/community/replies", createRateLimit(3000, 10), async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { postId, content, replyToId, isAnonymous = false } = req.body;

      if (!postId || !content?.trim()) {
        return res.status(400).json({ success: false, error: 'Post ID and content are required' });
      }

      // Check if post exists
      const post = await db.select()
        .from(communityPosts)
        .where(eq(communityPosts.id, postId))
        .limit(1);

      if (post.length === 0) {
        return res.status(404).json({ success: false, error: 'Post not found' });
      }

      // Rate limiting for replies (use profiles.userId for comparison)
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'User profile not found' });
      }

      const authorId = userProfile[0].userId;

      const recentReply = await db.select()
        .from(communityReplies)
        .where(and(
          eq(communityReplies.authorId, authorId),
          gt(communityReplies.createdAt, new Date(Date.now() - 30000)) // 30 seconds
        ))
        .limit(1);

      if (recentReply.length > 0) {
        return res.status(429).json({ success: false, error: 'Please wait before replying again' });
      }

      // Create reply
      const [newReply] = await db.insert(communityReplies).values({
        postId: postId,   // Only postId exists in database
        authorId: authorId, // Use the correct user ID from profile
        content: content.trim(),
        isAnonymous
      }).returning();

      // Update post replies count (skip for now as field doesn't exist in schema)
      // await db.update(communityPosts)
      //   .set({ 
      //     replies: sql`${communityPosts.replies} + 1`,
      //     updatedAt: new Date()
      //   })
      //   .where(eq(communityPosts.id, postId));

      // Create notification for post author (don't notify yourself)
      if (post[0].authorId !== authorId) {
        await db.insert(notifications).values({
          userId: post[0].authorId,
          title: 'New Comment',
          message: `${isAnonymous ? 'Someone' : user.name} commented on your post`,
          type: 'info',
          actionUrl: `/community/posts/${postId}`,
          isRead: false
        });
      }

      res.json({
        success: true,
        data: {
          id: newReply.id,
          postId: newReply.postId,
          content: newReply.content,
          createdAt: newReply.createdAt,
          author: {
            id: authorId,
            name: isAnonymous ? 'Anonymous Student' : user.name,
            profilePic: isAnonymous ? null : user.avatarUrl
          }
        }
      });

    } catch (error) {
      console.error('Add reply error:', error);
      res.status(500).json({ success: false, error: 'Failed to add reply' });
    }
  });

  // Get replies for a specific post
  app.get("/api/community/posts/:postId/replies", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { postId } = req.params;

      // Get all replies for the post  
      const replies = await db
        .select()
        .from(communityReplies)
        .where(eq(communityReplies.postId, postId))
        .orderBy(asc(communityReplies.createdAt));
        
      // Then enrich with author data separately
      const enrichedReplies = await Promise.all(replies.map(async (reply) => {
        let authorName = 'Anonymous Student';
        let authorAvatar = null;
        
        // Get author info if not anonymous
        if (!reply.isAnonymous && reply.authorId) {
          try {
            const author = await db
              .select({
                name: profiles.name,
                avatarUrl: profiles.avatarUrl,
              })
              .from(profiles)
              .where(eq(profiles.userId, reply.authorId))
              .limit(1);
            
            if (author.length > 0) {
              authorName = author[0].name;
              authorAvatar = author[0].avatarUrl;
            }
          } catch (error) {
            console.error('Error fetching reply author:', error);
          }
        }
        
        return {
          id: reply.id,
          postId: reply.postId,
          content: reply.content,
          communityReactions: reply.upvotes || 0,
          createdAt: reply.createdAt,
          authorId: reply.authorId,
          authorName: authorName,
          authorAvatarUrl: authorAvatar,
          author: {
            id: reply.authorId,
            name: authorName,
            profilePic: authorAvatar
          }
        };
      }));

      res.json({ success: true, data: enrichedReplies });

    } catch (error) {
      console.error('Get replies error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch replies' });
    }
  });

  // Get community topics 
  app.get("/api/community/posts", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId, search } = req.query;

      // Get all topics with proper Drizzle query and join author information
      let conditions = [eq(communityPosts.isModerated, false)];
      
      if (groupId) {
        conditions.push(eq(communityPosts.groupId, groupId as string));
      }
      
      if (search && typeof search === 'string') {
        conditions.push(or(
          sql`${communityPosts.title} ILIKE ${'%' + search + '%'}`,
          sql`${communityPosts.content} ILIKE ${'%' + search + '%'}`
        ));
      }

      // Get posts first without complex joins that cause issues
      const posts = await db
        .select()
        .from(communityPosts)
        .where(and(...conditions))
        .orderBy(desc(communityPosts.createdAt))
        .limit(20);

      // Then enrich with author data separately
      const topics = await Promise.all(posts.map(async (post) => {
        let authorName = 'Anonymous Student';
        let authorAvatar = null;
        let authorPronouns = null;
        let groupName = null;

        // Get author info if not anonymous
        if (!post.isAnonymous && post.authorId) {
          try {
            const author = await db
              .select({
                name: profiles.name,
                avatarUrl: profiles.avatarUrl,
                pronouns: profiles.pronouns
              })
              .from(profiles)
              .where(eq(profiles.userId, post.authorId))
              .limit(1);
            
            if (author.length > 0) {
              authorName = author[0].name;
              authorAvatar = author[0].avatarUrl;
              authorPronouns = author[0].pronouns;
            }
          } catch (error) {
            console.error('Error fetching author:', error);
          }
        }

        // Get group info if exists
        if (post.groupId) {
          try {
            const group = await db
              .select({ name: communityGroups.name })
              .from(communityGroups)
              .where(eq(communityGroups.id, post.groupId))
              .limit(1);
            
            if (group.length > 0) {
              groupName = group[0].name;
            }
          } catch (error) {
            console.error('Error fetching group:', error);
          }
        }

        return {
          id: post.id,
          title: post.title,
          content: post.content,
          communityReactions: post.communityReactions || 0,
          replyCount: 0, // Will be calculated separately if needed
          upvotes: post.upvotes || 0,
          downvotes: post.downvotes || 0,
          subject: post.subject,
          grade: post.grade,
          createdAt: post.createdAt,
          updatedAt: post.updatedAt,
          author: {
            id: post.authorId,
            name: authorName,
            profilePic: authorAvatar
          },
          groupName
        };
      }));

      res.json({ success: true, data: topics });

    } catch (error) {
      console.error('Community topics error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch community topics' });
    }
  });

  // Create community topic (Premium only)
  app.post("/api/community/posts", createRateLimit(10000, 3), async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // All students can create community topics

      const { 
        title, 
        content, 
        subject, 
        grade, 
        topicType = 'discussion',
        tags = [], 
        isAnonymous = false, 
        groupId 
      } = req.body;

      if (!title?.trim() || !content?.trim()) {
        return res.status(400).json({ success: false, error: 'Title and content are required' });
      }

      // Validate topic type
      const validTopicTypes = ['discussion', 'question', 'study_group', 'announcement'];
      if (!validTopicTypes.includes(topicType)) {
        return res.status(400).json({ success: false, error: 'Invalid topic type' });
      }

      // If posting to a group, verify membership
      if (groupId) {
        const membership = await db.select()
          .from(communityGroupMembers)
          .where(and(
            eq(communityGroupMembers.groupId, groupId),
            eq(communityGroupMembers.userId, user.id)
          ))
          .limit(1);

        if (membership.length === 0) {
          return res.status(403).json({ success: false, error: 'You must be a member of this group to post' });
        }
      }

      // Get user profile to get the correct user ID
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'User profile not found' });
      }

      const authorId = userProfile[0].userId;

      // Create new topic
      const [newTopic] = await db.insert(communityPosts).values({
        authorId: authorId, // Use the correct user ID from profile
        groupId: groupId || null,
        title: title.trim(),
        content: content.trim(),
        subject: subject?.trim() || null,
        grade: grade ? parseInt(grade) : null,
        topicType,
        tags: tags.length > 0 ? tags : null,
        isAnonymous
      }).returning();

      // Update group post count if applicable
      if (groupId) {
        await db.update(communityGroups)
          .set({ 
            postCount: sql`${communityGroups.postCount} + 1`,
            updatedAt: new Date()
          })
          .where(eq(communityGroups.id, groupId));
      }

      res.json({
        success: true,
        data: {
          id: newTopic.id,
          title: newTopic.title,
          content: newTopic.content,
          communityReactions: newTopic.communityReactions || 0,
          replies: 0,
          upvotes: newTopic.upvotes || 0,
          downvotes: newTopic.downvotes || 0,
          subject: newTopic.subject,
          grade: newTopic.grade,
          views: newTopic.views || 0,
          createdAt: newTopic.createdAt,
          author: {
            id: authorId,
            name: isAnonymous ? 'Anonymous Student' : user.name,
            profilePic: isAnonymous ? null : user.avatarUrl
          }
        }
      });

    } catch (error) {
      console.error('Create topic error:', error);
      res.status(500).json({ success: false, error: 'Failed to create topic' });
    }
  });

  // Like/Unlike community post
  app.post("/api/community/posts/:postId/like", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { postId } = req.params;

      // Check if post exists
      const post = await db.select()
        .from(communityPosts)
        .where(eq(communityPosts.id, postId))
        .limit(1);

      if (post.length === 0) {
        return res.status(404).json({ success: false, error: 'Post not found' });
      }

      // Check if user already liked this post
      const existingReaction = await db.select()
        .from(communityReactions)
        .where(and(
          eq(communityReactions.targetId, postId),
          eq(communityReactions.targetType, 'post'),
          eq(communityReactions.userId, user.id)
        ))
        .limit(1);

      if (existingReaction.length > 0) {
        // Remove like (toggle off)
        await db.delete(communityReactions)
          .where(eq(communityReactions.id, existingReaction[0].id));
        
        // Decrease communityReactions count
        await db.update(communityPosts)
          .set({ 
            likes: Math.max(0, (post[0].likes || 0) - 1),
            updatedAt: new Date()
          })
          .where(eq(communityPosts.id, postId));

        res.json({ success: true, message: 'Like removed', isLiked: false });
      } else {
        // Add like
        await db.insert(communityReactions).values({
          userId: user.id,
          targetId: postId,
          targetType: 'post',
          emoji: 'ðŸ‘'
        });
        
        // Increase communityReactions count
        await db.update(communityPosts)
          .set({ 
            likes: (post[0].likes || 0) + 1,
            updatedAt: new Date()
          })
          .where(eq(communityPosts.id, postId));

        // Create notification for post author (don't notify yourself)
        if (post[0].authorId !== user.id) {
          // Get liker's name
          const [liker] = await db.select({ name: profiles.name })
            .from(profiles)
            .where(eq(profiles.userId, user.id))
            .limit(1);

          await db.insert(notifications).values({
            userId: post[0].authorId,
            title: 'New Like',
            message: `${liker?.name || 'Someone'} liked your post`,
            type: 'info',
            actionUrl: `/community/posts/${postId}`,
            isRead: false
          });
        }

        res.json({ success: true, message: 'Post liked', isLiked: true });
      }

    } catch (error) {
      console.error('Like post error:', error);
      res.status(500).json({ success: false, error: 'Failed to like post' });
    }
  });


  // Edit community post
  app.put("/api/community/posts/:postId", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { postId } = req.params;
      const { title, content } = req.body;

      if (!title?.trim() || !content?.trim()) {
        return res.status(400).json({ success: false, error: 'Title and content are required' });
      }

      // Check if post exists and user owns it
      const post = await db.select()
        .from(communityPosts)
        .where(eq(communityPosts.id, postId))
        .limit(1);

      if (post.length === 0) {
        return res.status(404).json({ success: false, error: 'Post not found' });
      }

      // Get user profile to check authorization
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      // Check if user owns the post
      if (post[0].authorId !== userProfile[0].userId) {
        return res.status(403).json({ success: false, error: 'You can only edit your own posts' });
      }

      // Update the post
      const [updatedPost] = await db.update(communityPosts)
        .set({ 
          title: title.trim(),
          content: content.trim(),
          updatedAt: new Date()
        })
        .where(eq(communityPosts.id, postId))
        .returning();

      res.json({ 
        success: true, 
        message: 'Post updated successfully',
        data: {
          ...updatedPost,
          author: {
            id: userProfile[0].userId,
            name: user.name,
            profilePic: user.avatarUrl || null
          }
        }
      });

    } catch (error) {
      console.error('Edit post error:', error);
      res.status(500).json({ success: false, error: 'Failed to update post' });
    }
  });

  // ======================= MESSAGING GROUPS API =======================
  
  // Get user's joined groups for messaging interface
  app.get("/api/groups", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Get user's profile ID for unread count queries
      const userProfile = await db.select({ id: profiles.id })
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(400).json({ success: false, error: 'Profile not found' });
      }

      const currentUserProfileId = userProfile[0].id;

      // Get groups where user is a member
      const userGroups = await db
        .select({
          id: communityGroups.id,
          name: communityGroups.name,
          description: communityGroups.description,
          memberCount: communityGroups.memberCount,
          createdAt: communityGroups.createdAt,
          avatarUrl: communityGroups.avatarUrl,
          isMember: sql<boolean>`true` // Always true since we filter by membership
        })
        .from(communityGroups)
        .innerJoin(communityGroupMembers, and(
          eq(communityGroupMembers.groupId, communityGroups.id),
          eq(communityGroupMembers.userId, user.id)
        ))
        .where(eq(communityGroups.isActive, true))
        .orderBy(desc(communityGroups.createdAt));

      // Enrich groups with last message and unread count
      const enrichedGroups = await Promise.all(userGroups.map(async (group) => {
        // Get last message for this group
        const lastMessageResult = await db
          .select({
            content: messages.content,
            createdAt: messages.createdAt,
            messageType: messages.messageType,
            senderName: profiles.name
          })
          .from(messages)
          .leftJoin(profiles, eq(messages.senderId, profiles.id))
          .where(eq(messages.groupId, group.id))
          .orderBy(desc(messages.createdAt))
          .limit(1);

        // Get unread count for this user in this group
        const unreadCountResult = await db
          .select({ count: sql<number>`count(*)::int` })
          .from(messages)
          .where(and(
            eq(messages.groupId, group.id),
            ne(messages.senderId, currentUserProfileId),
            eq(messages.isRead, false)
          ));

        const lastMessage = lastMessageResult[0];
        const unreadCount = unreadCountResult[0]?.count || 0;

        // Format last message preview
        let actualLastMessage = '';
        if (lastMessage) {
          if (lastMessage.messageType === 'text') {
            const senderPrefix = lastMessage.senderName ? `${lastMessage.senderName}: ` : '';
            actualLastMessage = `${senderPrefix}${lastMessage.content || ''}`;
          } else if (lastMessage.messageType === 'image') {
            actualLastMessage = `${lastMessage.senderName || 'Someone'} sent a photo`;
          } else if (lastMessage.messageType === 'voice') {
            actualLastMessage = `${lastMessage.senderName || 'Someone'} sent a voice message`;
          } else if (lastMessage.messageType === 'document') {
            actualLastMessage = `${lastMessage.senderName || 'Someone'} sent a document`;
          } else {
            actualLastMessage = `${lastMessage.senderName || 'Someone'} sent a message`;
          }
        }

        return {
          ...group,
          actualLastMessage,
          lastMessageTime: lastMessage?.createdAt || group.createdAt,
          unreadCount
        };
      }));

      res.json({
        success: true,
        data: enrichedGroups
      });

    } catch (error) {
      console.error('Get user groups error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch user groups' });
    }
  });

  // Get messages for a specific group
  app.get("/api/groups/:groupId/messages", async (req, res) => {
    try {
      const { groupId } = req.params;
      const { page = 1, limit = 50 } = req.query;
      
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Check if user is a member of the group
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: 'You are not a member of this group' });
      }

      // Get group messages with sender info
      const groupMessages = await db
        .select({
          id: messages.id,
          senderId: messages.senderId,
          groupId: messages.groupId,
          content: messages.content,
          messageType: messages.messageType,
          fileUrl: messages.fileUrl,
          fileType: messages.fileType,
          createdAt: messages.createdAt,
          senderName: sql<string>`sender_profile.name`,
          senderAvatarUrl: sql<string>`sender_profile.avatar_url`
        })
        .from(messages)
        .leftJoin(sql`profiles AS sender_profile`, sql`sender_profile.id = ${messages.senderId}`)
        .where(eq(messages.groupId, groupId))
        .orderBy(desc(messages.createdAt))
        .limit(parseInt(limit as string))
        .offset((parseInt(page as string) - 1) * parseInt(limit as string));

      res.json({
        success: true,
        data: groupMessages.reverse() // Oldest first for chat display
      });

    } catch (error) {
      console.error('Get group messages error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch group messages' });
    }
  });

  // Send message to a group
  app.post("/api/groups/:groupId/messages", async (req, res) => {
    try {
      const { groupId } = req.params;
      const { content, messageType = 'text' } = req.body;
      
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      if (!content?.trim()) {
        return res.status(400).json({ success: false, error: 'Message content is required' });
      }

      // Check if user is a member of the group
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: 'You are not a member of this group' });
      }

      // Get sender profile info
      const senderProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (senderProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'Sender profile not found' });
      }

      // Insert the message
      const [newMessage] = await db.insert(messages).values({
        senderId: senderProfile[0].id,
        groupId: groupId,
        content: content.trim(),
        messageType,
      }).returning();

      // Broadcast to group members via WebSocket if available
      try {
        const groupMembers = await db.select({ userId: communityGroupMembers.userId })
          .from(communityGroupMembers)
          .where(eq(communityGroupMembers.groupId, groupId));

        const messageData = {
          type: 'new_group_message',
          data: {
            ...newMessage,
            senderName: senderProfile[0].name,
            senderAvatarUrl: senderProfile[0].avatarUrl,
            groupId
          }
        };

        groupMembers.forEach(member => {
          const memberWs = (global as any).wsClients?.get(member.userId);
          if (memberWs && memberWs.readyState === 1) {
            memberWs.send(JSON.stringify(messageData));
          }
        });
      } catch (wsError) {
        console.log('WebSocket broadcast failed:', wsError);
      }

      res.json({
        success: true,
        data: {
          ...newMessage,
          senderName: senderProfile[0].name,
          senderAvatarUrl: senderProfile[0].avatarUrl,
          groupId
        }
      });

    } catch (error) {
      console.error('Send group message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send group message' });
    }
  });

  // Update group settings (name and avatar)
  app.put("/api/groups/:groupId", async (req, res) => {
    try {
      const { groupId } = req.params;
      const { name, description } = req.body;
      
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Check if user is a member of the group
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: 'You are not a member of this group' });
      }

      // Validate input
      if (name && name.trim().length < 1) {
        return res.status(400).json({ success: false, error: 'Group name cannot be empty' });
      }

      if (name && name.trim().length > 50) {
        return res.status(400).json({ success: false, error: 'Group name cannot exceed 50 characters' });
      }

      // Prepare update data
      const updateData: any = {};
      if (name !== undefined) {
        updateData.name = name.trim();
      }
      if (description !== undefined) {
        updateData.description = description?.trim() || null;
      }

      // Update the group
      const [updatedGroup] = await db
        .update(communityGroups)
        .set(updateData)
        .where(eq(communityGroups.id, groupId))
        .returning();

      if (!updatedGroup) {
        return res.status(404).json({ success: false, error: 'Group not found' });
      }

      res.json({
        success: true,
        message: 'Group updated successfully',
        data: updatedGroup
      });

    } catch (error) {
      console.error('Update group error:', error);
      res.status(500).json({ success: false, error: 'Failed to update group' });
    }
  });

  // Update group avatar
  app.put("/api/groups/:groupId/avatar", upload.single('avatar'), async (req, res) => {
    try {
      const { groupId } = req.params;
      
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Check if user is a member of the group
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: 'You are not a member of this group' });
      }

      if (!req.file) {
        return res.status(400).json({ success: false, error: 'No avatar file provided' });
      }

      // Upload avatar to Cloudinary
      const uploadResult = await cloudinaryStorage.uploadFile(
        req.file.buffer,
        req.file.originalname,
        req.file.mimetype,
        'group-avatars'
      );

      if (!uploadResult.success) {
        return res.status(500).json({ success: false, error: 'Failed to upload avatar' });
      }

      // Update group with new avatar URL
      const [updatedGroup] = await db
        .update(communityGroups)
        .set({ avatarUrl: uploadResult.url })
        .where(eq(communityGroups.id, groupId))
        .returning();

      if (!updatedGroup) {
        return res.status(404).json({ success: false, error: 'Group not found' });
      }

      res.json({
        success: true,
        message: 'Group avatar updated successfully',
        data: {
          avatarUrl: uploadResult.url
        }
      });

    } catch (error) {
      console.error('Update group avatar error:', error);
      res.status(500).json({ success: false, error: 'Failed to update group avatar' });
    }
  });


  // Admin - Get all teacher-student assignments
  app.get("/api/admin/teacher-assignments", async (req, res) => {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: "Authorization required" });
      }

      const session = await db
        .select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, authHeader.replace('Bearer ', '')),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        return res.status(401).json({ success: false, error: "Invalid session" });
      }

      const admin = await getUserWithProfile(session[0].userId);
      if (!admin || admin.role !== 'admin') {
        return res.status(403).json({ success: false, error: "Admin access required" });
      }

      // Get all teacher-student assignments with names
      const assignments = await db.select({
        teacherId: teacherStudentAssignments.teacherId,
        studentId: teacherStudentAssignments.studentId,
        isActive: teacherStudentAssignments.isActive,
        createdAt: teacherStudentAssignments.assignedAt,
        teacherName: sql<string>`teacher_profile.name`,
        studentName: sql<string>`student_profile.name`
      })
      .from(teacherStudentAssignments)
      .leftJoin(sql`profiles AS teacher_profile`, sql`teacher_profile.user_id = ${teacherStudentAssignments.teacherId}`)
      .leftJoin(sql`profiles AS student_profile`, sql`student_profile.user_id = ${teacherStudentAssignments.studentId}`)
      .orderBy(desc(teacherStudentAssignments.assignedAt));

      res.json({ success: true, data: assignments });

    } catch (error) {
      console.error('Get teacher assignments error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch teacher assignments' });
    }
  });

  // ======================= STUDENT SETTINGS ROUTES =======================

  // Helper function to get user from session
  async function getUserFromSession(authHeader: string) {
    if (!authHeader) return null;
    
    const sessionId = authHeader.replace('Bearer ', '');
    
    try {
      // First, find the user session
      const session = await db.select()
        .from(userLoginSessions)
        .where(and(
          eq(userLoginSessions.sessionId, sessionId),
          eq(userLoginSessions.isActive, true),
          gt(userLoginSessions.expiresAt, new Date())
        ))
        .limit(1);

      if (session.length === 0) {
        console.log('ðŸ” Session not found or expired:', sessionId);
        return null;
      }

      // Then get the user and profile data
      const userProfile = await db.select({
        id: users.id,
        email: users.email,
        name: profiles.name,
        age: profiles.age,
        grade: profiles.grade,
        country: profiles.country,
        countryId: profiles.countryId,
        avatarUrl: profiles.avatarUrl,
        role: profiles.role,
        pronouns: profiles.pronouns,
        bio: profiles.bio,
        educationLevel: profiles.educationLevel,
        subscriptionTier: profiles.subscriptionTier,
        legacyPlan: profiles.legacyPlan,
        planExpiry: profiles.planExpiry,
        stripeCustomerId: profiles.stripeCustomerId,
        stripeSubscriptionId: profiles.stripeSubscriptionId
      })
      .from(users)
      .innerJoin(profiles, eq(users.id, profiles.userId))
      .where(eq(users.id, session[0].userId))
      .limit(1);
      
      return userProfile.length > 0 ? userProfile[0] : null;
    } catch (error) {
      console.error('getUserFromSession error:', error);
      return null;
    }
  }

  // Update user profile with enhanced Behance-style fields
  app.put('/api/settings/profile', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }


      // Define allowed profile fields that can be updated
      const allowedFields = [
        'name', 'displayName', 'email', 'age', 'grade', 'gradeLevel', 'educationLevel', 
        'subscriptionTier', 'country', 'countryId', 'gradeSystem', 'avatarUrl', 
        'profilePicture', 'role', 'status', 'pronouns', 'bio', 'qualifications', 
        'experience', 'availableHours', 'hourlyRate', 'legacyPlan', 'planExpiry', 
        'stripeCustomerId', 'stripeSubscriptionId', 'isTest', 'isOnline', 'lastSeen', 
        'lastPricingShown', 'availabilitySettings', 'approvalStatus', 'approvedBy', 
        'approvedAt', 'rejectionReason', 'adminNotes', 'professionalTitle', 'tagline', 
        'coverImageUrl', 'skills', 'socialLinks', 'websiteUrl', 'portfolioLinks', 
        'location', 'locationLat', 'locationLng', 'timeZone', 'yearsOfExperience', 
        'workAvailability', 'responseTime', 'professionalStatement', 'languages', 
        'completedProjects', 'clientReviews', 'averageRating', 'profileViews', 
        'profileVisibility', 'profileCompleteness', 'featuredWorkIds', 'verified', 
        'verificationBadges', 'contactEmail', 'phoneNumber'
      ];

      // Filter request body to only include allowed fields
      const updateData: any = {};
      for (const [key, value] of Object.entries(req.body)) {
        if (allowedFields.includes(key)) {
          updateData[key] = value;
        }
      }

      // Add updated timestamp
      updateData.updatedAt = new Date();

      // Update profile with filtered data
      
      await db.update(profiles)
        .set(updateData)
        .where(eq(profiles.userId, user.id));

      res.json({ success: true, message: 'Profile updated successfully' });

    } catch (error) {
      console.error('Profile update error:', error);
      res.status(500).json({ success: false, error: 'Failed to update profile' });
    }
  });

  // Get user notification preferences
  app.get('/api/settings/notifications', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Use raw SQL to work with existing database columns
      const preferences = await postgresClient`
        SELECT * FROM user_notification_preferences WHERE user_id = ${user.id} LIMIT 1
      `;

      if (preferences.length === 0) {
        // Create default preferences with existing column names
        const defaultPrefs = await postgresClient`
          INSERT INTO user_notification_preferences (user_id, email_course_updates, email_student_messages, email_system_updates, email_marketing_promotions)
          VALUES (${user.id}, true, true, true, false)
          RETURNING *
        `;
        
        // Map database columns to expected interface
        const mappedPrefs = {
          emailLessons: defaultPrefs[0].email_course_updates,
          emailProgress: defaultPrefs[0].email_system_updates,
          emailMessages: defaultPrefs[0].email_student_messages,
          emailMarketing: defaultPrefs[0].email_marketing_promotions,
          smsLessons: false,
          smsProgress: false,
          smsMessages: false,
          pushNotifications: true
        };
        
        res.json({ success: true, data: mappedPrefs });
      } else {
        // Map database columns to expected interface
        const mappedPrefs = {
          emailLessons: preferences[0].email_course_updates,
          emailProgress: preferences[0].email_system_updates,
          emailMessages: preferences[0].email_student_messages,
          emailMarketing: preferences[0].email_marketing_promotions,
          smsLessons: false,
          smsProgress: false,
          smsMessages: false,
          pushNotifications: true
        };
        
        res.json({ success: true, data: mappedPrefs });
      }

    } catch (error) {
      console.error('Get notification preferences error:', error);
      res.status(500).json({ success: false, error: 'Failed to get notification preferences' });
    }
  });

  // Update user notification preferences
  app.put('/api/settings/notifications', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { 
        emailLessons, 
        emailProgress, 
        emailMessages, 
        emailMarketing,
        smsLessons,
        smsProgress,
        smsMessages,
        pushNotifications
      } = req.body;

      // Use raw SQL to work with existing database columns
      const existing = await postgresClient`
        SELECT * FROM user_notification_preferences WHERE user_id = ${user.id} LIMIT 1
      `;

      if (existing.length === 0) {
        await postgresClient`
          INSERT INTO user_notification_preferences (user_id, email_course_updates, email_student_messages, email_system_updates, email_marketing_promotions)
          VALUES (${user.id}, ${emailLessons}, ${emailMessages}, ${emailProgress}, ${emailMarketing})
        `;
      } else {
        await postgresClient`
          UPDATE user_notification_preferences 
          SET email_course_updates = ${emailLessons}, 
              email_student_messages = ${emailMessages},
              email_system_updates = ${emailProgress},
              email_marketing_promotions = ${emailMarketing},
              updated_at = NOW()
          WHERE user_id = ${user.id}
        `;
      }

      res.json({ success: true, message: 'Notification preferences updated successfully' });

    } catch (error) {
      console.error('Update notification preferences error:', error);
      res.status(500).json({ success: false, error: 'Failed to update notification preferences' });
    }
  });

  // Get user subscription info
  app.get('/api/settings/subscription', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Use raw SQL to work with existing database columns (simplified for now)
      const subscription = await postgresClient`
        SELECT us.*
        FROM user_subscriptions us
        WHERE us.user_id = ${user.id} AND us.subscription_status = 'active'
        LIMIT 1
      `;

      // Get payment history
      const paymentHistory = await db.select()
        .from(payments)
        .where(eq(payments.userId, user.id))
        .orderBy(desc(payments.createdAt))
        .limit(10);

      res.json({
        success: true,
        data: {
          subscription: subscription.length > 0 ? subscription[0] : null,
          paymentHistory,
          hasActiveSubscription: subscription.length > 0
        }
      });

    } catch (error) {
      console.error('Get subscription info error:', error);
      res.status(500).json({ success: false, error: 'Failed to get subscription info' });
    }
  });

  // Cancel user subscription
  app.post('/api/settings/cancel-subscription', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || !user.stripeSubscriptionId) {
        return res.status(400).json({ success: false, error: 'No active subscription found' });
      }

      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ success: false, error: 'Payment service unavailable' });
      }

      // Cancel subscription in Stripe
      await stripe.subscriptions.update(user.stripeSubscriptionId, {
        cancel_at_period_end: true,
      });

      // Update subscription in database
      await db.update(userSubscriptions)
        .set({
          cancelAtPeriodEnd: true,
          cancelledAt: new Date(),
          updatedAt: new Date()
        })
        .where(eq(userSubscriptions.stripeSubscriptionId, user.stripeSubscriptionId));

      res.json({ success: true, message: 'Subscription cancelled successfully' });

    } catch (error) {
      console.error('Cancel subscription error:', error);
      res.status(500).json({ success: false, error: 'Failed to cancel subscription' });
    }
  });

  // Export user data
  app.get('/api/settings/export-data', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Gather all user data comprehensively
      const userData = {
        profile: {
          name: user.name,
          email: user.email,
          age: user.age,
          grade: user.grade,
          country: user.country,
          countryId: user.countryId,
          educationLevel: user.educationLevel,
          gradeSystem: null, // gradeSystem field not available
          pronouns: user.pronouns,
          bio: user.bio,
          subscriptionTier: user.subscriptionTier,
          plan: user.plan,
          planExpiry: user.planExpiry,
          role: user.role,
          avatarUrl: user.avatarUrl,
          createdAt: null, // createdAt field not available in user object
          updatedAt: null, // updatedAt field not available in user object  
          lastSeen: null // lastSeen field not available in user object
        },
        authentication: {
          userId: null, // userId field not available in user object
          accountCreated: null // createdAt field not available in user object
        },
        studyData: {
          notes: await db.select().from(studyNotes).where(eq(studyNotes.userId, user.id)),
          subjectProgress: [], // subjectProgress table not available
          lessonProgress: await db.select().from(studentProgress).where(eq(studentProgress.userId, user.id)),
          tasks: await db.select().from(tasks).where(eq(tasks.userId, user.id))
        },
        dailyQuestions: {
          questionProgress: [], // dailyQuestionProgress table not available
          dailySummaries: [] // dailyProgressSummary table not available
        },
        communication: {
          messages: await db.select().from(messages).where(or(
            eq(messages.senderId, user.id),
            eq(messages.receiverId, user.id)
          )),
          announcements: await db.select().from(announcements).where(eq(announcements.userId, user.id))
        },
        community: {
          groupMemberships: await db.select().from(groupMemberships).where(eq(groupMemberships.userId, user.id)),
          communityPosts: await db.select().from(communityPosts).where(eq(communityPosts.authorId, user.id)),
          communityReplies: await db.select().from(communityReplies).where(eq(communityReplies.authorId, user.id)),
          friendships: await db.select().from(friendships).where(or(
            eq(friendships.userId, user.id),
            eq(friendships.friendId, user.id)
          ))
        },
        preferences: {
          notifications: await db.select().from(userNotificationPreferences).where(eq(userNotificationPreferences.userId, user.id)),
          privacy: await db.select().from(userPrivacySettings).where(eq(userPrivacySettings.userId, user.id)),
          other: await db.select().from(userOtherSettings).where(eq(userOtherSettings.userId, user.id))
        },
        subscriptions: {
          current: await db.select().from(userSubscriptions).where(eq(userSubscriptions.userId, user.id)),
          paymentHistory: await db.select().from(payments).where(eq(payments.userId, user.id))
        },
        exportedAt: new Date().toISOString(),
        dataExportVersion: "1.0"
      };

      res.json({ success: true, data: userData });

    } catch (error) {
      console.error('Export data error:', error);
      res.status(500).json({ success: false, error: 'Failed to export data' });
    }
  });

  // Delete user account
  app.delete('/api/settings/delete-account', async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { confirmation } = req.body;
      if (confirmation !== 'DELETE MY ACCOUNT') {
        return res.status(400).json({ 
          success: false, 
          error: 'Please type "DELETE MY ACCOUNT" to confirm account deletion' 
        });
      }

      // Cancel any active subscriptions
      if (user.stripeSubscriptionId && stripe) {
        await stripe.subscriptions.cancel(user.stripeSubscriptionId);
      }

      // Delete related data comprehensively (cascading delete would be better but manual for now)
      await Promise.all([
        // Settings and preferences
        db.delete(userNotificationPreferences).where(eq(userNotificationPreferences.userId, user.id)),
        db.delete(userOtherSettings).where(eq(userOtherSettings.userId, user.id)),
        db.delete(userPrivacySettings).where(eq(userPrivacySettings.userId, user.id)),
        
        // Study data
        db.delete(studyNotes).where(eq(studyNotes.userId, user.id)),
        db.delete(subjectProgress).where(eq(subjectProgress.userId, user.id)),
        db.delete(lessonProgress).where(eq(lessonProgress.userId, user.id)),
        db.delete(tasks).where(eq(tasks.userId, user.id)),
        
        // Daily questions progress
        db.delete(dailyQuestionProgress).where(eq(dailyQuestionProgress.userId, user.id)),
        db.delete(dailyProgressSummary).where(eq(dailyProgressSummary.userId, user.id)),
        
        // Communication and messages
        db.delete(messages).where(or(
          eq(messages.senderId, user.id),
          eq(messages.receiverId, user.id)
        )),
        db.delete(announcements).where(eq(announcements.userId, user.id)),
        
        // Community participation
        db.delete(groupMemberships).where(eq(groupMemberships.userId, user.id)),
        db.delete(communityTopics).where(eq(communityTopics.authorId, user.id)),
        db.delete(communityReplies).where(eq(communityReplies.authorId, user.id)),
        db.delete(friendships).where(or(
          eq(friendships.userId, user.id),
          eq(friendships.friendId, user.id)
        )),
        
        // Financial data
        db.delete(userSubscriptions).where(eq(userSubscriptions.userId, user.id)),
        db.delete(payments).where(eq(payments.userId, user.id)),
        
        // Session and authentication
        db.delete(userLoginSessions).where(eq(userLoginSessions.userId, user.id)),
        db.delete(userRoles).where(eq(userRoles.userId, user.userId))
      ]);

      // Delete profile and user
      await db.delete(profiles).where(eq(profiles.userId, user.id));
      await db.delete(users).where(eq(users.id, user.id));

      res.json({ success: true, message: 'Account deleted successfully' });

    } catch (error) {
      console.error('Delete account error:', error);
      res.status(500).json({ success: false, error: 'Failed to delete account' });
    }
  });

  // Avatar upload endpoint
  app.post('/api/settings/upload-avatar', upload.single('avatar'), async (req, res) => {
    try {
      console.log('ðŸ“¸ Avatar upload request received');
      
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        console.log('âŒ Authentication failed for avatar upload');
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      console.log('âœ… Processing avatar upload for user:', user.id);

      if (!req.file) {
        console.log('âŒ No file received in upload request');
        return res.status(400).json({ success: false, error: 'No file uploaded' });
      }

      console.log('ðŸ“ File received:', {
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        size: req.file.size
      });

      // Validate file type
      if (!req.file.mimetype.startsWith('image/')) {
        console.log('âŒ Invalid file type:', req.file.mimetype);
        return res.status(400).json({ success: false, error: 'Please upload an image file' });
      }

      // Validate file size (5MB max)
      if (req.file.size > 5 * 1024 * 1024) {
        console.log('âŒ File too large:', req.file.size);
        return res.status(400).json({ success: false, error: 'File size must be less than 5MB' });
      }

      // Upload to Cloudinary
      const uploadResult = await cloudinaryStorage.uploadFile(
        req.file.buffer,
        req.file.originalname,
        req.file.mimetype,
        'avatars'
      );

      if (!uploadResult.success) {
        console.log('âŒ Cloudinary upload failed:', uploadResult.error);
        return res.status(500).json({ success: false, error: uploadResult.error || 'Failed to upload avatar' });
      }

      const avatarUrl = uploadResult.url!;
      
      // Update user profile with new avatar URL
      await db.update(profiles)
        .set({
          avatarUrl: avatarUrl,
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, user.id));
      
      console.log('âœ… Avatar upload completed successfully, profile updated');
      res.json({ success: true, avatarUrl, message: 'Avatar uploaded successfully' });

    } catch (error) {
      console.error('âŒ Avatar upload error:', error);
      res.status(500).json({ success: false, error: 'Failed to upload avatar' });
    }
  });

  // ======================= STUDENT SOCIAL FEATURES =======================

  // Search students with online status
  app.get("/api/students/search", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { q: search, limit = 20, offset = 0 } = req.query;

      // Get search parameters with enhanced filtering
      const { grade, country } = req.query as { grade?: string, country?: string };
      
      let whereConditions = [
        eq(profiles.role, 'student'), // Students only
        ne(users.id, user.id), // Exclude current user
        eq(profiles.isTest, false) // Exclude test accounts
      ];
      
      // Add grade filter if provided
      if (grade) {
        whereConditions.push(eq(profiles.grade, parseInt(grade)));
      }
      
      // Add country filter if provided  
      if (country) {
        whereConditions.push(eq(profiles.country, country));
      }

      let query = db
        .select({
          id: users.id,
          userId: users.userId,
          name: profiles.name,
          displayName: profiles.displayName,
          grade: profiles.grade,
          country: profiles.country,
          avatarUrl: profiles.avatarUrl,
          subscriptionTier: profiles.subscriptionTier,
          lastSeen: profiles.lastSeen,
          isOnline: sql<boolean>`(profiles.last_seen IS NULL OR profiles.last_seen > NOW() - INTERVAL '5 minutes')`.as('isOnline')
        })
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(...whereConditions));

      // Add search filter if provided
      if (search) {
        whereConditions.push(
          or(
            like(profiles.name, `%${search}%`),
            like(profiles.displayName, `%${search}%`)
          )
        );
        
        query = db
          .select({
            id: users.id,
            userId: users.userId,
            name: profiles.name,
            displayName: profiles.displayName,
            grade: profiles.grade,
            country: profiles.country,
            avatarUrl: profiles.avatarUrl,
            subscriptionTier: profiles.subscriptionTier,
            lastSeen: profiles.lastSeen,
            isOnline: sql<boolean>`(profiles.last_seen IS NULL OR profiles.last_seen > NOW() - INTERVAL '5 minutes')`.as('isOnline')
          })
          .from(users)
          .innerJoin(profiles, eq(users.id, profiles.userId))
          .where(and(...whereConditions));
      }

      const students = await query
        .orderBy(desc(profiles.lastSeen), asc(profiles.name))
        .limit(parseInt(limit as string))
        .offset(parseInt(offset as string));

      res.json({
        success: true,
        data: students
      });

    } catch (error) {
      console.error('Student search error:', error);
      res.status(500).json({ success: false, error: 'Failed to search students' });
    }
  });

  // Send friend request (Premium only)
  app.post("/api/students/friend-request", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // All students can send friend requests

      const { receiverId } = req.body;

      if (!receiverId) {
        return res.status(400).json({ success: false, error: 'Receiver ID is required' });
      }

      // Check if receiver exists and is a student
      const receiver = await db.select()
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(
          eq(users.id, receiverId),
          eq(profiles.role, 'student'),
          eq(profiles.isTest, false)
        ))
        .limit(1);

      if (receiver.length === 0) {
        return res.status(404).json({ success: false, error: 'Student not found' });
      }

      // Check if friendship already exists
      const existingFriendship = await db.select()
        .from(friendships)
        .where(or(
          and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, receiverId)),
          and(eq(friendships.requesterId, receiverId), eq(friendships.receiverId, user.id))
        ))
        .limit(1);

      if (existingFriendship.length > 0) {
        const status = existingFriendship[0].status;
        if (status === 'accepted') {
          return res.status(400).json({ success: false, error: 'Already friends' });
        } else if (status === 'pending') {
          return res.status(400).json({ success: false, error: 'Friend request already sent' });
        } else if (status === 'blocked') {
          return res.status(400).json({ success: false, error: 'Cannot send friend request' });
        }
      }

      // Create friend request
      await db.insert(friendships).values({
        requesterId: user.id,
        receiverId,
        status: 'pending'
      });

      res.json({ success: true, message: 'Friend request sent successfully' });

    } catch (error) {
      console.error('Send friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to send friend request' });
    }
  });

  // Accept friend request
  app.post("/api/students/friend-request/accept", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { friendshipId } = req.body;

      if (!friendshipId) {
        return res.status(400).json({ success: false, error: 'Friendship ID is required' });
      }

      // Find pending friendship where current user is receiver
      const friendship = await db.select()
        .from(friendships)
        .where(and(
          eq(friendships.id, friendshipId),
          eq(friendships.receiverId, user.id),
          eq(friendships.status, 'pending')
        ))
        .limit(1);

      if (friendship.length === 0) {
        return res.status(404).json({ success: false, error: 'Friend request not found' });
      }

      // Update friendship status to accepted
      await db.update(friendships)
        .set({ 
          status: 'accepted',
          updatedAt: new Date()
        })
        .where(eq(friendships.id, friendshipId));

      // Create reciprocal friendship record
      await db.insert(friendships).values({
        requesterId: friendship[0].receiverId,
        receiverId: friendship[0].requesterId,
        status: 'accepted'
      });

      res.json({ success: true, message: 'Friend request accepted' });

    } catch (error) {
      console.error('Accept friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to accept friend request' });
    }
  });

  // Block user/friend request
  app.post("/api/students/friend-request/block", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { friendshipId, userId } = req.body;

      if (friendshipId) {
        // Block specific friend request
        await db.update(friendships)
          .set({ 
            status: 'blocked',
            updatedAt: new Date()
          })
          .where(and(
            eq(friendships.id, friendshipId),
            eq(friendships.receiverId, user.id)
          ));
      } else if (userId) {
        // Block user completely
        const existingFriendship = await db.select()
          .from(friendships)
          .where(or(
            and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, userId)),
            and(eq(friendships.requesterId, userId), eq(friendships.receiverId, user.id))
          ))
          .limit(1);

        if (existingFriendship.length > 0) {
          await db.update(friendships)
            .set({ 
              status: 'blocked',
              updatedAt: new Date()
            })
            .where(eq(friendships.id, existingFriendship[0].id));
        } else {
          // Create block relationship
          await db.insert(friendships).values({
            requesterId: user.id,
            receiverId: userId,
            status: 'blocked'
          });
        }
      } else {
        return res.status(400).json({ success: false, error: 'Friendship ID or User ID is required' });
      }

      res.json({ success: true, message: 'User blocked successfully' });

    } catch (error) {
      console.error('Block user error:', error);
      res.status(500).json({ success: false, error: 'Failed to block user' });
    }
  });

  // Get friend requests (incoming)
  app.get("/api/students/friend-requests", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const friendRequests = await db.select({
        id: friendships.id,
        requesterId: friendships.requesterId,
        requesterName: profiles.name,
        requesterDisplayName: profiles.displayName,
        requesterAvatarUrl: profiles.avatarUrl,
        requesterGrade: profiles.grade,
        requesterCountry: profiles.country,
        createdAt: friendships.createdAt
      })
        .from(friendships)
        .innerJoin(profiles, eq(friendships.requesterId, profiles.userId))
        .where(and(
          eq(friendships.receiverId, user.id),
          eq(friendships.status, 'pending')
        ))
        .orderBy(desc(friendships.createdAt));

      res.json({
        success: true,
        data: friendRequests
      });

    } catch (error) {
      console.error('Get friend requests error:', error);
      res.status(500).json({ success: false, error: 'Failed to get friend requests' });
    }
  });

  // Get friends list
  app.get("/api/students/friends", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const friends = await db.select({
        id: users.id,
        userId: users.userId,
        name: profiles.name,
        displayName: profiles.displayName,
        avatarUrl: profiles.avatarUrl,
        grade: profiles.grade,
        country: profiles.country,
        lastSeen: profiles.lastSeen,
        isOnline: sql<boolean>`(profiles.last_seen IS NULL OR profiles.last_seen > NOW() - INTERVAL '5 minutes')`.as('isOnline'),
        friendshipDate: friendships.createdAt
      })
        .from(friendships)
        .innerJoin(users, eq(friendships.receiverId, users.id))
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(
          eq(friendships.requesterId, user.id),
          eq(friendships.status, 'accepted')
        ))
        .orderBy(desc(profiles.lastSeen), asc(profiles.name));

      res.json({
        success: true,
        data: friends
      });

    } catch (error) {
      console.error('Get friends error:', error);
      res.status(500).json({ success: false, error: 'Failed to get friends list' });
    }
  });

  // Update online presence (called when user is active)
  app.post("/api/students/presence", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Update last seen timestamp
      await db.update(profiles)
        .set({ 
          lastSeen: new Date(),
          updatedAt: new Date()
        })
        .where(eq(profiles.userId, user.id));

      res.json({ success: true });

    } catch (error) {
      console.error('Update presence error:', error);
      res.status(500).json({ success: false, error: 'Failed to update presence' });
    }
  });

  // ======================= STUDENT NETWORKING SYSTEM =======================
  
  // Send friend request
  app.post("/api/friends/request", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { receiverId, message } = req.body;

      // Check if receiver exists and is a student
      const receiver = await db.select({
        id: users.id,
        userId: users.userId,
        role: profiles.role
      })
        .from(users)
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(users.userId, receiverId))
        .limit(1);

      if (receiver.length === 0) {
        return res.status(404).json({ success: false, error: 'Student not found' });
      }

      if (receiver[0].role !== 'student') {
        return res.status(400).json({ success: false, error: 'Can only send friend requests to students' });
      }

      // Check if friendship already exists
      const existingFriendship = await db.select()
        .from(friendships)
        .where(
          or(
            and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, receiver[0].id)),
            and(eq(friendships.requesterId, receiver[0].id), eq(friendships.receiverId, user.id))
          )
        )
        .limit(1);

      if (existingFriendship.length > 0) {
        return res.status(400).json({ success: false, error: 'Friendship request already exists' });
      }

      // Create friend request
      await db.insert(friendships).values({
        requesterId: user.id,
        receiverId: receiver[0].id,
        status: 'pending',
        requestMessage: message || null
      });

      res.json({ success: true, message: 'Friend request sent successfully' });

    } catch (error) {
      console.error('Send friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to send friend request' });
    }
  });

  // Respond to friend request
  app.post("/api/friends/respond", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { friendshipId, action } = req.body; // action: 'accept' or 'reject'

      if (!['accept', 'reject'].includes(action)) {
        return res.status(400).json({ success: false, error: 'Invalid action' });
      }

      // Update friendship status
      const result = await db.update(friendships)
        .set({ 
          status: action === 'accept' ? 'accepted' : 'rejected',
          updatedAt: new Date()
        })
        .where(
          and(
            eq(friendships.id, friendshipId),
            eq(friendships.receiverId, user.id),
            eq(friendships.status, 'pending')
          )
        );

      res.json({ success: true, message: `Friend request ${action}ed successfully` });

    } catch (error) {
      console.error('Respond to friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to respond to friend request' });
    }
  });

  // Get pending friend requests
  app.get("/api/friends/requests", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const requests = await db.select({
        id: friendships.id,
        requesterId: friendships.requesterId,
        requesterUserId: users.userId,
        requesterName: profiles.name,
        requesterAvatar: profiles.avatarUrl,
        requesterGrade: profiles.grade,
        requesterCountry: profiles.country,
        message: friendships.requestMessage,
        createdAt: friendships.createdAt
      })
        .from(friendships)
        .innerJoin(users, eq(friendships.requesterId, users.id))
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(
          and(
            eq(friendships.receiverId, user.id),
            eq(friendships.status, 'pending')
          )
        )
        .orderBy(desc(friendships.createdAt));

      res.json({ success: true, data: requests });

    } catch (error) {
      console.error('Get friend requests error:', error);
      res.status(500).json({ success: false, error: 'Failed to get friend requests' });
    }
  });

  // REMOVED: Duplicate endpoint - using the main search endpoint above

  // Get discoverable students for Find Friends (Premium only)
  app.get("/api/community/students", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // All students can access Find Friends feature

      const { search, grade, subject, country, connectionType = 'friend' } = req.query;

      // Build conditions array for better handling
      let conditions = [
        eq(profiles.role, 'student'), // Students only
        ne(profiles.userId, user.id)
      ];

      // Exclude test accounts if the field exists
      try {
        conditions.push(or(isNull(profiles.isTest), eq(profiles.isTest, false)));
      } catch (error) {
        // isTest field might not exist, continue without it
        console.log('isTest field not available, skipping condition');
      }

      // Add search filter
      if (search) {
        conditions.push(or(
          like(profiles.name, `%${search}%`),
          like(profiles.displayName, `%${search}%`),
          like(profiles.country, `%${search}%`)
        ));
      }

      // Add grade filter
      if (grade) {
        conditions.push(eq(profiles.grade, parseInt(grade as string)));
      }

      // Add country filter
      if (country) {
        conditions.push(eq(profiles.country, country as string));
      }

      // Get students with simplified query
      const students = await db.select({
        id: profiles.userId,
        userId: profiles.userId,
        name: profiles.name,
        displayName: profiles.displayName,
        avatarUrl: profiles.avatarUrl,
        grade: profiles.grade,
        country: profiles.country,
        subscriptionTier: profiles.subscriptionTier,
        lastSeen: profiles.lastSeen,
        isOnline: profiles.isOnline
      })
      .from(profiles)
      .where(and(...conditions))
      .orderBy(desc(profiles.lastSeen), asc(profiles.name))
      .limit(50);

      // Check friendship status for each student separately
      const enrichedStudents = await Promise.all(students.map(async (student) => {
        try {
          const friendship = await db.select({ status: friendships.status })
            .from(friendships)
            .where(or(
              and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, student.userId)),
              and(eq(friendships.requesterId, student.userId), eq(friendships.receiverId, user.id))
            ))
            .limit(1);

          const friendshipStatus = friendship.length > 0 ? friendship[0].status : 'none';
          
          return {
            ...student,
            friendshipStatus
          };
        } catch (error) {
          console.error('Error checking friendship status:', error);
          return {
            ...student,
            friendshipStatus: 'none'
          };
        }
      }));

      // Filter out users already connected if needed
      const filteredStudents = enrichedStudents.filter(student => 
        student.friendshipStatus === 'none' || 
        student.friendshipStatus === 'rejected'
      );

      res.json({ success: true, data: filteredStudents });

    } catch (error) {
      console.error('Get community students error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch students' });
    }
  });

  // Send friend request via community (Premium only)
  app.post("/api/community/friend-requests", async (req, res) => {
    try {
      console.log('ðŸ¤ Friend request API called:', {
        body: req.body,
        authHeader: !!req.headers.authorization
      });
      
      const authHeader = req.headers.authorization as string;
      if (!authHeader) {
        return res.status(401).json({ success: false, error: 'Authorization header required' });
      }

      const user = await getUserFromSession(authHeader);
      
      if (!user || !user.id) {
        console.log('âŒ User authentication failed');
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      console.log('âœ… User authenticated:', { userId: user.userId, id: user.id });

      // All students can send friend requests  
      const { targetUserId } = req.body;

      if (!targetUserId) {
        return res.status(400).json({ success: false, error: 'Target user ID is required' });
      }

      // Check if target user exists and is a student
      const targetUser = await db.select()
        .from(users)
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(and(
          eq(users.userId, targetUserId),
          eq(profiles.role, 'student'),
          eq(profiles.isTest, false)
        ))
        .limit(1);

      if (targetUser.length === 0) {
        return res.status(404).json({ success: false, error: 'Student not found' });
      }

      const receiverId = targetUser[0].users.id;

      // Check if friendship already exists
      const existingFriendship = await db.select()
        .from(friendships)
        .where(or(
          and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, receiverId)),
          and(eq(friendships.requesterId, receiverId), eq(friendships.receiverId, user.id))
        ))
        .limit(1);

      if (existingFriendship.length > 0) {
        const status = existingFriendship[0].status;
        if (status === 'accepted') {
          return res.status(400).json({ success: false, error: 'Already friends' });
        } else if (status === 'pending') {
          return res.status(400).json({ success: false, error: 'Friend request already sent' });
        } else if (status === 'blocked') {
          return res.status(400).json({ success: false, error: 'Cannot send friend request' });
        }
      }

      // Create friend request
      await db.insert(friendships).values({
        requesterId: user.id,
        receiverId,
        status: 'pending'
      });

      res.json({ success: true, message: 'Friend request sent successfully' });

    } catch (error) {
      console.error('Send community friend request error:', error);
      res.status(500).json({ success: false, error: 'Failed to send friend request' });
    }
  });

  // ======================= PREMIUM MESSAGING SYSTEM =======================

  // Send premium message (requires admin approval)
  app.post("/api/premium-messages", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      // Check if user profile exists
      const userProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'User profile not found' });
      }

      const { receiverId, content, messageType = 'text' } = req.body;

      // Check if they are friends
      const friendship = await db.select()
        .from(friendships)
        .where(
          or(
            and(eq(friendships.requesterId, user.id), eq(friendships.receiverId, receiverId), eq(friendships.status, 'accepted')),
            and(eq(friendships.requesterId, receiverId), eq(friendships.receiverId, user.id), eq(friendships.status, 'accepted'))
          )
        )
        .limit(1);

      if (friendship.length === 0) {
        return res.status(403).json({ success: false, error: 'Can only send premium messages to friends' });
      }

      // Create premium message pending approval
      const newMessage = await db.insert(premiumMessages).values({
        senderId: user.id,
        receiverId: receiverId,
        content: content,
        messageType: messageType,
        status: 'pending'
      }).returning();

      res.json({ success: true, message: 'Premium message sent for approval', data: newMessage[0] });

    } catch (error) {
      console.error('Send premium message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send premium message' });
    }
  });

  // Admin: Get pending premium messages for approval
  app.get("/api/admin/premium-messages", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || !await isAdmin(user.id)) {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }

      const pendingMessages = await db.select({
        id: premiumMessages.id,
        content: premiumMessages.content,
        messageType: premiumMessages.messageType,
        sentAt: premiumMessages.sentAt,
        senderName: sql<string>`sender_profile.name`.as('senderName'),
        senderUserId: sql<string>`sender_users.user_id`.as('senderUserId'),
        receiverName: sql<string>`receiver_profile.name`.as('receiverName'),
        receiverUserId: sql<string>`receiver_users.user_id`.as('receiverUserId')
      })
        .from(premiumMessages)
        .leftJoin(sql`auth_users sender_users`, sql`premium_messages.sender_id = sender_users.id`)
        .leftJoin(sql`profiles sender_profile`, sql`sender_users.id = sender_profile.user_id`)
        .leftJoin(sql`auth_users receiver_users`, sql`premium_messages.receiver_id = receiver_users.id`)
        .leftJoin(sql`profiles receiver_profile`, sql`receiver_users.id = receiver_profile.user_id`)
        .where(eq(premiumMessages.status, 'pending'))
        .orderBy(asc(premiumMessages.sentAt));

      res.json({ success: true, data: pendingMessages });

    } catch (error) {
      console.error('Get pending premium messages error:', error);
      res.status(500).json({ success: false, error: 'Failed to get pending messages' });
    }
  });

  // Admin: Approve/Reject premium message
  app.post("/api/admin/premium-messages/:messageId/approve", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || !await isAdmin(user.id)) {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }

      const { messageId } = req.params;
      const { action, rejectionReason } = req.body; // action: 'approve' or 'reject'

      const status = action === 'approve' ? 'approved' : 'rejected';

      await db.update(premiumMessages)
        .set({
          status: status,
          approvedBy: user.id,
          approvedAt: new Date(),
          rejectionReason: rejectionReason || null,
          updatedAt: new Date()
        })
        .where(eq(premiumMessages.id, messageId));

      if (status === 'approved') {
        // Move to regular messages table for delivery
        const message = await db.select()
          .from(premiumMessages)
          .where(eq(premiumMessages.id, messageId))
          .limit(1);

        if (message.length > 0) {
          await db.insert(messages).values({
            senderId: message[0].senderId,
            receiverId: message[0].receiverId,
            topic: 'chat',
            extension: 'txt',
            content: message[0].content,
            messageType: message[0].messageType
          });
        }
      }

      res.json({ success: true, message: `Premium message ${action}d successfully` });

    } catch (error) {
      console.error('Approve premium message error:', error);
      res.status(500).json({ success: false, error: 'Failed to process premium message' });
    }
  });

  // ======================= GROUP MANAGEMENT SYSTEM =======================

  // Create group (pending admin approval)
  app.post("/api/groups", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { name, description, isPrivate = false, maxMembers = 100, tags = [] } = req.body;

      const newGroup = await db.insert(communityGroups).values({
        name: name,
        description: description,
        createdBy: user.id,
        status: 'pending', // Requires admin approval
        isPrivate: isPrivate,
        maxMembers: maxMembers,
        tags: tags,
        memberCount: 1,
        membersCount: 1
      }).returning();

      // Add creator as admin member
      await db.insert(groupMemberships).values({
        groupId: newGroup[0].id,
        userId: user.id,
        role: 'admin',
        status: 'active'
      });

      // Check user role to determine if approval is needed
      const userProfile = await db.select({ role: profiles.role })
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);
      
      // Auto-approve for admins and teachers, require approval for students and technicians
      const requiresApproval = !userProfile[0] || !['admin', 'teacher'].includes(userProfile[0].role || '');
      
      if (!requiresApproval) {
        // Auto-approve for admins/teachers
        await db.update(communityGroups)
          .set({ 
            status: 'approved',
            approvedBy: user.id,
            approvedAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(communityGroups.id, newGroup[0].id));
        
        res.json({ success: true, message: 'Group created and approved', data: { ...newGroup[0], status: 'approved' } });
      } else {
        res.json({ success: true, message: 'Group created and pending admin approval', data: newGroup[0] });
      }

    } catch (error) {
      console.error('Create group error:', error);
      res.status(500).json({ success: false, error: 'Failed to create group' });
    }
  });

  // Helper function to check admin status
  const isAdmin = async (userId: string): Promise<boolean> => {
    try {
      const profile = await db.select({ role: profiles.role })
        .from(profiles)
        .where(eq(profiles.userId, userId))
        .limit(1);
      return profile.length > 0 && profile[0].role === 'admin';
    } catch (error) {
      console.error('Error checking admin status:', error);
      return false;
    }
  };

  // Admin: Get pending groups for approval
  app.get("/api/admin/groups/pending", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || !await isAdmin(user.id)) {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }

      const pendingGroups = await db.select({
        id: communityGroups.id,
        name: communityGroups.name,
        description: communityGroups.description,
        isPrivate: communityGroups.isPrivate,
        maxMembers: communityGroups.maxMembers,
        tags: communityGroups.tags,
        createdAt: communityGroups.createdAt,
        creatorName: profiles.name,
        creatorUserId: users.userId
      })
        .from(communityGroups)
        .innerJoin(users, eq(communityGroups.createdBy, users.id))
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(communityGroups.status, 'pending'))
        .orderBy(asc(communityGroups.createdAt));

      res.json({ success: true, data: pendingGroups });

    } catch (error) {
      console.error('Get pending groups error:', error);
      res.status(500).json({ success: false, error: 'Failed to get pending groups' });
    }
  });

  // Admin: Approve/Reject group
  app.post("/api/admin/groups/:groupId/approve", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user || !await isAdmin(user.id)) {
        return res.status(403).json({ success: false, error: 'Admin access required' });
      }

      const { groupId } = req.params;
      const { action, rejectionReason } = req.body; // action: 'approve' or 'reject'

      const status = action === 'approve' ? 'approved' : 'rejected';

      await db.update(communityGroups)
        .set({
          status: status,
          approvedBy: user.id,
          approvedAt: new Date(),
          rejectionReason: rejectionReason || null,
          updatedAt: new Date()
        })
        .where(eq(communityGroups.id, groupId));

      res.json({ success: true, message: `Group ${action}d successfully` });

    } catch (error) {
      console.error('Approve group error:', error);
      res.status(500).json({ success: false, error: 'Failed to process group' });
    }
  });

  // Join group
  app.post("/api/groups/:groupId/join", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;

      // Check if group exists and is approved
      const group = await db.select()
        .from(communityGroups)
        .where(and(eq(communityGroups.id, groupId), or(eq(communityGroups.status, 'approved'), eq(communityGroups.status, 'active'))))
        .limit(1);

      if (group.length === 0) {
        return res.status(404).json({ success: false, error: 'Group not found or not available' });
      }

      // Check if already a member
      const existingMembership = await db.select()
        .from(groupMemberships)
        .where(and(eq(groupMemberships.groupId, groupId), eq(groupMemberships.userId, user.id)))
        .limit(1);

      if (existingMembership.length > 0) {
        return res.status(400).json({ success: false, error: 'Already a member of this group' });
      }

      // Check if group is full
      if (group[0].memberCount >= group[0].maxMembers) {
        return res.status(400).json({ success: false, error: 'Group is full' });
      }

      // Add membership
      await db.insert(groupMemberships).values({
        groupId: groupId,
        userId: user.id,
        role: 'member',
        status: 'active'
      });

      // Update member count
      await db.update(communityGroups)
        .set({ 
          memberCount: group[0].memberCount + 1,
          membersCount: group[0].memberCount + 1,
          updatedAt: new Date()
        })
        .where(eq(communityGroups.id, groupId));

      res.json({ success: true, message: 'Joined group successfully' });

    } catch (error) {
      console.error('Join group error:', error);
      res.status(500).json({ success: false, error: 'Failed to join group' });
    }
  });

  // Currency conversion API endpoint
  app.get('/api/currency/:countryCode', async (req, res) => {
    try {
      const { countryCode } = req.params;
      
      // Country to currency mapping
      const countryToCurrency: { [key: string]: string } = {
        'US': 'USD', 'CA': 'CAD', 'GB': 'GBP', 'EU': 'EUR', 'DE': 'EUR', 'FR': 'EUR', 'ES': 'EUR', 'IT': 'EUR',
        'AU': 'AUD', 'NZ': 'NZD', 'JP': 'JPY', 'CN': 'CNY', 'IN': 'INR', 'BR': 'BRL', 'MX': 'MXN',
        'ZA': 'ZAR', 'NG': 'NGN', 'KE': 'KES', 'GH': 'GHS', 'EG': 'EGP', 'MA': 'MAD',
        'RU': 'RUB', 'KR': 'KRW', 'TH': 'THB', 'VN': 'VND', 'ID': 'IDR', 'MY': 'MYR', 'PH': 'PHP', 'SG': 'SGD',
        'AR': 'ARS', 'CL': 'CLP', 'CO': 'COP', 'PE': 'PEN', 'UY': 'UYU', 'VE': 'VES',
        'TR': 'TRY', 'SA': 'SAR', 'AE': 'AED', 'IL': 'ILS', 'JO': 'JOD', 'LB': 'LBP',
        'PL': 'PLN', 'CZ': 'CZK', 'HU': 'HUF', 'RO': 'RON', 'BG': 'BGN', 'HR': 'HRK',
        'NO': 'NOK', 'SE': 'SEK', 'DK': 'DKK', 'FI': 'EUR', 'IS': 'ISK',
        'CH': 'CHF', 'AT': 'EUR', 'BE': 'EUR', 'NL': 'EUR', 'LU': 'EUR', 'IE': 'EUR', 'PT': 'EUR'
      };

      const currency = countryToCurrency[countryCode] || 'USD';
      
      // Fetch exchange rates from a free API
      const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD`);
      const data = await response.json();
      
      const rate = data.rates[currency] || 1;
      
      res.json({
        success: true,
        currency,
        rate,
        symbol: getCurrencySymbol(currency)
      });

    } catch (error) {
      console.error('Currency conversion error:', error);
      // Fallback to USD if API fails
      res.json({
        success: true,
        currency: 'USD',
        rate: 1,
        symbol: '$'
      });
    }
  });

  // Helper function to get currency symbols
  function getCurrencySymbol(currency: string): string {
    const symbols: { [key: string]: string } = {
      'USD': '$', 'CAD': 'C$', 'GBP': 'Â£', 'EUR': 'â‚¬', 'AUD': 'A$', 'NZD': 'NZ$',
      'JPY': 'Â¥', 'CNY': 'Â¥', 'INR': 'â‚¹', 'BRL': 'R$', 'MXN': '$', 'ZAR': 'R',
      'NGN': 'â‚¦', 'KES': 'KSh', 'GHS': 'GHâ‚µ', 'EGP': 'EÂ£', 'MAD': 'MAD',
      'RUB': 'â‚½', 'KRW': 'â‚©', 'THB': 'à¸¿', 'VND': 'â‚«', 'IDR': 'Rp', 'MYR': 'RM',
      'PHP': 'â‚±', 'SGD': 'S$', 'ARS': '$', 'CLP': '$', 'COP': '$', 'PEN': 'S/',
      'UYU': '$U', 'VES': 'Bs', 'TRY': 'â‚º', 'SAR': 'ï·¼', 'AED': 'Ø¯.Ø¥', 'ILS': 'â‚ª',
      'JOD': 'JD', 'LBP': 'LÂ£', 'PLN': 'zÅ‚', 'CZK': 'KÄ', 'HUF': 'Ft', 'RON': 'lei',
      'BGN': 'Ð»Ð²', 'HRK': 'kn', 'NOK': 'kr', 'SEK': 'kr', 'DKK': 'kr', 'ISK': 'kr',
      'CHF': 'CHF'
    };
    return symbols[currency] || currency;
  }

  // Get approved groups with membership info
  app.get("/api/groups", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const groups = await db.select({
        id: communityGroups.id,
        name: communityGroups.name,
        description: communityGroups.description,
        avatarUrl: communityGroups.avatarUrl,
        memberCount: communityGroups.memberCount,
        maxMembers: communityGroups.maxMembers,
        tags: communityGroups.tags,
        createdAt: communityGroups.createdAt,
        createdBy: communityGroups.createdBy,
        creatorName: profiles.name
      })
        .from(communityGroups)
        .innerJoin(users, eq(communityGroups.createdBy, users.id))
        .innerJoin(profiles, eq(users.id, profiles.userId))
        .where(or(eq(communityGroups.status, 'approved'), eq(communityGroups.status, 'active')))
        .orderBy(desc(communityGroups.createdAt));

      // Check membership for each group
      const groupsWithMembership = await Promise.all(groups.map(async (group) => {
        const membership = await db.select()
          .from(communityGroupMembers)
          .where(and(
            eq(communityGroupMembers.groupId, group.id),
            eq(communityGroupMembers.userId, user.id)
          ))
          .limit(1);
        
        return {
          ...group,
          isMember: membership.length > 0,
          isCreator: group.createdBy === user.id
        };
      }));

      res.json({ success: true, data: groupsWithMembership });

    } catch (error) {
      console.error('Get groups error:', error);
      res.status(500).json({ success: false, error: 'Failed to get groups' });
    }
  });


  // Send group message
  app.post("/api/groups/:groupId/messages", async (req, res) => {
    try {
      const authHeader = req.headers.authorization as string;
      const user = await getUserFromSession(authHeader);
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Authentication required' });
      }

      const { groupId } = req.params;
      const { content, messageType = 'text' } = req.body;

      // Check if user is a member of the group
      const membership = await db.select()
        .from(communityGroupMembers)
        .where(and(
          eq(communityGroupMembers.groupId, groupId),
          eq(communityGroupMembers.userId, user.id)
        ))
        .limit(1);

      if (membership.length === 0) {
        return res.status(403).json({ success: false, error: 'You are not a member of this group' });
      }

      // Get sender profile for message data
      const senderProfile = await db.select()
        .from(profiles)
        .where(eq(profiles.userId, user.id))
        .limit(1);

      if (senderProfile.length === 0) {
        return res.status(400).json({ success: false, error: 'Profile not found' });
      }

      // Insert the message
      const newMessage = await db.insert(messages).values({
        senderId: senderProfile[0].id,
        groupId: groupId,
        content: content,
        messageType: messageType,
        createdAt: new Date()
      }).returning();

      // Broadcast to all group members via WebSocket
      const groupMembers = await db.select({ userId: users.userId })
        .from(communityGroupMembers)
        .innerJoin(users, eq(communityGroupMembers.userId, users.id))
        .where(eq(communityGroupMembers.groupId, groupId));

      // Broadcast the message to all connected group members
      const messageData = {
        type: 'new_group_message',
        groupId,
        message: {
          ...newMessage[0],
          senderName: senderProfile[0].name,
          senderAvatarUrl: senderProfile[0].avatarUrl
        }
      };

      // Broadcast to group members via WebSocket (implementation would depend on your WebSocket setup)
      // This would integrate with your existing WebSocket system

      res.json({ success: true, data: newMessage[0] });

    } catch (error) {
      console.error('Send group message error:', error);
      res.status(500).json({ success: false, error: 'Failed to send group message' });
    }
  });

  // ======================= PRICING ROUTES =======================
  
  // Get pricing plans
  app.get("/api/pricing/plans", async (req, res) => {
    try {
      const plans = await db.select()
        .from(pricingPlans)
        .where(eq(pricingPlans.isActive, true))
        .orderBy(asc(pricingPlans.sortOrder));

      res.json({
        success: true,
        plans: plans
      });

    } catch (error) {
      console.error('Pricing plans error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch pricing plans' });
    }
  });


  // Mathematics content endpoint - serves the math book JSON
  app.get('/api/mathematics/content', async (req, res) => {
    try {
      const fs = require('fs').promises;
      const path = require('path');
      
      // Read the grade7_math_book.json file
      const mathBookPath = path.join(process.cwd(), 'grade7_math_book.json');
      const mathBookData = await fs.readFile(mathBookPath, 'utf8');
      const mathBook = JSON.parse(mathBookData);
      
      res.json({
        success: true,
        data: mathBook
      });
    } catch (error) {
      console.error('Mathematics content error:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to load mathematics content' 
      });
    }
  });

  // Course Creation API
  app.post('/api/admin/courses', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { title, subject, grade, description, lessons: courseLessons } = req.body;
      
      if (!title || !subject || !grade || !description) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: title, subject, grade, description'
        });
      }

      // Create course record
      const newCourse = await db
        .insert(courses)
        .values({
          title,
          description,
          price: "0",
          createdBy: req.user.id,
          instructorId: req.user.id,
          isActive: true,
          approvalStatus: "approved", // Admin-created courses are auto-approved
          // Only include fields that exist in the database
          ...(req.body.duration && { duration: req.body.duration }),
        })
        .returning();

      // If lessons are provided, create lesson records
      if (courseLessons && Array.isArray(courseLessons)) {
        for (let i = 0; i < courseLessons.length; i++) {
          const lesson = courseLessons[i];
          await db
            .insert(lessons)
            .values({
              courseId: newCourse[0].id,
              categoryId: 16, // Use the default category we just created
              title: lesson.title || `Lesson ${i + 1}`,
              description: lesson.description || '',
              content: lesson,
              level: 1, // Default level
              order: i + 1,
              durationMinutes: 30, // Default duration
              freePreviewFlag: false
              // Note: Don't include updatedAt as it doesn't exist in the actual database
            });
        }
      }

      res.json({
        success: true,
        course: newCourse[0],
        message: 'Course created successfully'
      });

    } catch (error) {
      console.error('Course creation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create course'
      });
    }
  });

  // Get all courses
  app.get('/api/admin/courses', requireAuth, requireAdmin, async (req, res) => {
    try {
      const allCourses = await db
        .select()
        .from(courses)
        .orderBy(desc(courses.createdAt));

      res.json({
        success: true,
        courses: allCourses
      });

    } catch (error) {
      console.error('Courses fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch courses'
      });
    }
  });

  // Approve a course
  app.patch('/api/admin/courses/:id/approve', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      
      const updatedCourse = await db
        .update(courses)
        .set({
          approvalStatus: "approved",
          isActive: true,
          updatedAt: new Date()
        })
        .where(eq(courses.id, id))
        .returning();

      if (!updatedCourse || updatedCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      res.json({
        success: true,
        course: updatedCourse[0],
        message: 'Course approved successfully'
      });

    } catch (error) {
      console.error('Course approval error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to approve course'
      });
    }
  });

  // Reject a course
  app.patch('/api/admin/courses/:id/reject', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { id } = req.params;
      const { reason } = req.body;
      
      const updatedCourse = await db
        .update(courses)
        .set({
          approvalStatus: "rejected",
          isActive: false,
          updatedAt: new Date()
        })
        .where(eq(courses.id, id))
        .returning();

      if (!updatedCourse || updatedCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      res.json({
        success: true,
        course: updatedCourse[0],
        message: 'Course rejected successfully'
      });

    } catch (error) {
      console.error('Course rejection error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to reject course'
      });
    }
  });


  // =============================================
  // COURSE PRICING MANAGEMENT
  // =============================================
  
  // GET /api/course-pricing/plans - Get course-specific pricing plans (Free and College Subscription only)
  app.get('/api/course-pricing/plans', (req, res) => {
    // Immediate early return with static data to avoid any DB access during schema migration
    const fallbackPlans = [
      {
        id: 'course_free_temp',
        name: 'course_free',
        displayName: 'Free Course Access',
        description: 'Access to free courses',
        priceMonthly: '0.00',
        priceYearly: '0.00',
        currency: 'USD',
        billingPeriod: 'one_time',
        features: ['Free course content'],
        isActive: true,
        isPopular: false,
        sortOrder: 1
      },
      {
        id: 'college_course_subscription_temp', 
        name: 'college_course_subscription',
        displayName: 'College Course Subscription',
        description: 'Access to premium course content',
        priceMonthly: '9.99',
        priceYearly: '99.99',
        currency: 'USD',
        billingPeriod: 'monthly',
        features: ['Premium course content', 'Advanced features'],
        isActive: true,
        isPopular: true,
        sortOrder: 2
      }
    ];

    return res.json({
      success: true,
      plans: fallbackPlans
    });
  });

  // POST /api/grade-subscriptions/initialize - Initialize grade-based subscription plans (Admin only)
  app.post('/api/grade-subscriptions/initialize', requireAuth, requireAdmin, async (req, res) => {
    try {
      // Check if grade-based pricing plans already exist
      const existingPlans = await db
        .select()
        .from(pricingPlans)
        .where(or(
          eq(pricingPlans.name, 'elementary_monthly'),
          eq(pricingPlans.name, 'high_school_monthly'),
          eq(pricingPlans.name, 'college_university_monthly')
        ));

      if (existingPlans.length > 0) {
        return res.json({
          success: true,
          message: 'Grade-based subscription plans already exist',
          plans: existingPlans
        });
      }

      // Create grade-based subscription plans
      const gradeBasedPlans = [
        // Elementary (Grades 1-7) Plans
        {
          name: 'elementary_monthly',
          displayName: 'Elementary Monthly',
          description: 'Perfect for students in Grades 1-7',
          gradeTier: 'elementary',
          gradeRange: '1-7',
          priceMonthly: 5.99,
          priceYearly: 54.99,
          currency: 'USD',
          billingPeriod: 'monthly',
          features: ['Age-appropriate content', 'Interactive lessons', 'Parent dashboard', 'Progress tracking'],
          benefits: ['Fun learning activities', 'Educational games', 'Safe environment', 'Basic support'],
          isActive: true,
          isPopular: false,
          sortOrder: 1
        },
        {
          name: 'elementary_yearly',
          displayName: 'Elementary Yearly',
          description: 'Perfect for students in Grades 1-7 (Save with yearly plan)',
          gradeTier: 'elementary',
          gradeRange: '1-7',
          priceMonthly: 5.99,
          priceYearly: 54.99,
          currency: 'USD',
          billingPeriod: 'yearly',
          features: ['Age-appropriate content', 'Interactive lessons', 'Parent dashboard', 'Progress tracking'],
          benefits: ['Fun learning activities', 'Educational games', 'Safe environment', 'Basic support', '17% savings'],
          isActive: true,
          isPopular: true,
          sortOrder: 2
        },
        // High School (Grades 8-12) Plans
        {
          name: 'high_school_monthly',
          displayName: 'High School Monthly',
          description: 'Designed for students in Grades 8-12',
          gradeTier: 'high_school',
          gradeRange: '8-12',
          priceMonthly: 9.99,
          priceYearly: 99.90,
          currency: 'USD',
          billingPeriod: 'monthly',
          features: ['Advanced coursework', 'Exam preparation', 'College readiness', 'Study tools', 'Access to college content for Grade 12+'],
          benefits: ['SAT/ACT prep', 'Career guidance', 'University applications', 'Priority support', 'College-level access'],
          isActive: true,
          isPopular: false,
          sortOrder: 3
        },
        {
          name: 'high_school_yearly',
          displayName: 'High School Yearly',
          description: 'Designed for students in Grades 8-12 (Save with yearly plan)',
          gradeTier: 'high_school',
          gradeRange: '8-12',
          priceMonthly: 9.99,
          priceYearly: 99.90,
          currency: 'USD',
          billingPeriod: 'yearly',
          features: ['Advanced coursework', 'Exam preparation', 'College readiness', 'Study tools', 'Access to college content for Grade 12+'],
          benefits: ['SAT/ACT prep', 'Career guidance', 'University applications', 'Priority support', 'College-level access', '17% savings'],
          isActive: true,
          isPopular: true,
          sortOrder: 4
        },
        // College & University Plans
        {
          name: 'college_university_monthly',
          displayName: 'College & University Monthly',
          description: 'Premium plan for college and university students',
          gradeTier: 'college_university',
          gradeRange: 'College & University',
          priceMonthly: 39.00,
          priceYearly: 399.00,
          currency: 'USD',
          billingPeriod: 'monthly',
          features: ['All university courses', 'Research tools', 'Professional development', 'Industry connections', 'Advanced analytics'],
          benefits: ['Graduate preparation', 'Career services', 'Networking opportunities', 'Premium support', 'All content access'],
          isActive: true,
          isPopular: false,
          sortOrder: 5
        },
        {
          name: 'college_university_yearly',
          displayName: 'College & University Yearly',
          description: 'Premium plan for college and university students (Save with yearly plan)',
          gradeTier: 'college_university',
          gradeRange: 'College & University',
          priceMonthly: 39.00,
          priceYearly: 399.00,
          currency: 'USD',
          billingPeriod: 'yearly',
          features: ['All university courses', 'Research tools', 'Professional development', 'Industry connections', 'Advanced analytics'],
          benefits: ['Graduate preparation', 'Career services', 'Networking opportunities', 'Premium support', 'All content access', '15% savings'],
          isActive: true,
          isPopular: true,
          sortOrder: 6
        }
      ];

      const createdPlans = await db
        .insert(pricingPlans)
        .values(gradeBasedPlans)
        .returning();

      res.json({
        success: true,
        message: 'Grade-based subscription plans initialized successfully',
        plans: createdPlans
      });

    } catch (error) {
      console.error('Grade-based subscription plans initialization error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to initialize grade-based subscription plans'
      });
    }
  });

  // =============================================
  // COURSE CREATOR API ENDPOINTS
  // =============================================
  
  // Create a new course (Admin/Teacher/Freelancer only)
  app.post('/api/course-creator/courses', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if user has permission to create courses (Admin/Teacher/Freelancer only)
      const userRole = await db
        .select({ role: userRoles.role })
        .from(userRoles)
        .where(eq(userRoles.userId, user.id))
        .limit(1);

      const role = userRole[0]?.role || user.role; // Fallback to user.role from profile
      if (!role || !['admin', 'teacher', 'freelancer'].includes(role)) {
        return res.status(403).json({ success: false, error: 'Only Admin, Teachers, and Freelancers can create courses' });
      }

      const { title, description, category, thumbnailUrl, gradeTier, duration, language, difficulty, certificationType, pricingType, price } = req.body;

      if (!title || !description) {
        return res.status(400).json({ 
          success: false, 
          error: 'Title and description are required' 
        });
      }

      // Default to college_university if no gradeTier is provided
      const courseGradeTier = gradeTier || 'college_university';
      
      // Validate gradeTier
      if (!['elementary', 'high_school', 'college_university'].includes(courseGradeTier)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid grade tier. Must be elementary, high_school, or college_university.'
        });
      }

      // Look up categoryId from category name
      let categoryId = null;
      if (category) {
        const categoryResult = await db
          .select({ id: courseCategories.id })
          .from(courseCategories)
          .where(eq(courseCategories.name, category))
          .limit(1);
        
        if (categoryResult.length > 0) {
          categoryId = categoryResult[0].id;
        }
      }

      // Create course with proper active status based on role - IMPROVED SECURITY
      // Only admins can directly activate courses, all others start as inactive (needs approval)
      const approvalStatus = role === 'admin' ? 'approved' : 'pending'; // Admin courses auto-approved, others need approval
      const isActive = role === 'admin' ? true : false;

      const newCourse = await db
        .insert(courses)
        .values({
          createdBy: user.id,
          title,
          description,
          categoryId,
          thumbnailUrl,
          gradeTier: courseGradeTier,
          duration: duration || 15,
          language: language || 'en',
          certificationType: certificationType || 'certificate',
          pricingType: pricingType || 'free',
          price: price || '0',
          difficulty: difficulty || 'intermediate',
          isActive,
          approvalStatus,
        })
        .returning();

      res.json({
        success: true,
        course: newCourse[0],
        message: 'Course created successfully'
      });

    } catch (error) {
      console.error('Course creation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create course'
      });
    }
  });

  // Get courses by user role
  app.get('/api/course-creator/courses', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      const userRole = await db
        .select({ role: userRoles.role })
        .from(userRoles)
        .where(eq(userRoles.userId, user.id))
        .limit(1);

      const role = userRole[0]?.role || user.role; // Fallback to user.role from profile

      let coursesQuery;
      if (role === 'admin') {
        // Admin can see all courses
        coursesQuery = db
          .select({
            id: courses.id,
            title: courses.title,
            description: courses.description,
            isActive: courses.isActive,
            isFeatured: courses.isFeatured,
            approvalStatus: courses.approvalStatus,
            thumbnailUrl: courses.thumbnailUrl,
            createdAt: courses.createdAt
          })
          .from(courses);
      } else {
        // Teachers and Freelancers can only see their own courses
        coursesQuery = db
          .select({
            id: courses.id,
            title: courses.title,
            description: courses.description,
            isActive: courses.isActive,
            isFeatured: courses.isFeatured,
            approvalStatus: courses.approvalStatus,
            thumbnailUrl: courses.thumbnailUrl,
            createdAt: courses.createdAt
          })
          .from(courses)
          .where(eq(courses.createdBy, user.id));
      }

      const userCourses = await coursesQuery.orderBy(desc(courses.createdAt));

      res.json({
        success: true,
        courses: userCourses
      });

    } catch (error) {
      console.error('Courses fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch courses'
      });
    }
  });

  // Update course status (Admin approval workflow)
  app.put('/api/course-creator/courses/:courseId/status', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { courseId } = req.params;
      const { status } = req.body;

      if (!['draft', 'published', 'rejected'].includes(status)) {
        return res.status(400).json({
          success: false,
          error: 'Invalid status. Must be draft, published, or rejected'
        });
      }

      const updatedCourse = await db
        .update(courses)
        .set({ status })
        .where(eq(courses.id, courseId))
        .returning();

      if (updatedCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      res.json({
        success: true,
        course: updatedCourse[0],
        message: `Course ${status} successfully`
      });

    } catch (error) {
      console.error('Course status update error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update course status'
      });
    }
  });

  // Get course with modules, lessons, and quizzes
  app.get('/api/course-creator/courses/:courseId', async (req, res) => {
    try {
      const { courseId } = req.params;

      // Optional authentication check - get user if authenticated
      let user = null;
      let isEnrolled = false;
      
      const authHeader = req.headers.authorization;
      const sessionId = authHeader?.replace('Bearer ', '') || 
                       req.headers['x-session-id'] as string ||
                       req.cookies?.sessionId ||
                       req.cookies?.session ||
                       req.cookies?.auth_session;

      if (sessionId) {
        try {
          const session = await db
            .select({ userId: userLoginSessions.userId })
            .from(userLoginSessions)
            .where(and(
              eq(userLoginSessions.sessionId, sessionId),
              gt(userLoginSessions.expiresAt, new Date())
            ))
            .limit(1);

          if (session.length > 0) {
            user = { id: session[0].userId };
            
            // Check if user is enrolled in this course
            const enrollment = await db
              .select()
              .from(courseEnrollments)
              .where(and(
                eq(courseEnrollments.courseId, courseId),
                eq(courseEnrollments.userId, session[0].userId)
              ))
              .limit(1);
            
            isEnrolled = enrollment.length > 0;
          }
        } catch (authError) {
          console.log('Auth check failed, continuing as public:', authError);
          // Continue as unauthenticated user
        }
      }

      const course = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (course.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      // Always get basic modules for course structure (titles only for non-enrolled)
      const courseModules = await db
        .select()
        .from(modules)
        .where(eq(modules.courseId, courseId))
        .orderBy(asc(modules.orderNum));

      // Get lessons for each module - limit content based on enrollment
      const modulesWithLessons = await Promise.all(
        courseModules.map(async (module) => {
          const moduleLessons = await db
            .select()
            .from(lessons)
            .where(eq(lessons.moduleId, module.id))
            .orderBy(asc(lessons.orderNum));

          let lessonsWithContent;
          
          if (isEnrolled) {
            // Full access for enrolled users - include quizzes and media
            lessonsWithContent = await Promise.all(
              moduleLessons.map(async (lesson) => {
                const lessonQuizzes = await db
                  .select()
                  .from(quizzes)
                  .where(eq(quizzes.lessonId, lesson.id))
                  .orderBy(asc(quizzes.order));

                const lessonFiles = await db
                  .select()
                  .from(lessonMedia)
                  .where(eq(lessonMedia.lessonId, lesson.id));

                return {
                  ...lesson,
                  quizzes: lessonQuizzes,
                  media: lessonFiles
                };
              })
            );
          } else {
            // Limited access for non-enrolled users - only basic lesson info
            lessonsWithContent = moduleLessons.map(lesson => ({
              id: lesson.id,
              title: lesson.title,
              orderNum: lesson.orderNum,
              durationMinutes: lesson.durationMinutes,
              freePreviewFlag: lesson.freePreviewFlag,
              // Don't include content, videoUrl, quizzes, or media for non-enrolled users
              quizzes: [],
              media: []
            }));
          }

          return {
            ...module,
            lessons: lessonsWithContent
          };
        })
      );

      res.json({
        success: true,
        course: {
          ...course[0],
          modules: modulesWithLessons
        }
      });

    } catch (error) {
      console.error('Course fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch course'
      });
    }
  });

  // Update course details (Creator only)
  app.put('/api/course-creator/courses/:courseId', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const { title, description, category, thumbnailUrl, duration, language, difficulty } = req.body;
      const user = req.user;

      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if course exists and user has permission to edit
      const existingCourse = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (existingCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      // Check if user is admin or course creator
      const userRole = await db
        .select({ role: userRoles.role })
        .from(userRoles)
        .where(eq(userRoles.userId, user.id))
        .limit(1);

      const role = userRole[0]?.role || user.role;
      const isCreator = existingCourse[0].createdBy === user.id;
      const isAdmin = role === 'admin';

      if (!isCreator && !isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Only course creators and admins can edit courses'
        });
      }

      if (!title || !description) {
        return res.status(400).json({
          success: false,
          error: 'Title and description are required'
        });
      }

      // Look up categoryId from category name if provided
      let categoryId = existingCourse[0].categoryId;
      if (category) {
        const categoryResult = await db
          .select({ id: courseCategories.id })
          .from(courseCategories)
          .where(eq(courseCategories.name, category))
          .limit(1);
        
        if (categoryResult.length > 0) {
          categoryId = categoryResult[0].id;
        }
      }

      const updatedCourse = await db
        .update(courses)
        .set({
          title,
          description,
          categoryId,
          thumbnailUrl,
          ...(duration !== undefined && { duration }),
          ...(language !== undefined && { language }),
          ...(difficulty !== undefined && { difficulty }),
          updatedAt: new Date()
        })
        .where(eq(courses.id, courseId))
        .returning();

      res.json({
        success: true,
        course: updatedCourse[0],
        message: 'Course updated successfully'
      });

    } catch (error) {
      console.error('Course update error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update course'
      });
    }
  });

  // Delete course (Creator/Admin only)
  app.delete('/api/course-creator/courses/:courseId', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const user = req.user;

      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if course exists and user has permission to delete
      const existingCourse = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (existingCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      // Check if user is admin or course creator
      const userRole = await db
        .select({ role: userRoles.role })
        .from(userRoles)
        .where(eq(userRoles.userId, user.id))
        .limit(1);

      const role = userRole[0]?.role || user.role;
      const isCreator = existingCourse[0].createdBy === user.id;
      const isAdmin = role === 'admin';

      if (!isCreator && !isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Only course creators and admins can delete courses'
        });
      }

      // Delete course and all related data (cascade delete)
      // First, get all lesson IDs for this course
      const courseLessons = await db
        .select({ id: lessons.id })
        .from(lessons)
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .where(eq(modules.courseId, courseId));
      
      const lessonIds = courseLessons.map(l => l.id);

      // Delete in correct order to avoid foreign key constraint violations
      
      // 1. Delete all data that references lessons
      if (lessonIds.length > 0) {
        // Delete lesson progress
        await db.delete(lessonProgress).where(inArray(lessonProgress.lessonId, lessonIds));
        
        // Delete lesson content blocks
        await db.delete(lessonContentBlocks).where(inArray(lessonContentBlocks.lessonId, lessonIds));
        
        // Delete topics
        await db.delete(topics).where(inArray(topics.lessonId, lessonIds));
        
        // Delete quizzes
        await db.delete(quizzes).where(inArray(quizzes.lessonId, lessonIds));
        
        // Delete lesson media
        try {
          await db.delete(lessonMedia).where(inArray(lessonMedia.lessonId, lessonIds));
        } catch (error: any) {
          console.log('Lesson media table not found, skipping deletion');
        }
      }

      // 2. Delete student progress that references this course (if table exists)
      try {
        await db.delete(studentProgress).where(eq(studentProgress.courseId, courseId));
      } catch (error: any) {
        console.log('Student progress table not found or no data, skipping deletion');
      }

      // 3. Delete lessons
      await db.delete(lessons).where(
        inArray(lessons.moduleId,
          db.select({ id: modules.id })
            .from(modules)
            .where(eq(modules.courseId, courseId))
        )
      );

      // 4. Delete modules
      await db.delete(modules).where(eq(modules.courseId, courseId));

      // 5. Delete all data that references the course
      await db.delete(courseEnrollments).where(eq(courseEnrollments.courseId, courseId));
      await db.delete(coursePurchases).where(eq(coursePurchases.courseId, courseId));
      await db.delete(courseReviews).where(eq(courseReviews.courseId, courseId));
      await db.delete(courseComments).where(eq(courseComments.courseId, courseId));
      await db.delete(certificates).where(eq(certificates.courseId, courseId));

      // 6. Finally delete the course
      await db.delete(courses).where(eq(courses.id, courseId));

      res.json({
        success: true,
        message: 'Course deleted successfully'
      });

    } catch (error) {
      console.error('Course deletion error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete course'
      });
    }
  });

  // Delete module (Creator/Admin only)
  app.delete('/api/course-creator/modules/:moduleId', requireAuth, async (req, res) => {
    try {
      const { moduleId } = req.params;
      const user = req.user;

      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if module exists and get course info for permission check
      const existingModule = await db
        .select({
          id: modules.id,
          courseId: modules.courseId,
          createdBy: courses.createdBy
        })
        .from(modules)
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(modules.id, parseInt(moduleId)))
        .limit(1);

      if (existingModule.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Module not found'
        });
      }

      // Check if user is admin or course creator
      const userRole = await db
        .select({ role: userRoles.role })
        .from(userRoles)
        .where(eq(userRoles.userId, user.id))
        .limit(1);

      const role = userRole[0]?.role || user.role;
      const isCreator = existingModule[0].createdBy === user.id;
      const isAdmin = role === 'admin';

      if (!isCreator && !isAdmin) {
        return res.status(403).json({
          success: false,
          error: 'Only course creators and admins can delete modules'
        });
      }

      // Delete module and all related data (cascade delete)
      // First delete quizzes
      await db.delete(quizzes).where(
        inArray(quizzes.lessonId,
          db.select({ id: lessons.id })
            .from(lessons)
            .where(eq(lessons.moduleId, parseInt(moduleId)))
        )
      );

      // Delete lesson media
      await db.delete(lessonMedia).where(
        inArray(lessonMedia.lessonId,
          db.select({ id: lessons.id })
            .from(lessons)
            .where(eq(lessons.moduleId, parseInt(moduleId)))
        )
      );

      // Delete lessons
      await db.delete(lessons).where(eq(lessons.moduleId, parseInt(moduleId)));

      // Finally delete the module
      await db.delete(modules).where(eq(modules.id, parseInt(moduleId)));

      res.json({
        success: true,
        message: 'Module deleted successfully'
      });

    } catch (error) {
      console.error('Module deletion error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete module'
      });
    }
  });

  // Create a new module in a course
  app.post('/api/course-creator/courses/:courseId/modules', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const { title, orderNum } = req.body;

      if (!title) {
        return res.status(400).json({
          success: false,
          error: 'Module title is required'
        });
      }

      const newModule = await db
        .insert(modules)
        .values({
          courseId,
          title,
          orderNum: orderNum || 1
        })
        .returning();

      res.json({
        success: true,
        module: newModule[0],
        message: 'Module created successfully'
      });

    } catch (error) {
      console.error('Module creation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create module'
      });
    }
  });

  // Create a new lesson in a module
  app.post('/api/course-creator/modules/:moduleId/lessons', requireAuth, async (req, res) => {
    try {
      const { moduleId } = req.params;
      const { title, content, videoUrl, orderNum } = req.body;

      if (!title) {
        return res.status(400).json({
          success: false,
          error: 'Lesson title is required'
        });
      }

      const newLesson = await db
        .insert(lessons)
        .values({
          moduleId: parseInt(moduleId),
          title,
          content: content || '',
          videoUrl,
          orderNum: orderNum || 1,
          categoryId: 16 // Default to "General" category
        })
        .returning();

      res.json({
        success: true,
        lesson: newLesson[0],
        message: 'Lesson created successfully'
      });

    } catch (error) {
      console.error('Lesson creation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create lesson'
      });
    }
  });

  // Upload media for a lesson
  app.post('/api/course-creator/lessons/:lessonId/media', requireAuth, upload.single('file'), async (req, res) => {
    try {
      const { lessonId } = req.params;
      const file = req.file as FileMetadata;

      if (!file) {
        return res.status(400).json({
          success: false,
          error: 'No file uploaded'
        });
      }

      const fileType = ['image/jpeg', 'image/png', 'image/jpg'].includes(file.mimetype) ? 'image' : 'file';

      const newMedia = await db
        .insert(lessonMedia)
        .values({
          lessonId: parseInt(lessonId),
          type: fileType,
          fileUrl: file.cloudinaryUrl || file.url,
          originalName: file.originalname,
          fileSize: file.size,
          mimeType: file.mimetype
        })
        .returning();

      res.json({
        success: true,
        media: newMedia[0],
        message: 'Media uploaded successfully'
      });

    } catch (error) {
      console.error('Media upload error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to upload media'
      });
    }
  });

  // Get all media for a lesson
  app.get('/api/course-creator/lessons/:lessonId/media', requireAuth, async (req, res) => {
    try {
      // Validate lesson ID parameter
      const lessonIdSchema = z.coerce.number().int().positive();
      let lessonId: number;
      try {
        lessonId = lessonIdSchema.parse(req.params.lessonId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid lesson ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check lesson exists and verify ownership
      const lessonWithCourse = await db
        .select({
          lesson: lessons,
          courseAuthorId: courses.createdBy
        })
        .from(lessons)
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(lessons.id, lessonId))
        .limit(1);

      if (lessonWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Lesson not found'
        });
      }

      // Check ownership - user must be the course author
      if (lessonWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to view this lesson media'
        });
      }

      const mediaFiles = await db
        .select()
        .from(lessonMedia)
        .where(eq(lessonMedia.lessonId, lessonId))
        .orderBy(desc(lessonMedia.createdAt));

      res.json({
        success: true,
        media: mediaFiles
      });

    } catch (error) {
      console.error('Media fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch media'
      });
    }
  });

  // Replace/update lesson media
  app.put('/api/course-creator/media/:mediaId', requireAuth, upload.single('file'), async (req, res) => {
    try {
      // Validate media ID parameter
      const mediaIdSchema = z.coerce.number().int().positive();
      let mediaId: number;
      try {
        mediaId = mediaIdSchema.parse(req.params.mediaId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      const file = req.file as FileMetadata;
      if (!file) {
        return res.status(400).json({
          success: false,
          error: 'No file uploaded'
        });
      }

      // Validate file using existing validation
      const validationResult = validateFile(file);
      if (!validationResult.isValid) {
        return res.status(400).json({
          success: false,
          error: validationResult.error
        });
      }

      // Check media exists and verify ownership
      const mediaWithCourse = await db
        .select({
          media: lessonMedia,
          courseAuthorId: courses.createdBy
        })
        .from(lessonMedia)
        .innerJoin(lessons, eq(lessonMedia.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(lessonMedia.id, mediaId))
        .limit(1);

      if (mediaWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Media not found'
        });
      }

      // Check ownership - user must be the course author
      if (mediaWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to edit this media'
        });
      }

      const fileType = getFileType(file);
      
      // Store old file URL for cleanup (if it's a Cloudinary URL)
      const oldFileUrl = mediaWithCourse[0].media.fileUrl;

      const updatedMedia = await db
        .update(lessonMedia)
        .set({
          type: fileType,
          fileUrl: file.cloudinaryUrl || file.url,
          originalName: file.originalname,
          fileSize: file.size,
          mimeType: file.mimetype
        })
        .where(eq(lessonMedia.id, mediaId))
        .returning();

      // TODO: Implement Cloudinary cleanup of old file
      // This would require extracting the public_id from the old URL
      // and calling cloudinaryStorage.deleteFile(publicId)
      console.log('TODO: Clean up old file:', oldFileUrl);

      res.json({
        success: true,
        media: updatedMedia[0],
        message: 'Media updated successfully'
      });

    } catch (error) {
      console.error('Media update error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update media'
      });
    }
  });

  // Delete lesson media
  app.delete('/api/course-creator/media/:mediaId', requireAuth, async (req, res) => {
    try {
      // Validate media ID parameter
      const mediaIdSchema = z.coerce.number().int().positive();
      let mediaId: number;
      try {
        mediaId = mediaIdSchema.parse(req.params.mediaId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check media exists and verify ownership
      const mediaWithCourse = await db
        .select({
          media: lessonMedia,
          courseAuthorId: courses.createdBy
        })
        .from(lessonMedia)
        .innerJoin(lessons, eq(lessonMedia.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(lessonMedia.id, mediaId))
        .limit(1);

      if (mediaWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Media not found'
        });
      }

      // Check ownership - user must be the course author
      if (mediaWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to delete this media'
        });
      }

      // Store file URL for cleanup
      const fileUrl = mediaWithCourse[0].media.fileUrl;

      await db
        .delete(lessonMedia)
        .where(eq(lessonMedia.id, mediaId));

      // TODO: Implement Cloudinary cleanup
      // Extract public_id from fileUrl and delete from Cloudinary
      console.log('TODO: Clean up deleted file:', fileUrl);

      res.json({
        success: true,
        message: 'Media deleted successfully'
      });

    } catch (error) {
      console.error('Media deletion error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete media'
      });
    }
  });

  // Get a specific media file
  app.get('/api/course-creator/media/:mediaId', requireAuth, async (req, res) => {
    try {
      // Validate media ID parameter
      const mediaIdSchema = z.coerce.number().int().positive();
      let mediaId: number;
      try {
        mediaId = mediaIdSchema.parse(req.params.mediaId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check media exists and verify ownership
      const mediaWithCourse = await db
        .select({
          media: lessonMedia,
          courseAuthorId: courses.createdBy
        })
        .from(lessonMedia)
        .innerJoin(lessons, eq(lessonMedia.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(lessonMedia.id, mediaId))
        .limit(1);

      if (mediaWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Media not found'
        });
      }

      // Check ownership - user must be the course author
      if (mediaWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to view this media'
        });
      }

      res.json({
        success: true,
        media: mediaWithCourse[0].media
      });

    } catch (error) {
      console.error('Media fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch media'
      });
    }
  });

  // ======================= PRODUCT UPLOAD ENDPOINTS =======================

  // Upload product images (supports multiple files)

  // Update lesson media settings (visibility)
  app.patch('/api/course-creator/media/:mediaId/settings', requireAuth, async (req, res) => {
    try {
      const mediaIdSchema = z.coerce.number().int().positive();
      let mediaId: number;
      try {
        mediaId = mediaIdSchema.parse(req.params.mediaId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid media ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Validate settings
      const settingsSchema = z.object({
        isCollapsible: z.boolean().optional(),
        isVisibleByDefault: z.boolean().optional()
      });

      let settings;
      try {
        settings = settingsSchema.parse(req.body);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid settings data'
        });
      }

      // Check media exists and verify ownership
      const mediaWithCourse = await db
        .select({
          media: lessonMedia,
          courseAuthorId: courses.createdBy
        })
        .from(lessonMedia)
        .innerJoin(lessons, eq(lessonMedia.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(lessonMedia.id, mediaId))
        .limit(1);

      if (mediaWithCourse.length === 0) {
        return res.status(404).json({ success: false, error: 'Media not found' });
      }

      const courseAuthorId = mediaWithCourse[0].courseAuthorId;
      if (courseAuthorId !== user.id) {
        return res.status(403).json({ success: false, error: 'Forbidden' });
      }

      // Update media settings
      const updateData: any = {};
      if (settings.isCollapsible !== undefined) {
        updateData.isCollapsible = settings.isCollapsible;
      }
      if (settings.isVisibleByDefault !== undefined) {
        updateData.isVisibleByDefault = settings.isVisibleByDefault;
      }

      await db
        .update(lessonMedia)
        .set(updateData)
        .where(eq(lessonMedia.id, mediaId));

      res.json({ success: true, message: 'Media settings updated successfully' });
    } catch (error) {
      console.error('[MEDIA_SETTINGS_UPDATE_ERROR]', error);
      res.status(500).json({ success: false, error: 'Failed to update media settings' });
    }
  });
  app.post('/api/products/upload/images', requireAuth, upload.array('images', 10), async (req, res) => {
    try {
      const files = req.files as Express.Multer.File[];

      if (!files || files.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No images uploaded'
        });
      }

      const uploadPromises = files.map(async (file) => {
        const result = await cloudinaryStorage.uploadFile(
          file.buffer,
          file.originalname,
          file.mimetype,
          'products/images'
        );

        if (!result.success) {
          throw new Error(result.error || 'Upload failed');
        }

        return {
          url: result.url,
          originalName: file.originalname,
          size: file.size,
          mimeType: file.mimetype
        };
      });

      const uploadedImages = await Promise.all(uploadPromises);

      res.json({
        success: true,
        images: uploadedImages,
        message: `${uploadedImages.length} image(s) uploaded successfully`
      });

    } catch (error) {
      console.error('Product images upload error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to upload product images'
      });
    }
  });

  // Upload downloadable files for digital products
  app.post('/api/products/upload/files', requireAuth, upload.array('files', 5), async (req, res) => {
    try {
      const files = req.files as Express.Multer.File[];
      const { fileTypes } = req.body; // Array of file types: 'main', 'preview', 'sample'

      if (!files || files.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'No files uploaded'
        });
      }

      const uploadPromises = files.map(async (file, index) => {
        const fileType = fileTypes && fileTypes[index] ? fileTypes[index] : 'main';
        
        const result = await cloudinaryStorage.uploadFile(
          file.buffer,
          file.originalname,
          file.mimetype,
          `products/files/${fileType}`
        );

        if (!result.success) {
          throw new Error(result.error || 'Upload failed');
        }

        return {
          id: uuidv4(),
          name: file.originalname,
          url: result.url,
          size: file.size,
          type: fileType,
          format: file.originalname.split('.').pop()?.toLowerCase() || 'unknown',
          downloadCount: 0
        };
      });

      const uploadedFiles = await Promise.all(uploadPromises);

      res.json({
        success: true,
        files: uploadedFiles,
        message: `${uploadedFiles.length} file(s) uploaded successfully`
      });

    } catch (error) {
      console.error('Product files upload error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to upload product files'
      });
    }
  });

  // Create a quiz for a lesson
  app.post('/api/course-creator/lessons/:lessonId/quizzes', requireAuth, async (req, res) => {
    try {
      const { lessonId } = req.params;
      const { title, description, questions, timeLimitMinutes, passingScore, topicId } = req.body;

      // Validate request data with Zod
      const questionSchema = z.object({
        question: z.string().min(1),
        options: z.array(z.string()).min(2),
        correctAnswer: z.string(),
        explanation: z.string().optional(),
        questionType: z.enum(['mcq', 'true_false', 'short_answer']).optional(),
        points: z.number().optional()
      });

      const quizDataSchema = z.object({
        title: z.string().min(1),
        description: z.string().optional(),
        questions: z.array(questionSchema).min(1),
        timeLimitMinutes: z.coerce.number().int().optional(),
        passingScore: z.coerce.number().int().optional(),
        topicId: z.coerce.number().int().optional()
      });

      const validatedData = quizDataSchema.parse({
        title,
        description,
        questions,
        timeLimitMinutes,
        passingScore,
        topicId
      });

      const insertData = {
        lessonId: parseInt(lessonId),
        title: validatedData.title,
        description: validatedData.description || '',
        questions: validatedData.questions, // Pass as JSON object, not stringified
        timeLimitMinutes: validatedData.timeLimitMinutes || null,
        passingScore: validatedData.passingScore || 70,
        topicId: validatedData.topicId || null
      };

      console.log('ðŸ” Quiz insert data:', JSON.stringify(insertData, null, 2));
      console.log('ðŸ” Quizzes schema columns:', Object.keys(quizzes));

      const newQuiz = await db
        .insert(quizzes)
        .values(insertData)
        .returning();

      res.json({
        success: true,
        quiz: newQuiz[0],
        message: 'Quiz created successfully'
      });

    } catch (error) {
      console.error('Quiz creation error:', error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          error: 'Invalid quiz data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to create quiz'
      });
    }
  });

  // Mark lesson as complete
  app.post('/api/course-creator/lessons/:lessonId/complete', requireAuth, async (req, res) => {
    try {
      const { lessonId } = req.params;
      const user = req.user;

      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Get the lesson to find its course
      const lesson = await db
        .select({
          id: lessons.id,
          moduleId: lessons.moduleId
        })
        .from(lessons)
        .where(eq(lessons.id, parseInt(lessonId)))
        .limit(1);

      if (!lesson || lesson.length === 0) {
        return res.status(404).json({ success: false, error: 'Lesson not found' });
      }

      // Get the module to find the course
      const module = await db
        .select({
          id: modules.id,
          courseId: modules.courseId
        })
        .from(modules)
        .where(eq(modules.id, lesson[0].moduleId))
        .limit(1);

      if (!module || module.length === 0) {
        return res.status(404).json({ success: false, error: 'Module not found' });
      }

      const courseId = module[0].courseId;

      // Check if progress record exists
      const existingProgress = await db
        .select()
        .from(lessonProgress)
        .where(and(
          eq(lessonProgress.userId, user.id),
          eq(lessonProgress.lessonId, parseInt(lessonId)),
          eq(lessonProgress.courseOrSubjectId, courseId)
        ))
        .limit(1);

      if (existingProgress && existingProgress.length > 0) {
        // Update existing progress
        await db
          .update(lessonProgress)
          .set({
            completedAt: new Date(),
            progressPercent: 100,
            updatedAt: new Date()
          })
          .where(eq(lessonProgress.id, existingProgress[0].id));
      } else {
        // Create new progress record
        await db
          .insert(lessonProgress)
          .values({
            userId: user.id,
            lessonId: parseInt(lessonId),
            courseOrSubjectId: courseId,
            startedAt: new Date(),
            completedAt: new Date(),
            progressPercent: 100
          });
      }

      res.json({
        success: true,
        message: 'Lesson marked as complete'
      });

    } catch (error) {
      console.error('Mark lesson complete error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to mark lesson as complete'
      });
    }
  });


  // Update a quiz for a lesson
  app.put('/api/course-creator/quizzes/:quizId', requireAuth, async (req, res) => {
    try {
      // Validate quiz ID parameter
      const quizIdSchema = z.coerce.number().int().positive();
      let quizId: number;
      try {
        quizId = quizIdSchema.parse(req.params.quizId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid quiz ID'
        });
      }

      const { title, description, questions, timeLimitMinutes, passingScore } = req.body;
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Validate request data with Zod
      const questionSchema = z.object({
        question: z.string().min(1),
        options: z.array(z.string()).min(2),
        correctAnswer: z.string(),
        explanation: z.string().optional(),
        questionType: z.enum(['mcq', 'true_false', 'short_answer']).optional(),
        points: z.number().optional()
      });

      const quizDataSchema = z.object({
        title: z.string().min(1),
        description: z.string().optional(),
        questions: z.array(questionSchema).min(1),
        timeLimitMinutes: z.coerce.number().int().optional(),
        passingScore: z.coerce.number().int().optional()
      });

      const validatedData = quizDataSchema.parse({
        title,
        description,
        questions,
        timeLimitMinutes,
        passingScore
      });

      // Check quiz exists and verify ownership
      const quizWithCourse = await db
        .select({
          quiz: quizzes,
          courseAuthorId: courses.createdBy
        })
        .from(quizzes)
        .innerJoin(lessons, eq(quizzes.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(quizzes.id, quizId))
        .limit(1);

      if (quizWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Quiz not found'
        });
      }

      // Check ownership - user must be the course author
      if (quizWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to edit this quiz'
        });
      }

      const updateData = {
        title: validatedData.title,
        description: validatedData.description || '',
        questions: validatedData.questions,
        timeLimitMinutes: validatedData.timeLimitMinutes || null,
        passingScore: validatedData.passingScore || 70,
        updatedAt: new Date()
      };

      const updatedQuiz = await db
        .update(quizzes)
        .set(updateData)
        .where(eq(quizzes.id, quizId))
        .returning();

      res.json({
        success: true,
        quiz: updatedQuiz[0],
        message: 'Quiz updated successfully'
      });

    } catch (error) {
      console.error('Quiz update error:', error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          success: false,
          error: 'Invalid quiz data',
          details: error.errors
        });
      }
      res.status(500).json({
        success: false,
        error: 'Failed to update quiz'
      });
    }
  });

  // Delete a quiz
  app.delete('/api/course-creator/quizzes/:quizId', requireAuth, async (req, res) => {
    try {
      // Validate quiz ID parameter
      const quizIdSchema = z.coerce.number().int().positive();
      let quizId: number;
      try {
        quizId = quizIdSchema.parse(req.params.quizId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid quiz ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check quiz exists and verify ownership
      const quizWithCourse = await db
        .select({
          quiz: quizzes,
          courseAuthorId: courses.createdBy
        })
        .from(quizzes)
        .innerJoin(lessons, eq(quizzes.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(quizzes.id, quizId))
        .limit(1);

      if (quizWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Quiz not found'
        });
      }

      // Check ownership - user must be the course author
      if (quizWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to delete this quiz'
        });
      }

      await db
        .delete(quizzes)
        .where(eq(quizzes.id, quizId));

      res.json({
        success: true,
        message: 'Quiz deleted successfully'
      });

    } catch (error) {
      console.error('Quiz deletion error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to delete quiz'
      });
    }
  });

  // Get a specific quiz for editing
  app.get('/api/course-creator/quizzes/:quizId', requireAuth, async (req, res) => {
    try {
      // Validate quiz ID parameter
      const quizIdSchema = z.coerce.number().int().positive();
      let quizId: number;
      try {
        quizId = quizIdSchema.parse(req.params.quizId);
      } catch (error) {
        return res.status(400).json({
          success: false,
          error: 'Invalid quiz ID'
        });
      }

      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check quiz exists and verify ownership
      const quizWithCourse = await db
        .select({
          quiz: quizzes,
          courseAuthorId: courses.createdBy
        })
        .from(quizzes)
        .innerJoin(lessons, eq(quizzes.lessonId, lessons.id))
        .innerJoin(modules, eq(lessons.moduleId, modules.id))
        .innerJoin(courses, eq(modules.courseId, courses.id))
        .where(eq(quizzes.id, quizId))
        .limit(1);

      if (quizWithCourse.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Quiz not found'
        });
      }

      // Check ownership - user must be the course author
      if (quizWithCourse[0].courseAuthorId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Not authorized to view this quiz'
        });
      }

      res.json({
        success: true,
        quiz: quizWithCourse[0].quiz
      });

    } catch (error) {
      console.error('Quiz fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch quiz'
      });
    }
  });

  // Get published courses for students
  app.get('/api/course-creator/public-courses', async (req, res) => {
    try {
      // First get courses without joins to avoid orderSelectedFields issues
      const coursesData = await db
        .select({
          id: courses.id,
          title: courses.title,
          description: courses.description,
          categoryId: courses.categoryId,
          thumbnailUrl: courses.thumbnailUrl,
          price: courses.price,
          difficulty: courses.difficulty,
          duration: courses.duration,
          avgRating: courses.avgRating,
          totalReviews: courses.totalReviews,
          totalEnrollments: courses.totalEnrollments,
          tags: courses.tags,
          createdBy: courses.createdBy,
          createdAt: courses.createdAt
        })
        .from(courses)
        .where(eq(courses.isActive, true))
        .orderBy(desc(courses.createdAt));

      // Get author names and category names separately to avoid join issues
      const enrichedCourses = await Promise.all(
        coursesData.map(async (course) => {
          let authorName = null;
          let categoryName = null;
          
          try {
            if (course.createdBy) {
              const authorProfile = await db
                .select({ name: profiles.name })
                .from(profiles)
                .where(eq(profiles.userId, course.createdBy))
                .limit(1);
              
              if (authorProfile.length > 0) {
                authorName = authorProfile[0].name;
              }
            }
          } catch (error) {
            console.error('Error fetching author name for course:', course.id, error);
          }
          
          try {
            if (course.categoryId) {
              const category = await db
                .select({ name: courseCategories.name })
                .from(courseCategories)
                .where(eq(courseCategories.id, course.categoryId))
                .limit(1);
              
              if (category.length > 0) {
                categoryName = category[0].name;
              }
            }
          } catch (error) {
            console.error('Error fetching category name for course:', course.id, error);
          }
          
          return {
            ...course,
            authorName,
            categoryId: categoryName || course.categoryId
          };
        })
      );

      res.json({
        success: true,
        courses: enrichedCourses
      });

    } catch (error) {
      console.error('Public courses fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch courses'
      });
    }
  });

  // Enroll student in a course (only for free courses)
  app.post('/api/course-creator/enroll/:courseId', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const user = req.user;
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if course exists and is published
      const course = await db
        .select()
        .from(courses)
        .where(and(eq(courses.id, courseId), eq(courses.isActive, true)))
        .limit(1);

      if (course.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found or not available'
        });
      }

      // Check if user has access to this course based on pricing type
      const coursePrice = parseFloat(course[0].price?.toString() || '0');
      const pricingType = course[0].pricingType;
      const subscriptionStatus = await hasActiveSubscription(user.id);
      
      // Allow enrollment based on pricing type:
      // 1. Free courses (pricingType = "free" or price = 0) - anyone can enroll
      // 2. Subscription courses (pricingType = "subscription") - requires active subscription
      // 3. Fixed-price courses (pricingType = "fixed_price" with price > 0) - must go through checkout
      // 4. Legacy courses (no pricingType but price > 0) - treat as fixed-price paid courses
      let hasAccess = false;
      let requiresPayment = false;

      if (coursePrice === 0 || pricingType === 'free') {
        // Free course - anyone can enroll
        hasAccess = true;
      } else if (pricingType === 'subscription') {
        // Subscription course - requires active subscription
        hasAccess = subscriptionStatus.hasAccess;
      } else if (pricingType === 'fixed_price' || (!pricingType && coursePrice > 0)) {
        // Paid course (explicit fixed_price or legacy with price > 0) - must go through checkout
        hasAccess = false;
        requiresPayment = true;
      }

      if (!hasAccess) {
        if (requiresPayment) {
          return res.status(400).json({
            success: false,
            error: 'This is a paid course. Please complete the purchase to enroll.',
            isPaid: true,
            price: coursePrice,
            requiresCheckout: true
          });
        } else {
          return res.status(400).json({
            success: false,
            error: 'This course requires an active subscription. Please upgrade your plan to access premium courses.',
            isPaid: true,
            price: coursePrice,
            subscriptionRequired: true,
            currentSubscription: subscriptionStatus.subscriptionTier || 'free'
          });
        }
      }

      // Check if already enrolled
      const existingEnrollment = await db
        .select()
        .from(courseEnrollments)
        .where(and(
          eq(courseEnrollments.userId, user.id),
          eq(courseEnrollments.courseId, courseId)
        ))
        .limit(1);

      if (existingEnrollment.length > 0) {
        return res.status(400).json({
          success: false,
          error: 'Already enrolled in this course'
        });
      }

      // Create enrollment for free course
      const newEnrollment = await db
        .insert(courseEnrollments)
        .values({
          userId: user.id,
          courseId
        })
        .returning();

      res.json({
        success: true,
        enrollment: newEnrollment[0],
        message: 'Successfully enrolled in course'
      });

    } catch (error) {
      console.error('Course enrollment error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to enroll in course'
      });
    }
  });

  // Create payment intent for course purchase
  app.post('/api/course-creator/purchase/:courseId', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const user = req.user;
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Check if course exists and is published
      const course = await db
        .select()
        .from(courses)
        .where(and(eq(courses.id, courseId), eq(courses.isActive, true)))
        .limit(1);

      if (course.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found or not available'
        });
      }

      const coursePrice = parseFloat(course[0].price?.toString() || '0');
      
      if (coursePrice <= 0) {
        return res.status(400).json({
          success: false,
          error: 'This course is free. Use the enroll endpoint instead.'
        });
      }

      // Check if already enrolled or purchased
      const existingEnrollment = await db
        .select()
        .from(courseEnrollments)
        .where(and(
          eq(courseEnrollments.userId, user.id),
          eq(courseEnrollments.courseId, courseId)
        ))
        .limit(1);

      if (existingEnrollment.length > 0) {
        return res.status(400).json({
          success: false,
          error: 'Already enrolled in this course'
        });
      }

      // Create Stripe payment intent (use global Stripe instance)
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({
          success: false,
          error: 'Payment processing unavailable'
        });
      }

      const paymentIntent = await stripe.paymentIntents.create({
        amount: Math.round(coursePrice * 100), // Convert to cents
        currency: 'usd',
        metadata: {
          courseId: courseId,
          userId: user.id,
          courseName: course[0].title,
          type: 'course_purchase'
        }
      });

      res.json({
        success: true,
        clientSecret: paymentIntent.client_secret,
        course: {
          id: course[0].id,
          title: course[0].title,
          price: coursePrice
        }
      });

    } catch (error) {
      console.error('Course purchase error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create payment intent'
      });
    }
  });

  // Confirm course purchase and enroll student after successful payment
  app.post('/api/course-creator/confirm-purchase', requireAuth, async (req, res) => {
    try {
      const { paymentIntentId } = req.body;
      const user = req.user;
      
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      if (!paymentIntentId) {
        return res.status(400).json({
          success: false,
          error: 'Payment intent ID is required'
        });
      }

      // Verify payment with Stripe (use global instance and validate server-side)
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({
          success: false,
          error: 'Payment processing unavailable'
        });
      }

      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

      // Comprehensive server-side validation
      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({
          success: false,
          error: 'Payment not successful'
        });
      }

      // Validate metadata exists and matches
      if (!paymentIntent.metadata?.courseId || !paymentIntent.metadata?.userId) {
        return res.status(400).json({
          success: false,
          error: 'Invalid payment metadata'
        });
      }

      const courseId = paymentIntent.metadata.courseId;
      const paymentUserId = paymentIntent.metadata.userId;

      // Verify the user matches (critical security check)
      if (paymentUserId !== user.id) {
        return res.status(403).json({
          success: false,
          error: 'Payment user mismatch'
        });
      }

      // Verify course exists and get current price
      const course = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (course.length === 0) {
        return res.status(404).json({
          success: false,
          error: 'Course not found'
        });
      }

      // Validate payment amount matches current course price
      const expectedAmount = Math.round(parseFloat(course[0].price?.toString() || '0') * 100);
      if (paymentIntent.amount !== expectedAmount) {
        return res.status(400).json({
          success: false,
          error: 'Payment amount mismatch'
        });
      }

      // Validate currency
      if (paymentIntent.currency !== 'usd') {
        return res.status(400).json({
          success: false,
          error: 'Invalid payment currency'
        });
      }

      // Use a database transaction for atomicity
      await db.transaction(async (tx) => {
        // Check if already enrolled (with transaction lock)
        const existingEnrollment = await tx
          .select()
          .from(courseEnrollments)
          .where(and(
            eq(courseEnrollments.userId, user.id),
            eq(courseEnrollments.courseId, courseId)
          ))
          .limit(1);

        if (existingEnrollment.length > 0) {
          throw new Error('Already enrolled in this course');
        }

        // Check if payment already processed (idempotency)
        const existingPayment = await tx
          .select()
          .from(payments)
          .where(eq(payments.stripePaymentIntentId, paymentIntentId))
          .limit(1);

        if (existingPayment.length > 0) {
          throw new Error('Payment already processed');
        }

        // Record the payment
        await tx.insert(payments).values({
          userId: user.id,
          amount: (paymentIntent.amount / 100).toString(), // Convert from cents
          currency: paymentIntent.currency.toUpperCase(),
          status: 'succeeded',
          stripePaymentIntentId: paymentIntentId,
          description: `Course purchase: ${paymentIntent.metadata.courseName}`,
          paymentMethod: 'card',
          processedAt: new Date(),
          metadata: {
            courseId: courseId,
            courseName: paymentIntent.metadata.courseName,
            type: 'course_purchase'
          }
        });

        // Create enrollment after successful payment
        const newEnrollment = await tx
          .insert(courseEnrollments)
          .values({
            userId: user.id,
            courseId: courseId
          })
          .returning();

        // Update course enrollment count
        await tx
          .update(courses)
          .set({
            totalEnrollments: sql`${courses.totalEnrollments} + 1`
          })
          .where(eq(courses.id, courseId));

        return newEnrollment[0];
      }).then(async (newEnrollment) => {
        // Send confirmation email
        try {
          const { emailService } = await import('./utils/email.js');
          const userProfile = await db.select().from(profiles).where(eq(profiles.userId, user.id)).limit(1);
          const userEmail = userProfile[0]?.email || user.email;
          
          if (userEmail) {
            await emailService.sendCoursePurchaseEmail(userEmail, {
              courseName: paymentIntent.metadata.courseName || course[0].title,
              price: paymentIntent.amount / 100,
              orderId: paymentIntentId,
              customerName: userProfile[0]?.name || undefined,
              accessUrl: `https://edufiliova.com/course/${courseId}`,
            });
            console.log('ðŸ“§ Course purchase confirmation email sent to:', userEmail);
          }
        } catch (emailError) {
          console.error('Failed to send course purchase email:', emailError);
        }

        res.json({
          success: true,
          enrollment: newEnrollment,
          message: 'Course purchased and enrolled successfully!'
        });
      }).catch((error) => {
        if (error.message === 'Already enrolled in this course' || 
            error.message === 'Payment already processed') {
          return res.status(400).json({
            success: false,
            error: error.message
          });
        }
        throw error; // Re-throw unexpected errors
      });

    } catch (error) {
      console.error('Course purchase confirmation error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to confirm course purchase'
      });
    }
  });

  // Get student's enrolled courses
  app.get('/api/course-creator/my-courses', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Get enrolled courses without problematic joins
      const enrollmentsData = await db
        .select({
          courseId: courses.id,
          title: courses.title,
          description: courses.description,
          categoryId: courses.categoryId,
          thumbnailUrl: courses.thumbnailUrl,
          enrolledAt: courseEnrollments.enrolledAt,
          progress: courseEnrollments.progress,
          createdBy: courses.createdBy
        })
        .from(courseEnrollments)
        .innerJoin(courses, eq(courseEnrollments.courseId, courses.id))
        .where(eq(courseEnrollments.userId, user.id))
        .orderBy(desc(courseEnrollments.enrolledAt));

      // Get author names separately to avoid join issues
      const enrichedCourses = await Promise.all(
        enrollmentsData.map(async (course) => {
          let authorName = null;
          try {
            if (course.createdBy) {
              const authorProfile = await db
                .select({ name: profiles.name })
                .from(profiles)
                .where(eq(profiles.userId, course.createdBy))
                .limit(1);
              
              if (authorProfile.length > 0) {
                authorName = authorProfile[0].name;
              }
            }
          } catch (error) {
            console.error('Error fetching author name for enrolled course:', course.courseId, error);
          }
          
          return {
            ...course,
            authorName
          };
        })
      );

      res.json({
        success: true,
        courses: enrichedCourses
      });

    } catch (error) {
      console.error('My courses fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch enrolled courses'
      });
    }
  });

  // Unsubscribe student from all enrolled courses
  app.post('/api/course-creator/unsubscribe-all', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Get all enrolled courses before deletion for logging
      const enrolledCourses = await db
        .select({
          courseId: courses.id,
          title: courses.title
        })
        .from(courseEnrollments)
        .innerJoin(courses, eq(courseEnrollments.courseId, courses.id))
        .where(eq(courseEnrollments.userId, user.id));

      console.log(`Unsubscribing user ${user.id} from ${enrolledCourses.length} courses:`, 
        enrolledCourses.map(c => c.title).join(', '));

      // Delete all course enrollments for the user
      const deletedEnrollments = await db
        .delete(courseEnrollments)
        .where(eq(courseEnrollments.userId, user.id))
        .returning();

      res.json({
        success: true,
        message: `Successfully unsubscribed from ${deletedEnrollments.length} courses`,
        unsubscribedCount: deletedEnrollments.length,
        unsubscribedCourses: enrolledCourses.map(c => ({ id: c.courseId, title: c.title }))
      });

    } catch (error) {
      console.error('Unsubscribe error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to unsubscribe from courses'
      });
    }
  });

  // Update student progress
  app.post('/api/course-creator/progress', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      const { courseId, lessonId, progressPercentage, timeSpent } = req.body;

      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      // Create or update progress
      const progressData = {
        userId: user.id,
        courseId,
        lessonId,
        progressPercentage: progressPercentage || 0,
        timeSpent: timeSpent || 0,
        lastAccessedAt: new Date()
      };

      const existingProgress = await db
        .select()
        .from(studentProgress)
        .where(and(
          eq(studentProgress.userId, user.id),
          eq(studentProgress.courseId, courseId),
          eq(studentProgress.lessonId, lessonId)
        ))
        .limit(1);

      let progress;
      if (existingProgress.length > 0) {
        progress = await db
          .update(studentProgress)
          .set(progressData)
          .where(eq(studentProgress.id, existingProgress[0].id))
          .returning();
      } else {
        progress = await db
          .insert(studentProgress)
          .values(progressData)
          .returning();
      }

      // Update overall course progress
      if (progressPercentage === 100) {
        await db
          .update(courseEnrollments)
          .set({ progress: progressPercentage })
          .where(and(
            eq(courseEnrollments.userId, user.id),
            eq(courseEnrollments.courseId, courseId)
          ));
      }

      res.json({
        success: true,
        progress: progress[0],
        message: 'Progress updated successfully'
      });

    } catch (error) {
      console.error('Progress update error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to update progress'
      });
    }
  });

  // Daily Questions System API endpoints
  
  // Get today's daily questions (7 questions for the current day)
  app.get('/api/daily-questions/today/:userId', requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      
      // Get user profile to check their grade and grade system
      const userProfile = await db
        .select()
        .from(users)
        .where(eq(users.id, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'User not found' });
      }

      const userGrade = userProfile[0].grade;
      const userGradeSystem = userProfile[0].gradeSystem;

      // Calculate user's current day based on their progress
      // Find the last completed day
      const lastCompletedDay = await db
        .select({ dayNumber: dailyProgressSummary.dayNumber })
        .from(dailyProgressSummary)
        .where(
          and(
            eq(dailyProgressSummary.userId, userId),
            sql`${dailyProgressSummary.completedAt} IS NOT NULL`
          )
        )
        .orderBy(desc(dailyProgressSummary.dayNumber))
        .limit(1);

      // Current day is either the last completed day + 1, or day 1 for new users
      const currentDay = lastCompletedDay.length > 0 
        ? lastCompletedDay[0].dayNumber + 1 
        : 1;
      
      // Get total days available in the system (filtered by grade)
      // Build where conditions dynamically to handle null gradeSystem
      const totalDaysConditions = [eq(subjects.gradeLevel, userGrade)];
      if (userGradeSystem !== null && userGradeSystem !== undefined) {
        totalDaysConditions.push(eq(subjects.gradeSystem, userGradeSystem));
      }
      
      const totalDaysResult = await db
        .select({ maxDay: sql<number>`MAX(${dailyQuestions.dayNumber})` })
        .from(dailyQuestions)
        .leftJoin(subjects, eq(dailyQuestions.subjectId, subjects.id))
        .where(and(...totalDaysConditions));
      
      const totalDays = totalDaysResult[0]?.maxDay || 200;

      // Check if user has questions available for current day
      if (currentDay > totalDays) {
        return res.json({
          success: true,
          data: {
            dayNumber: totalDays,
            totalDays,
            isCompleted: true,
            questions: [],
            totalQuestions: 0,
            answeredQuestions: 0,
            correctAnswers: 0,
            message: "Congratulations! You've completed all available daily questions."
          }
        });
      }

      // Get today's questions - FILTERED BY GRADE AND GRADE SYSTEM
      const todaysQuestions = await db
        .select({
          id: dailyQuestions.id,
          dayNumber: dailyQuestions.dayNumber,
          question: dailyQuestions.question,
          options: dailyQuestions.options,
          correctAnswer: dailyQuestions.correctAnswer,
          explanation: dailyQuestions.explanation,
          difficulty: dailyQuestions.difficulty,
          questionOrder: dailyQuestions.questionOrder,
          subjectId: dailyQuestions.subjectId,
          subjectName: subjects.name,
          gradeLevel: subjects.gradeLevel,
          gradeSystem: subjects.gradeSystem,
        })
        .from(dailyQuestions)
        .leftJoin(subjects, eq(dailyQuestions.subjectId, subjects.id))
        .where(
          and(
            eq(dailyQuestions.dayNumber, currentDay),
            eq(subjects.gradeLevel, userGrade),
            eq(subjects.gradeSystem, userGradeSystem)
          )
        )
        .orderBy(asc(dailyQuestions.questionOrder));

      // Get user's progress for today's questions
      const userProgress = await db
        .select()
        .from(dailyQuestionProgress)
        .where(
          and(
            eq(dailyQuestionProgress.userId, userId),
            eq(dailyQuestionProgress.dayNumber, currentDay)
          )
        );

      // Combine questions with user progress
      const questionsWithProgress = todaysQuestions.map(question => {
        const progress = userProgress.find(p => p.questionId === question.id);
        return {
          ...question,
          isAnswered: !!progress,
          selectedAnswer: progress?.selectedAnswer || null,
          isCorrect: progress?.isCorrect || null,
          timeSpent: progress?.timeSpent || 0
        };
      });

      res.json({
        success: true,
        data: {
          dayNumber: currentDay,
          totalDays,
          isCompleted: false,
          questions: questionsWithProgress,
          totalQuestions: questionsWithProgress.length,
          answeredQuestions: userProgress.length,
          correctAnswers: userProgress.filter(p => p.isCorrect).length
        }
      });

    } catch (error) {
      console.error('Daily questions error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch daily questions' });
    }
  });

  // Submit answer for a daily question
  app.post('/api/daily-questions/answer', requireAuth, async (req, res) => {
    try {
      const { userId, questionId, selectedAnswer, timeSpent } = req.body;

      // Get question details
      const question = await db
        .select()
        .from(dailyQuestions)
        .where(eq(dailyQuestions.id, questionId))
        .limit(1);

      if (question.length === 0) {
        return res.status(404).json({ success: false, error: 'Question not found' });
      }

      const isCorrect = selectedAnswer === question[0].correctAnswer;

      // Check if user already answered this question
      const existingProgress = await db
        .select()
        .from(dailyQuestionProgress)
        .where(
          and(
            eq(dailyQuestionProgress.userId, userId),
            eq(dailyQuestionProgress.questionId, questionId)
          )
        )
        .limit(1);

      if (existingProgress.length > 0) {
        return res.status(400).json({ success: false, error: 'Question already answered' });
      }

      // Save user's answer
      await db.insert(dailyQuestionProgress).values({
        userId,
        questionId,
        dayNumber: question[0].dayNumber,
        selectedAnswer,
        isCorrect,
        timeSpent: timeSpent || 0
      });

      // Update daily progress summary
      const existingSummary = await db
        .select()
        .from(dailyProgressSummary)
        .where(
          and(
            eq(dailyProgressSummary.userId, userId),
            eq(dailyProgressSummary.dayNumber, question[0].dayNumber)
          )
        )
        .limit(1);

      if (existingSummary.length > 0) {
        // Update existing summary
        const newCorrectAnswers = existingSummary[0].correctAnswers + (isCorrect ? 1 : 0);
        const newTotalTime = existingSummary[0].totalTime + (timeSpent || 0);
        
        await db
          .update(dailyProgressSummary)
          .set({
            correctAnswers: newCorrectAnswers,
            totalTime: newTotalTime,
            completedAt: newCorrectAnswers === 7 ? new Date() : null,
            updatedAt: new Date()
          })
          .where(eq(dailyProgressSummary.id, existingSummary[0].id));
      } else {
        // Create new summary
        await db.insert(dailyProgressSummary).values({
          userId,
          dayNumber: question[0].dayNumber,
          totalQuestions: 7,
          correctAnswers: isCorrect ? 1 : 0,
          totalTime: timeSpent || 0,
          completedAt: null // Will be set when all 7 questions are completed
        });
      }

      res.json({
        success: true,
        data: {
          isCorrect,
          correctAnswer: question[0].correctAnswer,
          explanation: question[0].explanation
        }
      });

    } catch (error) {
      console.error('Answer submission error:', error);
      res.status(500).json({ success: false, error: 'Failed to submit answer' });
    }
  });

  // Get user's daily progress statistics (for progress visualization)
  app.get('/api/daily-questions/progress/:userId', requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;
      const { limit = 30 } = req.query; // Default to last 30 days

      // Get recent daily summaries
      const recentProgress = await db
        .select()
        .from(dailyProgressSummary)
        .where(eq(dailyProgressSummary.userId, userId))
        .orderBy(desc(dailyProgressSummary.dayNumber))
        .limit(Number(limit));

      // Calculate overall statistics
      const totalDays = recentProgress.length;
      const completedDays = recentProgress.filter(day => day.completedAt).length;
      const totalCorrectAnswers = recentProgress.reduce((sum, day) => sum + day.correctAnswers, 0);
      const totalQuestions = recentProgress.reduce((sum, day) => sum + day.totalQuestions, 0);

      // Calculate current streak
      let currentStreak = 0;
      for (let i = 0; i < recentProgress.length; i++) {
        if (recentProgress[i].completedAt) {
          currentStreak++;
        } else {
          break;
        }
      }

      // Calculate accuracy by subject (requires joining with questions)
      const subjectStats = await db
        .select({
          subjectName: subjects.name,
          correctAnswers: sql<number>`COUNT(CASE WHEN ${dailyQuestionProgress.isCorrect} = true THEN 1 END)`,
          totalAnswers: sql<number>`COUNT(${dailyQuestionProgress.id})`
        })
        .from(dailyQuestionProgress)
        .leftJoin(dailyQuestions, eq(dailyQuestionProgress.questionId, dailyQuestions.id))
        .leftJoin(subjects, eq(dailyQuestions.subjectId, subjects.id))
        .where(eq(dailyQuestionProgress.userId, userId))
        .groupBy(subjects.name);

      res.json({
        success: true,
        data: {
          overview: {
            totalDays,
            completedDays,
            currentStreak,
            totalCorrectAnswers,
            totalQuestions,
            accuracy: totalQuestions > 0 ? Math.round((totalCorrectAnswers / totalQuestions) * 100) : 0
          },
          recentProgress: recentProgress.map(day => ({
            dayNumber: day.dayNumber,
            correctAnswers: day.correctAnswers,
            totalQuestions: day.totalQuestions,
            accuracy: Math.round((day.correctAnswers / day.totalQuestions) * 100),
            isCompleted: !!day.completedAt,
            completedAt: day.completedAt,
            totalTime: day.totalTime
          })),
          subjectStats: subjectStats.map(stat => ({
            subject: stat.subjectName,
            accuracy: stat.totalAnswers > 0 ? Math.round((stat.correctAnswers / stat.totalAnswers) * 100) : 0,
            totalAnswers: stat.totalAnswers,
            correctAnswers: stat.correctAnswers
          }))
        }
      });

    } catch (error) {
      console.error('Progress statistics error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch progress statistics' });
    }
  });

  // Get comprehensive user profile with learning statistics
  app.get('/api/users/:userId/profile-stats', requireAuth, async (req, res) => {
    try {
      const { userId } = req.params;

      // Get user profile with country information
      const userProfile = await db
        .select({
          id: profiles.id,
          userId: profiles.userId,
          name: profiles.name,
          email: profiles.email,
          age: profiles.age,
          grade: profiles.grade,
          educationLevel: profiles.educationLevel,
          country: profiles.country,
          gradeSystem: profiles.gradeSystem,
          avatarUrl: profiles.avatarUrl,
          role: profiles.role,
          subscriptionTier: profiles.subscriptionTier,
          legacyPlan: profiles.legacyPlan,
          planExpiry: profiles.planExpiry,
          createdAt: profiles.createdAt,
          lastSeen: profiles.lastSeen,
          countryName: countries.name,
          countryCode: countries.code
        })
        .from(profiles)
        .leftJoin(countries, eq(profiles.countryId, countries.id))
        .where(eq(profiles.userId, userId))
        .limit(1);

      if (userProfile.length === 0) {
        return res.status(404).json({ success: false, error: 'User profile not found' });
      }

      const profile = userProfile[0];

      // Get learning statistics
      const learningStats = await db
        .select({
          lessonId: subjectProgress.lessonId,
          status: subjectProgress.status,
          score: subjectProgress.score,
          timeSpent: subjectProgress.timeSpent,
          completedAt: subjectProgress.completedAt,
          subjectName: subjects.name
        })
        .from(subjectProgress)
        .innerJoin(subjectLessons, eq(subjectProgress.lessonId, subjectLessons.id))
        .innerJoin(subjectChapters, eq(subjectLessons.chapterId, subjectChapters.id))
        .innerJoin(subjects, eq(subjectChapters.subjectId, subjects.id))
        .where(eq(subjectProgress.userId, userId));

      // Calculate statistics
      const totalLessons = learningStats.length;
      const completedLessons = learningStats.filter(lesson => lesson.status === 'completed').length;
      const inProgressLessons = learningStats.filter(lesson => lesson.status === 'in_progress').length;
      const totalTimeSpent = learningStats.reduce((total, lesson) => total + (lesson.timeSpent || 0), 0);
      const averageScore = learningStats.length > 0 
        ? learningStats.filter(lesson => lesson.score !== null)
            .reduce((total, lesson, _, arr) => total + (lesson.score || 0) / arr.length, 0)
        : 0;

      // Get daily questions statistics
      const dailyStats = await db
        .select({
          dayNumber: dailyProgressSummary.dayNumber,
          correctAnswers: dailyProgressSummary.correctAnswers,
          totalQuestions: dailyProgressSummary.totalQuestions,
          completedAt: dailyProgressSummary.completedAt
        })
        .from(dailyProgressSummary)
        .where(eq(dailyProgressSummary.userId, userId))
        .orderBy(desc(dailyProgressSummary.dayNumber));

      const totalDailyDays = dailyStats.length;
      const dailyStreak = calculateStreak(dailyStats);
      const totalDailyQuestions = dailyStats.reduce((total, day) => total + day.totalQuestions, 0);
      const totalCorrectDaily = dailyStats.reduce((total, day) => total + day.correctAnswers, 0);
      const dailyAccuracy = totalDailyQuestions > 0 ? (totalCorrectDaily / totalDailyQuestions) * 100 : 0;

      // Get subject breakdown
      const subjectBreakdown = learningStats.reduce((acc, lesson) => {
        const subject = lesson.subjectName;
        if (!acc[subject]) {
          acc[subject] = { total: 0, completed: 0, timeSpent: 0 };
        }
        acc[subject].total++;
        if (lesson.status === 'completed') acc[subject].completed++;
        acc[subject].timeSpent += lesson.timeSpent || 0;
        return acc;
      }, {} as Record<string, { total: number; completed: number; timeSpent: number }>);

      res.json({
        success: true,
        data: {
          profile: {
            ...profile,
            joinedDaysAgo: Math.floor((Date.now() - new Date(profile.createdAt).getTime()) / (1000 * 60 * 60 * 24))
          },
          learningStats: {
            totalLessons,
            completedLessons,
            inProgressLessons,
            completionRate: totalLessons > 0 ? (completedLessons / totalLessons) * 100 : 0,
            totalTimeSpent,
            averageScore: Math.round(averageScore),
            subjectBreakdown
          },
          dailyStats: {
            totalDays: totalDailyDays,
            currentStreak: dailyStreak,
            totalQuestions: totalDailyQuestions,
            correctAnswers: totalCorrectDaily,
            accuracy: Math.round(dailyAccuracy)
          }
        }
      });

    } catch (error) {
      console.error('Profile stats error:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch profile statistics' });
    }
  });

  // Helper function to calculate streak
  function calculateStreak(dailyStats: any[]): number {
    if (dailyStats.length === 0) return 0;
    
    let streak = 0;
    const today = new Date();
    
    for (let i = 0; i < dailyStats.length; i++) {
      const statDate = new Date(dailyStats[i].completedAt);
      const daysDiff = Math.floor((today.getTime() - statDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysDiff === i && dailyStats[i].completedAt) {
        streak++;
      } else {
        break;
      }
    }
    
    return streak;
  }



  // ======================= PRODUCT LIKE/FOLLOW ENDPOINTS =======================

  // Toggle product like (heart/like functionality)
  app.post('/api/products/:productId/like', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { productId } = req.params;
      const userId = req.user!.id;

      const result = await storage.toggleProductLike(productId, userId);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error toggling product like:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle product like'
      });
    }
  });


  // Get featured/trending products for landing page
  app.get('/api/products/featured', async (req, res) => {
    try {
      const limit = parseInt(req.query.limit as string) || 8;
      
      const result = await sql`
        SELECT 
          p.id,
          p.seller_id as "sellerId",
          p.seller_role as "sellerRole",
          p.name,
          p.description,
          p.type,
          p.price,
          p.currency,
          p.category,
          COALESCE(p.images[1], p.file_url) as "imageUrl"
        FROM products p
        WHERE p.type IS NOT NULL
        ORDER BY p.created_at DESC
        LIMIT ${limit}
      `;
      
      res.json({ 
        success: true, 
        products: result 
      });
    } catch (error) {
      console.error('Error fetching featured products:', error);
      res.status(500).json({ 
        success: false, 
        error: "Failed to fetch featured products" 
      });
    }
  });
  // Get product likes with user information
  app.get('/api/products/:productId/likes', async (req, res) => {
    try {
      const { productId } = req.params;
      // Validate pagination
      const limit = Math.min(Math.max(parseInt(req.query.limit as string) || 50, 1), 100);
      const offset = Math.max(parseInt(req.query.offset as string) || 0, 0);

      const likes = await storage.getProductLikes(productId, { limit, offset });
      
      res.json({
        success: true,
        data: likes
      });
    } catch (error) {
      console.error('Error fetching product likes:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch product likes'
      });
    }
  });

  // Get product like stats (count, whether current user liked, recent likers)
  app.get('/api/products/:productId/like-stats', optionalAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { productId } = req.params;
      const viewerUserId = req.user?.id; // Optional - user may not be authenticated

      const stats = await storage.getProductLikeStats(productId, viewerUserId);
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error('Error fetching product like stats:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch product like stats'
      });
    }
  });

  // Get user's liked products
  app.get('/api/users/:userId/liked-products', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { userId } = req.params;
      const currentUserId = req.user!.id;
      const currentUserTextId = req.user!.userId;

      // Users can only see their own liked products (check both UUID and text ID)
      if (userId !== currentUserId && userId !== currentUserTextId) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      // Validate pagination
      const limit = Math.min(Math.max(parseInt(req.query.limit as string) || 50, 1), 100);
      const offset = Math.max(parseInt(req.query.offset as string) || 0, 0);

      // Use the UUID for storage operations
      const likedProducts = await storage.getUserLikedProducts(currentUserId, { limit, offset });
      
      res.json({
        success: true,
        data: likedProducts
      });
    } catch (error) {
      console.error('Error fetching user liked products:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch liked products'
      });
    }
  });

  // Toggle seller follow (follow the seller/creator)
  app.post('/api/sellers/:sellerId/follow', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { sellerId } = req.params;
      const followerId = req.user!.id;
      const followerTextId = req.user!.userId;

      // Users cannot follow themselves (check both UUID and text ID)
      if (sellerId === followerId || sellerId === followerTextId) {
        return res.status(400).json({
          success: false,
          error: 'Cannot follow yourself'
        });
      }

      // Use UUID for storage operations
      const result = await storage.toggleProductFollow(sellerId, followerId);
      
      res.json({
        success: true,
        data: result
      });
    } catch (error) {
      console.error('Error toggling seller follow:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to toggle seller follow'
      });
    }
  });

  // Get seller followers with user information
  app.get('/api/sellers/:sellerId/followers', async (req, res) => {
    try {
      const { sellerId } = req.params;
      // Validate pagination
      const limit = Math.min(Math.max(parseInt(req.query.limit as string) || 50, 1), 100);
      const offset = Math.max(parseInt(req.query.offset as string) || 0, 0);

      const followers = await storage.getProductFollows(sellerId, { limit, offset });
      
      res.json({
        success: true,
        data: followers
      });
    } catch (error) {
      console.error('Error fetching seller followers:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch seller followers'
      });
    }
  });

  // Get seller follow stats (count, whether current user follows, recent followers)
  app.get('/api/sellers/:sellerId/follow-stats', optionalAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { sellerId } = req.params;
      const viewerUserId = req.user?.id; // Optional - user may not be authenticated

      const stats = await storage.getSellerFollowStats(sellerId, viewerUserId);
      
      res.json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error('Error fetching seller follow stats:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch seller follow stats'
      });
    }
  });

  // Get user's followed sellers
  app.get('/api/users/:userId/followed-sellers', requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { userId } = req.params;
      const currentUserId = req.user!.id;
      const currentUserTextId = req.user!.userId;

      // Users can only see their own followed sellers (check both UUID and text ID)
      if (userId !== currentUserId && userId !== currentUserTextId) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      // Validate pagination
      const limit = Math.min(Math.max(parseInt(req.query.limit as string) || 50, 1), 100);
      const offset = Math.max(parseInt(req.query.offset as string) || 0, 0);

      // Use the UUID for storage operations
      const followedSellers = await storage.getUserFollowedSellers(currentUserId, { limit, offset });
      
      res.json({
        success: true,
        data: followedSellers
      });
    } catch (error) {
      console.error('Error fetching user followed sellers:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch followed sellers'
      });
    }
  });

  // ===== HELP CHAT API ENDPOINTS =====

  // Get help chat messages for a guest
  app.get('/api/help-chat/messages/:guestId', async (req, res) => {
    try {
      const { guestId } = req.params;
      
      const messages = await db
        .select({
          id: helpChatMessages.id,
          guestId: helpChatMessages.guestId,
          message: helpChatMessages.message,
          sender: helpChatMessages.sender,
          createdAt: helpChatMessages.createdAt,
          adminName: profiles.name,
          adminAvatar: profiles.avatarUrl
        })
        .from(helpChatMessages)
        .leftJoin(users, eq(helpChatMessages.receiverId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(helpChatMessages.guestId, guestId))
        .orderBy(asc(helpChatMessages.createdAt));

      const formattedMessages = messages.map(msg => ({
        id: msg.id.toString(),
        message: msg.message,
        sender: msg.sender,
        timestamp: msg.createdAt.toISOString(),
        adminName: msg.adminName,
        adminAvatar: msg.adminAvatar
      }));

      res.json({
        success: true,
        messages: formattedMessages
      });
    } catch (error) {
      console.error('Error fetching help chat messages:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch messages'
      });
    }
  });

  // Send help chat message (HTTP backup for WebSocket)
  app.post('/api/help-chat/send', async (req, res) => {
    try {
      const { guestId, message, sender } = req.body;

      if (!guestId || !message || !sender) {
        return res.status(400).json({
          success: false,
          error: 'Missing required fields: guestId, message, sender'
        });
      }

      // Validate message length
      if (message.length > 2000) {
        return res.status(400).json({
          success: false,
          error: 'Message too long. Maximum 2000 characters.'
        });
      }

      // Save message to database
      const [newMessage] = await db.insert(helpChatMessages).values({
        guestId: guestId,
        receiverId: null, // Will be set if from admin
        message: message,
        sender: sender,
      }).returning({
        id: helpChatMessages.id,
        guestId: helpChatMessages.guestId,
        message: helpChatMessages.message,
        sender: helpChatMessages.sender,
        createdAt: helpChatMessages.createdAt
      });

      res.json({
        success: true,
        message: 'Message sent successfully',
        data: {
          id: newMessage.id.toString(),
          guestId: newMessage.guestId,
          message: newMessage.message,
          sender: newMessage.sender,
          timestamp: newMessage.createdAt.toISOString()
        }
      });
    } catch (error) {
      console.error('Error sending help chat message:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to send message'
      });
    }
  });

  // Get all help chat conversations for admin/moderator
  app.get('/api/admin/help-chat/conversations', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      // Get distinct guest IDs with their latest message and message count
      // Using a more explicit approach to avoid subquery scoping issues
      const conversations = await db
        .select({
          guestId: helpChatMessages.guestId,
          lastMessage: sql<string>`(
            SELECT message 
            FROM help_chat_messages hcm2 
            WHERE hcm2.guest_id = help_chat_messages.guest_id 
            ORDER BY hcm2.created_at DESC 
            LIMIT 1
          )`,
          lastMessageTime: sql<Date>`(
            SELECT created_at 
            FROM help_chat_messages hcm2 
            WHERE hcm2.guest_id = help_chat_messages.guest_id 
            ORDER BY hcm2.created_at DESC 
            LIMIT 1
          )`,
          messageCount: sql<number>`COUNT(*)`,
          unreadCount: sql<number>`SUM(CASE WHEN sender = 'visitor' THEN 1 ELSE 0 END)`
        })
        .from(helpChatMessages)
        .groupBy(helpChatMessages.guestId)
        .orderBy(sql`MAX(${helpChatMessages.createdAt}) DESC`);

      // Double-check that each conversation has the correct lastMessage by querying individually
      const enrichedConversations = await Promise.all(
        conversations.map(async (conv) => {
          const latestMessage = await db
            .select({
              message: helpChatMessages.message,
              createdAt: helpChatMessages.createdAt
            })
            .from(helpChatMessages)
            .where(eq(helpChatMessages.guestId, conv.guestId))
            .orderBy(desc(helpChatMessages.createdAt))
            .limit(1);

          return {
            guestId: conv.guestId,
            lastMessage: latestMessage[0]?.message || conv.lastMessage,
            lastMessageTime: latestMessage[0]?.createdAt ? latestMessage[0].createdAt.toISOString() : 
                            (conv.lastMessageTime ? new Date(conv.lastMessageTime).toISOString() : null),
            messageCount: Number(conv.messageCount),
            unreadCount: Number(conv.unreadCount),
            isActive: true // Could add logic to determine if guest is currently online
          };
        })
      );

      res.json({
        success: true,
        conversations: enrichedConversations
      });
    } catch (error) {
      console.error('Error fetching help chat conversations:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch conversations'
      });
    }
  });

  // Get help chat conversation details
  app.get('/api/admin/help-chat/conversation/:guestId', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      const { guestId } = req.params;
      
      const messages = await db
        .select({
          id: helpChatMessages.id,
          guestId: helpChatMessages.guestId,
          message: helpChatMessages.message,
          sender: helpChatMessages.sender,
          createdAt: helpChatMessages.createdAt,
          adminName: profiles.name,
          adminAvatar: profiles.avatarUrl
        })
        .from(helpChatMessages)
        .leftJoin(users, eq(helpChatMessages.receiverId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .where(eq(helpChatMessages.guestId, guestId))
        .orderBy(asc(helpChatMessages.createdAt));

      const formattedMessages = messages.map(msg => ({
        id: msg.id.toString(),
        message: msg.message,
        sender: msg.sender,
        timestamp: msg.createdAt.toISOString(),
        adminName: msg.adminName,
        adminAvatar: msg.adminAvatar
      }));

      res.json({
        success: true,
        guestId,
        messages: formattedMessages
      });
    } catch (error) {
      console.error('Error fetching help chat conversation:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch conversation'
      });
    }
  });

  // Export help chat history 
  app.get('/api/admin/help-chat/export', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      const { format = 'csv', guestId } = req.query;
      
      let query = db
        .select({
          id: helpChatMessages.id,
          guestId: helpChatMessages.guestId,
          message: helpChatMessages.message,
          sender: helpChatMessages.sender,
          createdAt: helpChatMessages.createdAt,
          adminName: profiles.name
        })
        .from(helpChatMessages)
        .leftJoin(users, eq(helpChatMessages.receiverId, users.id))
        .leftJoin(profiles, eq(users.id, profiles.userId))
        .orderBy(asc(helpChatMessages.createdAt));

      // Filter by guest ID if provided
      if (guestId) {
        query = query.where(eq(helpChatMessages.guestId, guestId as string));
      }

      const messages = await query;

      if (format === 'csv') {
        const csvHeader = 'Guest ID,Sender,Message,Admin Name,Timestamp\n';
        const csvData = messages.map(msg => 
          `"${msg.guestId}","${msg.sender}","${msg.message.replace(/"/g, '""')}","${msg.adminName || ''}","${msg.createdAt.toISOString()}"`
        ).join('\n');
        
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="help-chat-export-${Date.now()}.csv"`);
        res.send(csvHeader + csvData);
      } else if (format === 'txt') {
        const txtData = messages.map(msg => 
          `[${msg.createdAt.toISOString()}] ${msg.sender === 'visitor' ? `Guest ${msg.guestId}` : `Admin ${msg.adminName || 'Unknown'}`}: ${msg.message}`
        ).join('\n\n');
        
        res.setHeader('Content-Type', 'text/plain');
        res.setHeader('Content-Disposition', `attachment; filename="help-chat-export-${Date.now()}.txt"`);
        res.send(txtData);
      } else if (format === 'json') {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="help-chat-export-${Date.now()}.json"`);
        res.json({
          exportDate: new Date().toISOString(),
          totalMessages: messages.length,
          messages: messages.map(msg => ({
            id: msg.id.toString(),
            guestId: msg.guestId,
            message: msg.message,
            sender: msg.sender,
            adminName: msg.adminName,
            timestamp: msg.createdAt.toISOString()
          }))
        });
      } else if (format === 'pdf') {
        const PDFDocument = require('pdfkit');
        const doc = new PDFDocument();
        
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="help-chat-export-${Date.now()}.pdf"`);
        
        doc.pipe(res);
        
        // PDF Header
        doc.fontSize(16).text('Help Chat History Export', { align: 'center' });
        doc.fontSize(12).text(`Export Date: ${new Date().toLocaleString()}`, { align: 'center' });
        doc.fontSize(10).text(`Total Messages: ${messages.length}`, { align: 'center' });
        
        if (guestId) {
          doc.text(`Guest ID: ${guestId}`, { align: 'center' });
        }
        
        doc.moveDown(2);
        
        // Messages
        messages.forEach((msg, index) => {
          const timestamp = new Date(msg.createdAt).toLocaleString();
          const senderName = msg.sender === 'visitor' ? `Guest ${msg.guestId.slice(-8)}` : (msg.adminName || 'Admin');
          
          if (doc.y > 700) { // Add new page if needed
            doc.addPage();
          }
          
          // Message header with bubble-style formatting
          doc.fontSize(10)
             .fillColor('#666666')
             .text(`${timestamp} - ${senderName}`, { align: msg.sender === 'admin' ? 'right' : 'left' });
          
          // Message content with styling similar to chat bubbles
          doc.fontSize(11)
             .fillColor(msg.sender === 'admin' ? '#2563eb' : '#374151')
             .text(msg.message, { 
               align: msg.sender === 'admin' ? 'right' : 'left',
               indent: msg.sender === 'admin' ? 50 : 0,
               width: 400
             });
          
          doc.moveDown(0.5);
          
          // Add separator line
          if (index < messages.length - 1) {
            doc.strokeColor('#e5e7eb')
               .lineWidth(0.5)
               .moveTo(50, doc.y)
               .lineTo(550, doc.y)
               .stroke();
            doc.moveDown(0.5);
          }
        });
        
        doc.end();
      } else {
        res.status(400).json({
          success: false,
          error: 'Invalid format. Supported formats: csv, txt, json, pdf'
        });
      }
    } catch (error) {
      console.error('Error exporting help chat data:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to export chat data'
      });
    }
  });

  // =======================
  // SUPPORT SYSTEM API ROUTES
  // =======================

  // Support Agents Management
  // =========================
  
  // Get all support agents (admin/moderator only)
  app.get('/api/admin/support-agents', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      // Add cache-control headers to prevent browser caching
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      
      // Direct database query to access existing support agents (bypassing storage interface issues)
      const agents = await db.select().from(supportAgents).orderBy(asc(supportAgents.sortOrder), asc(supportAgents.name));
      console.log('ðŸ“‹ Direct DB query - Support agents found:', agents.length);
      res.json({ success: true, data: agents });
    } catch (error) {
      console.error('Error fetching support agents:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch support agents' });
    }
  });

  // Get active support agents for public display (visitor chat)
  app.get('/api/support-agents/active', async (req, res) => {
    try {
      // Add cache-control headers to prevent browser caching
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
      res.setHeader('Pragma', 'no-cache');
      res.setHeader('Expires', '0');
      
      const agents = await storage.getActiveSupportAgents();
      // Only return minimal info needed for visitor display
      const publicAgents = agents.map(agent => ({
        id: agent.id,
        name: agent.name,
        avatarUrl: agent.avatarUrl,
        role: agent.role
      }));
      res.json({ success: true, data: publicAgents });
    } catch (error) {
      console.error('Error fetching active support agents:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch active support agents' });
    }
  });

  // Get specific support agent
  app.get('/api/admin/support-agents/:id', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid agent ID' });
      }
      
      const agent = await storage.getSupportAgentById(id);
      
      if (!agent) {
        return res.status(404).json({ success: false, error: 'Support agent not found' });
      }
      
      res.json({ success: true, data: agent });
    } catch (error) {
      console.error('Error fetching support agent:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch support agent' });
    }
  });

  // Create new support agent
  app.post('/api/admin/support-agents', requireAuth, requireAdmin, async (req, res) => {
    try {
      const validationResult = insertSupportAgentSchema.safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.errors 
        });
      }

      const newAgent = await storage.createSupportAgent(validationResult.data);

      res.status(201).json({ success: true, data: newAgent, message: 'Support agent created successfully' });
    } catch (error) {
      console.error('Error creating support agent:', error);
      res.status(500).json({ success: false, error: 'Failed to create support agent' });
    }
  });

  // Update support agent
  app.put('/api/admin/support-agents/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid agent ID' });
      }
      
      const validationResult = insertSupportAgentSchema.partial().safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.errors 
        });
      }

      const updatedAgent = await storage.updateSupportAgent(id, validationResult.data);
      
      if (!updatedAgent) {
        return res.status(404).json({ success: false, error: 'Support agent not found' });
      }

      res.json({ success: true, data: updatedAgent, message: 'Support agent updated successfully' });
    } catch (error) {
      console.error('Error updating support agent:', error);
      res.status(500).json({ success: false, error: 'Failed to update support agent' });
    }
  });

  // Delete support agent
  app.delete('/api/admin/support-agents/:id', requireAuth, requireAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid agent ID' });
      }
      
      const deleted = await storage.deleteSupportAgent(id);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Support agent not found' });
      }

      res.json({ success: true, message: 'Support agent deleted successfully' });
    } catch (error) {
      console.error('Error deleting support agent:', error);
      res.status(500).json({ success: false, error: 'Failed to delete support agent' });
    }
  });

  // Help Chat Settings Management
  // =============================
  
  // Get all help chat settings
  app.get('/api/admin/help-chat-settings', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      const settings = await storage.getHelpChatSettings();
      res.json({ success: true, data: settings });
    } catch (error) {
      console.error('Error fetching help chat settings:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch help chat settings' });
    }
  });

  // Get specific help chat setting
  app.get('/api/admin/help-chat-settings/:key', requireAuth, requireAdminOrModerator, async (req, res) => {
    try {
      const { key } = req.params;
      const setting = await storage.getHelpChatSetting(key);
      
      if (!setting) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }
      
      res.json({ success: true, data: setting });
    } catch (error) {
      console.error('Error fetching help chat setting:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch help chat setting' });
    }
  });

  // Create or update help chat setting
  app.post('/api/admin/help-chat-settings', requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      // Convert text userId to UUID for updatedBy field
      let updatedByUuid = null;
      if (req.user?.userId) {
        updatedByUuid = await getUserUuidByTextId(req.user.userId);
      }

      const validationResult = insertHelpChatSettingSchema.safeParse({
        ...req.body,
        updatedBy: updatedByUuid
      });
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.errors 
        });
      }

      const { settingKey, settingValue, description, updatedBy } = validationResult.data;
      
      // Check if setting already exists
      const existingSetting = await storage.getHelpChatSetting(settingKey);
      
      let setting;
      if (existingSetting) {
        // Update existing setting
        setting = await storage.updateHelpChatSetting(settingKey, settingValue, updatedBy || undefined);
      } else {
        // Create new setting
        setting = await storage.createHelpChatSetting(validationResult.data);
      }

      res.status(existingSetting ? 200 : 201).json({ 
        success: true, 
        data: setting, 
        message: `Help chat setting ${existingSetting ? 'updated' : 'created'} successfully` 
      });
    } catch (error) {
      console.error('Error saving help chat setting:', error);
      res.status(500).json({ success: false, error: 'Failed to save help chat setting' });
    }
  });

  // Update help chat setting
  app.put('/api/admin/help-chat-settings/:key', requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { key } = req.params;
      const { settingValue } = req.body;
      
      if (!settingValue) {
        return res.status(400).json({ success: false, error: 'Setting value is required' });
      }

      // Convert text userId to UUID for updatedBy field
      let updatedByUuid = undefined;
      if (req.user?.userId) {
        updatedByUuid = await getUserUuidByTextId(req.user.userId);
      }

      const updatedSetting = await storage.updateHelpChatSetting(key, settingValue, updatedByUuid);
      
      if (!updatedSetting) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }

      res.json({ success: true, data: updatedSetting, message: 'Help chat setting updated successfully' });
    } catch (error) {
      console.error('Error updating help chat setting:', error);
      res.status(500).json({ success: false, error: 'Failed to update help chat setting' });
    }
  });

  // Delete help chat setting
  app.delete('/api/admin/help-chat-settings/:key', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { key } = req.params;
      const deleted = await storage.deleteHelpChatSetting(key);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Setting not found' });
      }

      res.json({ success: true, message: 'Help chat setting deleted successfully' });
    } catch (error) {
      console.error('Error deleting help chat setting:', error);
      res.status(500).json({ success: false, error: 'Failed to delete help chat setting' });
    }
  });

  // Quick Responses Management
  // ==========================
  
  // Get all quick responses
  app.get('/api/admin/quick-responses', requireAuth, requireSupportStaff, async (req, res) => {
    try {
      const { category } = req.query;
      
      // Fetch quick responses with creator information
      const responsesWithCreator = await db
        .select({
          id: quickResponses.id,
          title: quickResponses.title,
          content: quickResponses.content,
          shortcut: quickResponses.shortcut,
          category: quickResponses.category,
          isActive: quickResponses.isActive,
          sortOrder: quickResponses.sortOrder,
          createdBy: quickResponses.createdBy,
          createdAt: quickResponses.createdAt,
          updatedAt: quickResponses.updatedAt,
          creatorRole: users.role,
          creatorName: users.name
        })
        .from(quickResponses)
        .leftJoin(users, eq(quickResponses.createdBy, users.id))
        .where(category ? eq(quickResponses.category, category as string) : sql`true`)
        .orderBy(
          asc(quickResponses.category), 
          asc(quickResponses.sortOrder), 
          asc(quickResponses.title)
        );
      
      res.json({ success: true, data: responsesWithCreator });
    } catch (error) {
      console.error('Error fetching quick responses:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch quick responses' });
    }
  });

  // Get specific quick response
  app.get('/api/admin/quick-responses/:id', requireAuth, requireSupportStaff, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid quick response ID' });
      }
      
      const response = await storage.getQuickResponseById(id);
      
      if (!response) {
        return res.status(404).json({ success: false, error: 'Quick response not found' });
      }
      
      res.json({ success: true, data: response });
    } catch (error) {
      console.error('Error fetching quick response:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch quick response' });
    }
  });

  // Create new quick response
  app.post('/api/admin/quick-responses', requireAuth, requireSupportStaff, async (req: AuthenticatedRequest, res) => {
    console.log('ðŸ” QuickResponse POST body:', JSON.stringify(req.body, null, 2));
    
    try {
      // Normalize request body to match backend schema
      const shortcut = req.body.shortcut ?? req.body.trigger;
      const title = req.body.title ?? shortcut;
      const sortOrder = typeof req.body.sortOrder === 'string' ? parseInt(req.body.sortOrder, 10) : (req.body.sortOrder ?? 0);
      const category = String(req.body.category || 'general').toLowerCase();
      
      const dataToValidate = {
        title,
        shortcut,
        content: req.body.content,
        category,
        isActive: req.body.isActive ?? true,
        sortOrder,
        createdBy: req.user.id
      };
      
      console.log('ðŸ” Normalized data for validation:', JSON.stringify(dataToValidate, null, 2));
      
      const validationResult = insertQuickResponseSchema.safeParse(dataToValidate);
      
      if (!validationResult.success) {
        console.log('âŒ Validation failed:', JSON.stringify(validationResult.error.flatten(), null, 2));
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          issues: validationResult.error.flatten()
        });
      }

      const newResponse = await storage.createQuickResponse(validationResult.data);

      res.status(201).json({ success: true, data: newResponse, message: 'Quick response created successfully' });
    } catch (error) {
      console.error('Error creating quick response:', error);
      res.status(500).json({ success: false, error: 'Failed to create quick response' });
    }
  });

  // Update quick response
  app.put('/api/admin/quick-responses/:id', requireAuth, requireSupportStaff, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid quick response ID' });
      }
      
      const validationResult = insertQuickResponseSchema.partial().safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.errors 
        });
      }

      const updatedResponse = await storage.updateQuickResponse(id, validationResult.data);
      
      if (!updatedResponse) {
        return res.status(404).json({ success: false, error: 'Quick response not found' });
      }

      res.json({ success: true, data: updatedResponse, message: 'Quick response updated successfully' });
    } catch (error) {
      console.error('Error updating quick response:', error);
      res.status(500).json({ success: false, error: 'Failed to update quick response' });
    }
  });

  // Delete quick response
  app.delete('/api/admin/quick-responses/:id', requireAuth, requireSupportStaff, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ success: false, error: 'Invalid quick response ID' });
      }
      
      const deleted = await storage.deleteQuickResponse(id);

      if (!deleted) {
        return res.status(404).json({ success: false, error: 'Quick response not found' });
      }

      res.json({ success: true, message: 'Quick response deleted successfully' });
    } catch (error) {
      console.error('Error deleting quick response:', error);
      res.status(500).json({ success: false, error: 'Failed to delete quick response' });
    }
  });

  // Public Quick Responses (for messaging interface)
  // =================================================
  
  // Get active quick responses for all authenticated users (for messaging interface)
  app.get('/api/quick-responses/active', requireAuth, async (req, res) => {
    try {
      const { category } = req.query;
      const responses = await storage.getActiveQuickResponses();
      
      // Filter by category if provided
      const filteredResponses = category && category !== 'all' 
        ? responses.filter(response => response.category === category)
        : responses;
      
      res.json({ success: true, data: filteredResponses });
    } catch (error) {
      console.error('Error fetching active quick responses:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch quick responses' });
    }
  });

  // Support Chat Sessions Management
  // ================================
  
  // Get all support chat sessions (for admin dashboard)
  app.get('/api/admin/support-chat-sessions', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { activeOnly } = req.query;
      const sessions = activeOnly === 'true' 
        ? await storage.getActiveSessions()
        : await storage.getAllSupportChatSessions();
      
      res.json({ success: true, data: sessions });
    } catch (error) {
      console.error('Error fetching support chat sessions:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch support chat sessions' });
    }
  });

  // Get sessions by agent
  app.get('/api/admin/support-chat-sessions/agent/:agentId', requireAuth, requireAdmin, async (req, res) => {
    try {
      const agentId = parseInt(req.params.agentId);
      const { activeOnly } = req.query;
      
      const sessions = await storage.getSessionsByAgent(agentId, { 
        activeOnly: activeOnly === 'true' 
      });
      
      res.json({ success: true, data: sessions });
    } catch (error) {
      console.error('Error fetching sessions by agent:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch sessions by agent' });
    }
  });

  // Get specific support chat session
  app.get('/api/admin/support-chat-sessions/:guestId', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { guestId } = req.params;
      const session = await storage.getSupportChatSession(guestId);
      
      if (!session) {
        return res.status(404).json({ success: false, error: 'Support chat session not found' });
      }
      
      res.json({ success: true, data: session });
    } catch (error) {
      console.error('Error fetching support chat session:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch support chat session' });
    }
  });

  // Update support chat session (assign agent, admin takeover, etc.)
  app.put('/api/admin/support-chat-sessions/:guestId', requireAuth, requireAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const { guestId } = req.params;
      const updates = req.body;

      // If this is an admin takeover, set the admin user ID
      if (updates.adminTakenOver === true) {
        updates.adminUserId = req.user?.userId || null;
      }

      const updatedSession = await storage.updateSupportChatSession(guestId, updates);
      
      if (!updatedSession) {
        return res.status(404).json({ success: false, error: 'Support chat session not found' });
      }

      res.json({ success: true, data: updatedSession, message: 'Support chat session updated successfully' });
    } catch (error) {
      console.error('Error updating support chat session:', error);
      res.status(500).json({ success: false, error: 'Failed to update support chat session' });
    }
  });

  // Close support chat session
  app.post('/api/admin/support-chat-sessions/:guestId/close', requireAuth, requireAdmin, async (req, res) => {
    try {
      const { guestId } = req.params;
      const closedSession = await storage.closeSupportChatSession(guestId);
      
      if (!closedSession) {
        return res.status(404).json({ success: false, error: 'Support chat session not found' });
      }
      
      res.json({ success: true, data: closedSession, message: 'Support chat session closed successfully' });
    } catch (error) {
      console.error('Error closing support chat session:', error);
      res.status(500).json({ success: false, error: 'Failed to close support chat session' });
    }
  });

  // Get or create support chat session
  app.post('/api/support-chat-sessions', async (req, res) => {
    try {
      const { guestId } = req.body;
      
      if (!guestId) {
        return res.status(400).json({ success: false, error: 'Guest ID is required' });
      }
      
      const validationResult = insertSupportChatSessionSchema.partial().safeParse(req.body);
      
      if (!validationResult.success) {
        return res.status(400).json({ 
          success: false, 
          error: 'Validation failed',
          details: validationResult.error.errors 
        });
      }

      const session = await storage.getOrCreateSupportChatSession(guestId, validationResult.data);

      res.json({ success: true, data: session });
    } catch (error) {
      console.error('Error getting/creating support chat session:', error);
      res.status(500).json({ success: false, error: 'Failed to get or create support chat session' });
    }
  });

  // Course reviews endpoint for CourseDetail page
  app.get('/api/courses/:courseId/reviews', async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // Get reviews from the database (using courseReviews from schema)
      const reviewData = await db
        .select({
          id: courseReviews.id,
          userId: courseReviews.studentId,
          rating: courseReviews.rating,
          comment: courseReviews.review,
          title: sql`NULL`, // title column doesn't exist in this table
          createdAt: courseReviews.createdAt,
          userName: profiles.displayName,
          userAvatar: profiles.avatarUrl
        })
        .from(courseReviews)
        .leftJoin(profiles, eq(courseReviews.studentId, profiles.userId))
        .where(eq(courseReviews.courseId, courseId))
        .orderBy(desc(courseReviews.createdAt));

      // Map to expected format with isVerified check
      const reviews = reviewData.map(review => ({
        id: review.id,
        userId: review.userId,
        userName: review.userName || 'Anonymous',
        userAvatar: review.userAvatar || null,
        rating: review.rating,
        title: review.title || null,
        comment: review.comment,
        isVerified: true, // For now, assume all reviews are verified
        createdAt: review.createdAt
      }));

      res.json({ reviews });
    } catch (error) {
      console.error('Error fetching course reviews:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch course reviews' });
    }
  });


  // Check if user has purchased a course
  app.get('/api/courses/:courseId/purchase-status', async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // Get user from auth header (optional - returns false if not authenticated)
      let userId = null;
      const authHeader = req.headers.authorization;
      const sessionId = authHeader?.replace('Bearer ', '') || 
                       req.headers['x-session-id'] as string;

      if (sessionId) {
        const session = await db
          .select({ userId: userLoginSessions.userId })
          .from(userLoginSessions)
          .where(and(
            eq(userLoginSessions.sessionId, sessionId),
            gt(userLoginSessions.expiresAt, new Date())
          ))
          .limit(1);

        if (session.length > 0) {
          userId = session[0].userId;
        }
      }

      if (!userId) {
        return res.json({ hasPurchased: false });
      }

      // Check if user has purchased this course
      const purchase = await db
        .select()
        .from(coursePurchases)
        .where(and(
          eq(coursePurchases.userId, userId),
          eq(coursePurchases.courseId, courseId),
          eq(coursePurchases.paymentStatus, 'completed')
        ))
        .limit(1);

      res.json({ hasPurchased: purchase.length > 0 });
    } catch (error) {
      console.error('Error checking purchase status:', error);
      res.status(500).json({ error: 'Failed to check purchase status' });
    }
  });

  // Create Stripe payment intent for course purchase
  app.post('/api/courses/:courseId/create-payment-intent', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const { couponCode } = req.body;
      const user = (req as AuthenticatedRequest).user;
      
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      // Get course details
      const course = await db
        .select()
        .from(courses)
        .where(eq(courses.id, courseId))
        .limit(1);

      if (course.length === 0) {
        return res.status(404).json({ error: 'Course not found' });
      }

      const courseData = course[0];
      
      // Check if course is free
      if (!courseData.price || parseFloat(courseData.price) <= 0) {
        return res.status(400).json({ error: 'This course is free' });
      }

      const originalPrice = parseFloat(courseData.price);

      // Check if user already purchased this course
      const existingPurchase = await db
        .select()
        .from(coursePurchases)
        .where(and(
          eq(coursePurchases.userId, user.id),
          eq(coursePurchases.courseId, courseId),
          eq(coursePurchases.paymentStatus, 'completed')
        ))
        .limit(1);

      if (existingPurchase.length > 0) {
        return res.status(400).json({ error: 'You have already purchased this course' });
      }

      // Delete any existing pending purchases to avoid unique constraint violation
      await db
        .delete(coursePurchases)
        .where(and(
          eq(coursePurchases.userId, user.id),
          eq(coursePurchases.courseId, courseId),
          eq(coursePurchases.paymentStatus, 'pending')
        ));

      // Initialize discount variables
      let discountAmount = 0;
      let finalPrice = originalPrice;
      let validatedCoupon = null;

      // Validate and apply coupon if provided
      if (couponCode && typeof couponCode === 'string') {
        // Find coupon
        const [coupon] = await db
          .select()
          .from(coupons)
          .where(eq(coupons.code, couponCode.toUpperCase()))
          .limit(1);

        if (!coupon) {
          return res.status(404).json({ error: 'Invalid coupon code' });
        }

        // Validate coupon
        const now = new Date();

        if (!coupon.isActive) {
          return res.status(400).json({ error: 'This coupon is no longer active' });
        }

        if (coupon.startDate && new Date(coupon.startDate) > now) {
          return res.status(400).json({ error: 'This coupon is not yet valid' });
        }

        if (coupon.endDate && new Date(coupon.endDate) < now) {
          return res.status(400).json({ error: 'This coupon has expired' });
        }

        if (coupon.minOrderAmount && originalPrice < parseFloat(coupon.minOrderAmount)) {
          return res.status(400).json({ 
            error: `Minimum order amount of $${coupon.minOrderAmount} required` 
          });
        }

        if (coupon.totalUsageLimit && (coupon.usageCount ?? 0) >= coupon.totalUsageLimit) {
          return res.status(400).json({ error: 'This coupon has reached its usage limit' });
        }

        // Check per-user limit
        const [userUsageResult] = await db
          .select({ count: count() })
          .from(couponUsages)
          .where(
            and(
              eq(couponUsages.couponId, coupon.id),
              eq(couponUsages.userId, user.id)
            )
          );

        const userUsageCount = userUsageResult?.count || 0;
        if (coupon.perUserLimit && userUsageCount >= coupon.perUserLimit) {
          return res.status(400).json({ 
            error: 'You have already used this coupon the maximum number of times' 
          });
        }

        // Calculate discount
        if (coupon.discountType === 'percentage') {
          discountAmount = (originalPrice * parseFloat(coupon.discountValue)) / 100;
          if (coupon.maxDiscount && discountAmount > parseFloat(coupon.maxDiscount)) {
            discountAmount = parseFloat(coupon.maxDiscount);
          }
        } else {
          discountAmount = parseFloat(coupon.discountValue);
        }

        // Ensure discount doesn't exceed course price
        discountAmount = Math.min(discountAmount, originalPrice);
        finalPrice = originalPrice - discountAmount;

        validatedCoupon = coupon;
      }

      // Get Stripe instance
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: 'Payment processing is not configured' });
      }

      // Create payment intent with discounted price
      const amount = Math.round(finalPrice * 100); // Convert to cents
      
      const paymentIntent = await stripe.paymentIntents.create({
        amount,
        currency: 'usd',
        automatic_payment_methods: {
          enabled: true,
        },
        metadata: {
          courseId: courseId,
          userId: user.id,
          courseTitle: courseData.title,
          type: 'course_purchase',
          ...(validatedCoupon && {
            couponCode: validatedCoupon.code,
            couponId: validatedCoupon.id,
            discountAmount: discountAmount.toFixed(2),
            originalPrice: originalPrice.toFixed(2),
          }),
        },
      });

      // Create pending purchase record with discounted price
      await db.insert(coursePurchases).values({
        userId: user.id,
        courseId: courseId,
        amount: finalPrice.toFixed(2),
        currency: 'USD',
        paymentIntentId: paymentIntent.id,
        paymentStatus: 'pending',
      });

      res.json({ 
        success: true, 
        clientSecret: paymentIntent.client_secret,
        originalAmount: originalPrice,
        discountAmount: discountAmount,
        finalPrice: finalPrice,
        amount: finalPrice
      });
    } catch (error) {
      console.error('Error creating payment intent:', error);
      res.status(500).json({ error: 'Failed to create payment intent' });
    }
  });

  // Confirm course purchase after successful Stripe payment
  app.post('/api/courses/:courseId/purchase', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const { paymentIntentId } = req.body;
      const user = (req as AuthenticatedRequest).user;
      
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }

      if (!paymentIntentId) {
        return res.status(400).json({ error: 'Payment intent ID is required' });
      }

      // Get Stripe instance
      const stripe = await getStripeInstance();
      if (!stripe) {
        return res.status(500).json({ error: 'Payment processing is not configured' });
      }

      // Verify payment intent with Stripe
      const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);

      if (paymentIntent.status !== 'succeeded') {
        return res.status(400).json({ error: 'Payment not completed' });
      }

      // Verify metadata matches
      if (paymentIntent.metadata.courseId !== courseId || 
          paymentIntent.metadata.userId !== user.id) {
        return res.status(400).json({ error: 'Payment verification failed' });
      }

      // Update purchase record to completed
      await db
        .update(coursePurchases)
        .set({ 
          paymentStatus: 'completed',
          purchasedAt: new Date()
        })
        .where(and(
          eq(coursePurchases.paymentIntentId, paymentIntentId),
          eq(coursePurchases.userId, user.id),
          eq(coursePurchases.courseId, courseId)
        ));

      // Auto-enroll user in the course
      const existingEnrollment = await db
        .select()
        .from(courseEnrollments)
        .where(and(
          eq(courseEnrollments.userId, user.id),
          eq(courseEnrollments.courseId, courseId)
        ))
        .limit(1);

      if (existingEnrollment.length === 0) {
        await db.insert(courseEnrollments).values({
          userId: user.id,
          courseId: courseId,
          enrolledAt: new Date(),
          progress: 0,
        });
      }

      res.json({ 
        success: true, 
        message: 'Purchase completed successfully' 
      });
    } catch (error) {
      console.error('Error confirming purchase:', error);
      res.status(500).json({ error: 'Failed to confirm purchase' });
    }
  });
  // Course modules endpoint for CourseDetail page
  app.get('/api/course-creator/courses/:courseId/modules', async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // Optional authentication check - get user if authenticated
      let user = null;
      let isEnrolled = false;
      
      const authHeader = req.headers.authorization;
      const sessionId = authHeader?.replace('Bearer ', '') || 
                       req.headers['x-session-id'] as string ||
                       req.cookies?.sessionId ||
                       req.cookies?.session ||
                       req.cookies?.auth_session;

      if (sessionId) {
        try {
          const session = await db
            .select({ userId: userLoginSessions.userId })
            .from(userLoginSessions)
            .where(and(
              eq(userLoginSessions.sessionId, sessionId),
              gt(userLoginSessions.expiresAt, new Date())
            ))
            .limit(1);

          if (session.length > 0) {
            user = { id: session[0].userId };
            
            // Check if user is enrolled in this course
            const enrollment = await db
              .select()
              .from(courseEnrollments)
              .where(and(
                eq(courseEnrollments.courseId, courseId),
                eq(courseEnrollments.userId, session[0].userId)
              ))
              .limit(1);
            
            const isSpecificallyEnrolled = enrollment.length > 0;
            
            // Check if user has active subscription for premium access
            const subscriptionStatus = await hasActiveSubscription(session[0].userId);
            
            // User has access if they are enrolled OR have active subscription
            isEnrolled = isSpecificallyEnrolled || subscriptionStatus.hasAccess;
          }
        } catch (authError) {
          console.log('Auth check failed, continuing as public:', authError);
          // Continue as unauthenticated user
        }
      }
      
      // Get modules and their lessons with proper ordering
      const moduleList = await db
        .select({
          moduleId: modules.id,
          moduleTitle: modules.title,
          moduleDescription: modules.description,
          moduleOrderIndex: modules.orderNum,
          lessonId: lessons.id,
          lessonTitle: lessons.title,
          lessonContent: lessons.content,
          lessonVideoUrl: lessons.videoUrl,
          lessonOrderIndex: lessons.orderNum,
          lessonDurationMinutes: lessons.durationMinutes,
          lessonFreePreviewFlag: lessons.freePreviewFlag
        })
        .from(modules)
        .leftJoin(lessons, eq(modules.id, lessons.moduleId))
        .where(eq(modules.courseId, courseId))
        .orderBy(modules.orderNum, lessons.orderNum);

      // Group lessons by module with access control
      const groupedModules = moduleList.reduce((acc, item) => {
        const moduleId = item.moduleId;
        if (!acc[moduleId]) {
          acc[moduleId] = {
            id: item.moduleId,
            title: item.moduleTitle,
            description: item.moduleDescription,
            orderNum: item.moduleOrderIndex,
            lessons: []
          };
        }
        if (item.lessonId) {
          if (isEnrolled) {
            // Full access for enrolled users
            acc[moduleId].lessons.push({
              id: item.lessonId,
              title: item.lessonTitle,
              content: item.lessonContent,
              videoUrl: item.lessonVideoUrl,
              orderNum: item.lessonOrderIndex,
              durationMinutes: item.lessonDurationMinutes,
              freePreviewFlag: item.lessonFreePreviewFlag || false
            });
          } else if (item.lessonFreePreviewFlag) {
            // Only show preview lessons to non-enrolled users with full content
            acc[moduleId].lessons.push({
              title: item.lessonTitle,
              id: item.lessonId,
              content: item.lessonContent,
              videoUrl: item.lessonVideoUrl,
              orderNum: item.lessonOrderIndex,
              durationMinutes: item.lessonDurationMinutes,
              freePreviewFlag: item.lessonFreePreviewFlag || false
            });
          }
        }
        return acc;
      }, {} as any);

      const modules_result = Object.values(groupedModules);
      res.json({ modules: modules_result });
    } catch (error) {
      console.error('Error fetching course modules:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch course modules' });
    }
  });

  // Course enrollment status endpoint for CourseDetail page
  app.get('/api/course-creator/courses/:courseId/enrollment', requireAuth, async (req, res) => {
    try {
      const { courseId } = req.params;
      const userId = (req as AuthenticatedRequest).user.id;
      
      // Check if user is enrolled in the course
      const enrollment = await db
        .select()
        .from(courseEnrollments)
        .where(and(
          eq(courseEnrollments.courseId, courseId),
          eq(courseEnrollments.userId, userId)
        ))
        .limit(1);

      const isEnrolled = enrollment.length > 0;
      const enrollmentData = enrollment[0] || null;

      res.json({ 
        enrolled: isEnrolled,
        enrollment: enrollmentData 
      });
    } catch (error) {
      console.error('Error checking course enrollment:', error);
      res.status(500).json({ success: false, error: 'Failed to check course enrollment' });
    }
  });

  // ==================================================
  // UNIFIED SHOP CATEGORIES ENDPOINTS (Multi-role access)
  // ==================================================

  // Get shop categories (public - for unauthenticated access) 
  app.get('/api/shop-categories/public', async (req, res) => {
    try {
      // Public endpoint - only return global categories
      const categories = await db
        .select()
        .from(shopCategories)
        .where(and(
          eq(shopCategories.isActive, true),
          eq(shopCategories.scope, 'global')
        ))
        .orderBy(shopCategories.sortOrder, shopCategories.displayName);

      // Transform snake_case to camelCase for frontend
      const transformedCategories = categories.map(category => ({
        id: category.id,
        name: category.name,
        displayName: category.displayName,
        description: category.description,
        imageUrl: category.imageUrl,
        backgroundColor: category.backgroundColor,
        sortOrder: category.sortOrder,
        isActive: category.isActive,
        scope: category.scope,
        createdAt: category.createdAt.toISOString()
      }));

      res.json({
        success: true,
        data: transformedCategories
      });
    } catch (error) {
      console.error('Error fetching public shop categories:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch shop categories' 
      });
    }
  });

  // Get single shop category by ID (public - for unauthenticated access)
  app.get('/api/shop-categories/public/:id', async (req, res) => {
    try {
      const { id } = req.params;

      // Public endpoint - fetch single global category by ID
      const [category] = await db
        .select()
        .from(shopCategories)
        .where(and(
          eq(shopCategories.id, id),
          eq(shopCategories.isActive, true),
          eq(shopCategories.scope, 'global')
        ))
        .limit(1);

      if (!category) {
        return res.status(404).json({
          success: false,
          error: 'Category not found'
        });
      }

      // Transform snake_case to camelCase for frontend
      const transformedCategory = {
        id: category.id,
        name: category.name,
        displayName: category.displayName,
        description: category.description,
        imageUrl: category.imageUrl,
        backgroundColor: category.backgroundColor,
        sortOrder: category.sortOrder,
        isActive: category.isActive,
        scope: category.scope,
        createdAt: category.createdAt.toISOString()
      };

      res.json({
        success: true,
        data: transformedCategory
      });
    } catch (error) {
      console.error('Error fetching public shop category:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch shop category' 
      });
    }
  });

  // Get shop categories with role-based visibility (authenticated)
  app.get('/api/shop-categories', requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user.id;
      const userRole = (req as AuthenticatedRequest).user.role || 'student';
      const { visibility } = req.query;

      let categories;

      if (userRole === 'admin' && visibility === 'all') {
        // Admins can see all categories when requested
        categories = await db
          .select()
          .from(shopCategories)
          .where(eq(shopCategories.isActive, true))
          .orderBy(shopCategories.sortOrder, shopCategories.displayName);
      } else if (userRole === 'admin' || userRole === 'teacher' || userRole === 'freelancer') {
        // Teachers/freelancers see global + their own categories
        categories = await db
          .select()
          .from(shopCategories)
          .where(and(
            eq(shopCategories.isActive, true),
            or(
              eq(shopCategories.scope, 'global'),
              and(
                eq(shopCategories.scope, 'seller'),
                eq(shopCategories.createdBy, userId)
              )
            )
          ))
          .orderBy(shopCategories.sortOrder, shopCategories.displayName);
      } else {
        // Students and others see only global categories
        categories = await db
          .select()
          .from(shopCategories)
          .where(and(
            eq(shopCategories.isActive, true),
            eq(shopCategories.scope, 'global')
          ))
          .orderBy(shopCategories.sortOrder, shopCategories.displayName);
      }

      // Transform snake_case to camelCase for frontend
      const transformedCategories = categories.map(category => ({
        id: category.id,
        name: category.name,
        displayName: category.displayName,
        description: category.description,
        imageUrl: category.imageUrl,
        backgroundColor: category.backgroundColor,
        sortOrder: category.sortOrder,
        isActive: category.isActive,
        scope: category.scope,
        createdBy: category.createdBy,
        createdAt: category.createdAt.toISOString()
      }));

      res.json({
        success: true,
        data: transformedCategories
      });
    } catch (error) {
      console.error('Error fetching shop categories:', error);
      res.status(500).json({ 
        success: false, 
        error: 'Failed to fetch shop categories' 
      });
    }
  });

  // Create new shop category (multi-role)
  app.post('/api/shop-categories', requireAuth, upload.single('image'), async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user.id;
      const userRole = (req as AuthenticatedRequest).user.role || 'student';

      // Check if user can create categories
      if (!['admin', 'teacher', 'freelancer'].includes(userRole)) {
        return res.status(403).json({
          success: false,
          error: 'Only admins, teachers, and freelancers can create categories'
        });
      }

      // SERVER-SIDE SECURITY: Set scope based on role, never trust client
      let scope: 'global' | 'seller';
      if (userRole === 'admin') {
        // Admins can create both global and seller categories
        scope = req.body.scope === 'seller' ? 'seller' : 'global';
      } else {
        // Teachers/freelancers can ONLY create seller-scoped categories
        scope = 'seller';
      }

      // Validate and sanitize request body - including required server-side fields
      const requestData = {
        name: req.body.name?.trim(),
        displayName: req.body.displayName?.trim(),
        description: req.body.description?.trim() || '',
        backgroundColor: req.body.backgroundColor || 'bg-gradient-to-br from-blue-100 to-blue-200',
        sortOrder: req.body.sortOrder ? parseInt(req.body.sortOrder, 10) : 0,
        isActive: req.body.isActive === 'true' || req.body.isActive === true || req.body.isActive === 'True',
        scope: scope,
        createdBy: userId
      };

      const validation = insertShopCategorySchema.safeParse(requestData);

      if (!validation.success) {
        return res.status(400).json({
          success: false,
          error: 'Invalid category data',
          details: validation.error.errors
        });
      }

      const categoryData = validation.data;

      let imageUrl = null;
      if (req.file) {
        const fileType = getFileType(req.file.originalname);
        if (!FILE_CONFIGS[fileType]) {
          return res.status(400).json({
            success: false,
            error: 'Unsupported file type'
          });
        }

        const validation = validateFile(req.file, fileType);
        if (!validation.isValid) {
          return res.status(400).json({
            success: false,
            error: validation.error
          });
        }

        const uploadResult = await cloudinaryStorage.uploadFile(
          req.file.buffer,
          req.file.originalname,
          req.file.mimetype,
          FILE_CONFIGS[fileType].folder || 'shop-categories'
        );

        if (!uploadResult.success) {
          return res.status(500).json({
            success: false,
            error: 'Failed to upload image'
          });
        }
        
        imageUrl = uploadResult.url;
      }

      // SERVER-SIDE SECURITY: Always set createdBy from authenticated user, never trust client
      const [newCategory] = await db.insert(shopCategories).values({
        ...categoryData,
        scope, // Server-controlled based on role
        createdBy: userId, // Always from authenticated user
        imageUrl,
        createdAt: new Date(),
        updatedAt: new Date()
      }).returning();

      res.status(201).json({
        success: true,
        data: {
          id: newCategory.id,
          name: newCategory.name,
          displayName: newCategory.displayName,
          description: newCategory.description,
          imageUrl: newCategory.imageUrl,
          backgroundColor: newCategory.backgroundColor,
          sortOrder: newCategory.sortOrder,
          isActive: newCategory.isActive,
          scope: newCategory.scope,
          createdBy: newCategory.createdBy
        }
      });
    } catch (error) {
      console.error('Create shop category error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to create category'
      });
    }
  });

  // Update shop category
  app.put('/api/shop-categories/:id', requireAuth, upload.single('image'), async (req, res) => {
    try {
      const { id } = req.params;
      const userId = (req as any).userId;
      const profile = (req as any).profile;
      
      if (!profile) {
        return res.status(401).json({
          success: false,
          error: 'Unauthorized'
        });
      }

      // Determine scope based on role
      const isAdmin = profile.role === 'admin';
      const scope = isAdmin ? 'platform' : 'seller';

      const updateData: any = {};

      if (req.body.name) updateData.name = req.body.name.trim();
      if (req.body.displayName) updateData.displayName = req.body.displayName.trim();
      if (req.body.description !== undefined) updateData.description = req.body.description.trim();
      if (req.body.backgroundColor) updateData.backgroundColor = req.body.backgroundColor;
      if (req.body.sortOrder !== undefined) updateData.sortOrder = parseInt(req.body.sortOrder, 10);
      if (req.body.isActive !== undefined) {
        updateData.isActive = req.body.isActive === 'true' || req.body.isActive === true || req.body.isActive === 'True';
      }

      if (req.file) {
        const fileType = getFileType(req.file.originalname);
        if (!FILE_CONFIGS[fileType]) {
          return res.status(400).json({
            success: false,
            error: 'Unsupported file type'
          });
        }

        const validation = validateFile(req.file, fileType);
        if (!validation.isValid) {
          return res.status(400).json({
            success: false,
            error: validation.error
          });
        }

        const uploadResult = await cloudinaryStorage.uploadFile(
          req.file.buffer,
          req.file.originalname,
          req.file.mimetype,
          FILE_CONFIGS[fileType].folder || 'shop-categories'
        );

        if (!uploadResult.success) {
          return res.status(500).json({
            success: false,
            error: 'Failed to upload image'
          });
        }
        
        updateData.imageUrl = uploadResult.url;
      }

      const [updatedCategory] = await db
        .update(shopCategories)
        .set(updateData)
        .where(eq(shopCategories.id, id))
        .returning();
      res.json({
        success: true,
        data: {
          id: updatedCategory.id,
          name: updatedCategory.name,
          displayName: updatedCategory.displayName,
          description: updatedCategory.description,
          imageUrl: updatedCategory.imageUrl,
          backgroundColor: updatedCategory.backgroundColor,
          sortOrder: updatedCategory.sortOrder,
          isActive: updatedCategory.isActive,
          scope: updatedCategory.scope
        }
      });
    } catch (error) {
      console.error("Update shop category error:", error);
      res.status(500).json({
        success: false,
        error: "Failed to update category"
      });
    }
  });


  // ===== QUIZ AND ASSESSMENT ROUTES =====
  
  // Get quiz for a specific lesson
  app.get('/api/quizzes/lesson/:lessonId', async (req, res) => {
    try {
      const { lessonId } = req.params;
      
      const quiz = await db.query.quizzes.findFirst({
        where: eq(quizzes.lessonId, parseInt(lessonId))
      });
      
      if (!quiz) {
        return res.json(null);
      }
      
      res.json({
        id: quiz.id,
        lessonId: quiz.lessonId,
        title: quiz.title,
        description: quiz.description,
        questions: quiz.questions,
        passingScore: quiz.passingScore || 70
      });
    } catch (error) {
      console.error('Get quiz error:', error);
      res.status(500).json({ error: 'Failed to fetch quiz' });
    }
  });
  
  // Submit quiz answers
  app.post('/api/quizzes/submit', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      const { lessonId, answers, score } = req.body;
      
      const quiz = await db.query.quizzes.findFirst({
        where: eq(quizzes.lessonId, lessonId)
      });
      
      if (!quiz) {
        return res.status(404).json({ error: 'Quiz not found' });
      }
      
      const passed = score >= (quiz.passingScore || 70);
      
      const existing = await db.query.lessonProgress.findFirst({
        where: and(
          eq(lessonProgress.userId, user.id),
          eq(lessonProgress.lessonId, lessonId)
        )
      });
      
      if (existing) {
        await db.update(lessonProgress)
          .set({
            progressPercent: passed ? 100 : existing.progressPercent,
            completedAt: passed ? new Date() : existing.completedAt,
            updatedAt: new Date()
          })
          .where(eq(lessonProgress.id, existing.id));
      }
      
      res.json({
        success: true,
        passed,
        score,
        passingScore: quiz.passingScore || 70
      });
    } catch (error) {
      console.error('Submit quiz error:', error);
      res.status(500).json({ error: 'Failed to submit quiz' });
    }
  });
  
  app.get('/api/courses/:courseId/progress', requireAuth, async (req, res) => {
    try {
  // Get course progress
      const user = req.user;
      if (!user) {
        return res.status(401).json({ success: false, error: 'Unauthorized' });
      }

      const { courseId } = req.params;

      // Get all modules and lessons for this course
      const courseModules = await db.query.modules.findMany({
        where: eq(modules.courseId, courseId),
        with: {
          lessons: true
        },
        orderBy: [asc(modules.orderNum)]
      });

      const allLessons = courseModules.flatMap(m => m.lessons);
      const totalLessons = allLessons.length;

      if (totalLessons === 0) {
        return res.json({
          success: true,
          progressPercentage: 0,
          completedLessons: 0,
          totalLessons: 0,
          lessonProgress: []
        });
      }

      // Get user's lesson progress
      const userProgress = await db.query.lessonProgress.findMany({
        where: eq(lessonProgress.userId, user.id)
      });

      // Create a map of completed lessons
      const progressMap = userProgress.reduce((acc, lp) => {
        acc[lp.lessonId] = {
          completed: lp.completedAt !== null,
          quizPassed: lp.quizPassed,
          score: lp.score
        };
        return acc;
      }, {} as Record<number, any>);

      // Calculate completed lessons count
      const completedCount = allLessons.filter(lesson => 
        progressMap[lesson.id]?.completed
      ).length;

      const progressPercentage = Math.round((completedCount / totalLessons) * 100);

      // Update course enrollment progress
      await db
        .update(courseEnrollments)
        .set({ progress: progressPercentage })
        .where(and(
          eq(courseEnrollments.userId, user.id),
          eq(courseEnrollments.courseId, courseId)
        ));

      res.json({
        success: true,
        progressPercentage,
        completedLessons: completedCount,
        totalLessons,
        lessonProgress: allLessons.map(lesson => ({
          lessonId: lesson.id,
          completed: progressMap[lesson.id]?.completed || false,
          quizPassed: progressMap[lesson.id]?.quizPassed,
          score: progressMap[lesson.id]?.score
        }))
      });
    } catch (error) {
      console.error('Course progress fetch error:', error);
      res.status(500).json({
        success: false,
        error: 'Failed to fetch course progress'
      });
    }
  });
  // ===== CERTIFICATE ROUTES =====
  
  // Generate certificate for course completion
  // Generate certificate for course completion
  app.post('/api/certificates/generate', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      const { courseId } = req.body;
      
      // Get course details
      const course = await db.query.courses.findFirst({
        where: eq(courses.id, courseId)
      });
      
      if (!course) {
        return res.status(404).json({ error: 'Course not found' });
      }
      
      // Check if user has completed the course
      const enrollment = await db.query.courseEnrollments.findFirst({
        where: and(
          eq(courseEnrollments.userId, user.id),
          eq(courseEnrollments.courseId, courseId)
        )
      });
      
      if (!enrollment) {
        return res.status(403).json({ error: 'You are not enrolled in this course' });
      }
      
      // Check if course is 100% complete
      if (enrollment.progress !== 100) {
        return res.status(400).json({ 
          error: 'You must complete 100% of the course before generating a certificate',
          currentProgress: enrollment.progress
        });
      }
      
      // Check if certificate already exists
      const existingCertificate = await db.query.certificates.findFirst({
        where: and(
          eq(certificates.userId, user.id),
          eq(certificates.courseId, courseId),
          eq(certificates.isRevoked, false)
        )
      });
      
      if (existingCertificate) {
        // Certificate already exists - ask Certifier to resend it to the user's email
        if (existingCertificate.certifierId) {
          try {
            const { certifierAPI } = await import('./utils/certifier-api.js');
            console.log(`ðŸ“§ Requesting Certifier to resend certificate to ${user.email}`);
            await certifierAPI.sendCredential(existingCertificate.certifierId);
            console.log(`âœ… Certifier will send the certificate to ${user.email}`);
          } catch (resendError) {
            console.error('âŒ Failed to request Certifier resend:', resendError);
          }
        }
        // Return existing certificate
        return res.json(existingCertificate);
      }
      
      // Get user profile
      const profile = await db.query.profiles.findFirst({
        where: eq(profiles.userId, user.id)
      });
      
      if (!profile) {
        return res.status(404).json({ error: 'User profile not found' });
      }
      
      // Generate verification code
      const verificationCode = generateVerificationCode();
      
      // Generate certificate using Certifier API
      const { certificateUrl, certifierId, certifierGroupId } = await generateCertificateWithCertifier({
        studentName: profile.name,
        studentEmail: user.email,
        courseTitle: course.title,
        courseDescription: course.description || undefined,
        completionDate: enrollment.completedAt || new Date(),
        verificationCode,
        instructorName: course.publisherName || undefined,
        finalScore: enrollment.progress,
        certificateType: (course.certificationType as 'certificate' | 'diploma') || 'certificate',
      });
      
      // Create certificate in database
      const [newCertificate] = await db.insert(certificates).values({
        userId: user.id,
        courseId: courseId,
        studentName: profile.name,
        studentEmail: user.email,
        courseTitle: course.title,
        courseDescription: course.description,
        verificationCode,
        certificateUrl,
        completionDate: enrollment.completedAt || new Date(),
        finalScore: enrollment.progress,
        instructorName: course.publisherName,
        certificateType: course.certificationType || 'certificate',
        certifierId,
        certifierGroupId,
      }).returning();
      
      // Certifier API already sent the certificate via email in createIssueAndSendCredential()
      console.log(`âœ… Certificate generated and sent by Certifier to ${user.email}`);
      
      res.json(newCertificate);
    } catch (error) {
      console.error('Generate certificate error:', error);
      res.status(500).json({ error: 'Failed to generate certificate' });
    }
  });
  
  // Get user's certificates
  app.get('/api/certificates/my-certificates', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      const userCertificates = await db.query.certificates.findMany({
        where: and(
          eq(certificates.userId, user.id),
          eq(certificates.isRevoked, false)
        ),
        orderBy: [desc(certificates.issueDate)]
      });
      
      res.json(userCertificates);
    } catch (error) {
      console.error('Get certificates error:', error);
      res.status(500).json({ error: 'Failed to fetch certificates' });
    }
  });
  
  // Get certificate by verification code
  app.get('/api/certificates/verify/:verificationCode', async (req, res) => {
    try {
      const { verificationCode } = req.params;
      
      const certificate = await db.query.certificates.findFirst({
        where: and(
          eq(certificates.verificationCode, verificationCode),
          eq(certificates.isRevoked, false)
        )
      });
      
      if (!certificate) {
        return res.status(404).json({ error: 'Certificate not found' });
      }
      
      res.json({
        id: certificate.id,
        userName: certificate.userName,
        courseTitle: certificate.courseTitle,
        issuedAt: certificate.issuedAt,
        verificationCode: certificate.verificationCode,
        certificateUrl: certificate.certificateUrl,
        isValid: !certificate.isRevoked
      });
    } catch (error) {
      console.error('Verify certificate error:', error);
      res.status(500).json({ error: 'Failed to verify certificate' });
    }
  });
  
  // Download certificate (placeholder - can be enhanced with PDF generation)
  app.get('/api/certificates/:id/download', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      const { id } = req.params;
      
      const certificate = await db.query.certificates.findFirst({
        where: and(
          eq(certificates.id, id),
          eq(certificates.userId, user.id),
          eq(certificates.isRevoked, false)
        )
      });
      
      if (!certificate) {
        return res.status(404).json({ error: 'Certificate not found' });
      }
      
      // Return certificate data for now
      // In the future, this can generate and return a PDF
      res.json(certificate);
    } catch (error) {
      console.error('Download certificate error:', error);
      res.status(500).json({ error: 'Failed to download certificate' });
    }
  });
  // Get course progress alternative endpoint
  app.get('/api/courses/:courseId/progress-alt', requireAuth, async (req, res) => {
    try {
      const user = req.user;
      if (!user) {
        return res.status(401).json({ error: 'Unauthorized' });
      }
      
      const { courseId } = req.params;
      
      // Get all lessons in this course
      const courseLessons = await db
        .select({
          lessonId: lessons.id
        })
        .from(lessons)
        .leftJoin(modules, eq(lessons.moduleId, modules.id))
        .where(eq(modules.courseId, courseId));
      
      const allLessonIds = courseLessons.map(l => l.lessonId);
      const totalLessons = allLessonIds.length;
      
      if (totalLessons === 0) {
        return res.json({
          completedLessons: 0,
          totalLessons: 0,
          progressPercentage: 0,
          lessonProgress: []
        });
      }
      
      const progress = await db
        .select()
        .from(lessonProgress)
        .where(and(
          eq(lessonProgress.userId, user.id),
          inArray(lessonProgress.lessonId, allLessonIds)
        ));
      
      const completed = progress.filter(p => p.completedAt !== null);
      const progressPercentage = Math.round((completed.length / totalLessons) * 100);
      
      res.json({
        completedLessons: completed.length,
        totalLessons,
        progressPercentage,
        lessonProgress: progress.map(p => ({
          lessonId: p.lessonId,
          completed: p.completedAt !== null,
          progressPercent: p.progressPercent
        }))
      });
    } catch (error) {
      console.error('Get course progress error:', error);
      res.status(500).json({ error: 'Failed to fetch progress' });
    }
  });


  // ==========================================
  // API Keys - Marketplace API Access
  // ==========================================

  app.post("/api/api-keys/generate", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { name, tier, permissions, expiresInDays } = req.body;

      // Validate tier based on user's membership
      const userProfile = await db.query.profiles.findFirst({
        where: eq(profiles.userId, userId)
      });

      if (!userProfile) {
        return res.status(404).json({ error: "Profile not found" });
      }

      // Check if user has required subscription tier
      const subscriptionTier = userProfile.subscriptionTier;
      if (tier === 'basic' && !['pro', 'business'].includes(subscriptionTier || '')) {
        return res.status(403).json({ error: "Pro or Business tier required for Basic API access" });
      }
      if (tier === 'advanced' && subscriptionTier !== 'business') {
        return res.status(403).json({ error: "Business tier required for Advanced API access" });
      }

      // Generate a secure random API key
      const crypto = await import('crypto');
      const apiKey = `mk_${crypto.randomBytes(32).toString('hex')}`;

      // Hash the key before storing
      const keyHash = await bcrypt.hash(apiKey, 10);
      const keyPreview = apiKey.substring(0, 10) + '...' + apiKey.substring(apiKey.length - 4);

      // Calculate expiration date if specified
      let expiresAt = null;
      if (expiresInDays) {
        expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + expiresInDays);
      }

      const newKey = await storage.createApiKey({
        userId,
        keyHash,
        keyPreview,
        name: name || 'API Key',
        tier: tier || 'basic',
        permissions: permissions || [],
        expiresAt,
        isActive: true
      });

      res.json({
        id: newKey.id,
        name: newKey.name,
        key: apiKey, // Return the raw key only once
        tier: newKey.tier,
        permissions: newKey.permissions,
        expiresAt: newKey.expiresAt,
        createdAt: newKey.createdAt,
        message: "Store this key securely - it won't be shown again!"
      });
    } catch (error) {
      console.error('Generate API key error:', error);
      res.status(500).json({ error: "Failed to generate API key" });
    }
  });
  // List user's API keys
  app.get("/api/api-keys", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const keys = await storage.getApiKeysByUserId(userId);
      
      // Return sanitized metadata - keyPreview is already stored in DB
      const sanitizedKeys = keys.map(k => ({
        id: k.id,
        name: k.name,
        tier: k.tier,
        permissions: k.permissions,
        keyPreview: k.keyPreview, // Already formatted in DB as "mk_xxxxxxxxxx...xxxx"
        lastUsedAt: k.lastUsedAt,
        expiresAt: k.expiresAt,
        createdAt: k.createdAt
      }));

      res.json(sanitizedKeys);
    } catch (error) {
      console.error('List API keys error:', error);
      res.status(500).json({ error: "Failed to list API keys" });
    }
  });

  // Revoke an API key
  app.delete("/api/api-keys/:keyId", requireAuth, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }

      const { keyId } = req.params;

      // Verify the key belongs to the user
      const key = await db.query.apiKeys.findFirst({
        where: and(
          eq(apiKeys.id, keyId),
          eq(apiKeys.userId, userId)
        )
      });

      if (!key) {
        return res.status(404).json({ error: "API key not found" });
      }

      await storage.revokeApiKey(keyId);

      res.json({ message: "API key revoked successfully" });
    } catch (error) {
      console.error('Revoke API key error:', error);
      res.status(500).json({ error: "Failed to revoke API key" });
    }
  });

  // Example API endpoint that can be accessed with API keys
  app.get("/api/v1/profile", validateApiKey, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).apiKey?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Invalid API key" });
      }

      const userProfile = await db.query.profiles.findFirst({
        where: eq(profiles.userId, userId)
      });

      if (!userProfile) {
        return res.status(404).json({ error: "Profile not found" });
      }

      res.json({
        id: userProfile.id,
        name: userProfile.name,
        email: userProfile.email,
        subscriptionTier: userProfile.subscriptionTier,
        createdAt: userProfile.createdAt
      });
    } catch (error) {
      console.error('API profile fetch error:', error);
      res.status(500).json({ error: "Failed to fetch profile" });
    }
  });

  // Example API endpoint for accessing purchases (requires API key)
  app.get("/api/v1/purchases", validateApiKey, async (req, res) => {
    try {
      const userId = (req as AuthenticatedRequest).apiKey?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Invalid API key" });
      }

      const purchases = await db.query.shopPurchases.findMany({
        where: eq(shopPurchases.customerId, userId),
        orderBy: [desc(shopPurchases.purchaseDate)],
        limit: 100
      });

      res.json({
        purchases: purchases.map(p => ({
          id: p.id,
          productId: p.productId,
          amount: p.amount,
          purchaseDate: p.purchaseDate,
          downloadUrl: p.downloadUrl
        }))
      });
    } catch (error) {
      console.error('API purchases fetch error:', error);
      res.status(500).json({ error: "Failed to fetch purchases" });
    }
  });
  
  // GET /api/app-download-links - Get app download links (public)
  app.get('/api/app-download-links', async (req, res) => {
    try {
      const links = await storage.getAppDownloadLinks();
      res.json({ success: true, data: links });
    } catch (error) {
      console.error('Error fetching app download links:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch app download links' });
    }
  });

  // POST /api/admin/app-download-links - Update app download links (admin only)
  app.post('/api/admin/app-download-links', requireAuth, requireAdmin, async (req, res) => {
    console.log('ðŸš€ POST /api/admin/app-download-links called');
    console.log('ðŸ“¦ Request body:', req.body);
    try {
      const { 
        appStoreUrl, 
        appStoreText, 
        googlePlayUrl, 
        googlePlayText,
        huaweiGalleryUrl,
        huaweiGalleryText
      } = req.body;
      
      console.log('ðŸ“Š Extracted values:', {
        appStoreUrl,
        appStoreText,
        googlePlayUrl,
        googlePlayText,
        huaweiGalleryUrl,
        huaweiGalleryText
      });
      
      console.log('ðŸ’¾ Calling storage.updateAppDownloadLinks...');
      const links = await storage.updateAppDownloadLinks(
        appStoreUrl || '', 
        appStoreText || 'Download on the',
        googlePlayUrl || '', 
        googlePlayText || 'Get it on',
        huaweiGalleryUrl || '',
        huaweiGalleryText || 'Explore it on'
      );
      
      console.log('âœ… Storage returned:', links);
      res.json({ success: true, data: links });
    } catch (error) {
      console.error('âŒ Error updating app download links:', error);
      res.status(500).json({ success: false, error: 'Failed to update app download links' });
    }
  });




  // ==========================================
  // Social Media Links - Social media profile links
  // ==========================================
  

  // ==========================================
  // Social Media Links - Social media profile links
  // ==========================================
  
  // GET /api/social-media-links - Get social media links (public)
  app.get('/api/social-media-links', async (req, res) => {
    try {
      const links = await storage.getSocialMediaLinks();
      res.json({ success: true, data: links });
    } catch (error) {
      console.error('Error fetching social media links:', error);
      res.status(500).json({ success: false, error: 'Failed to fetch social media links' });
    }
  });

  // POST /api/admin/social-media-links - Update social media links (admin only)
  app.post('/api/admin/social-media-links', requireAuth, requireAdmin, async (req, res) => {
    console.log('ðŸš€ POST /api/admin/social-media-links called');
    console.log('ðŸ“¦ Request body:', req.body);
    try {
      const { 
        whatsappUrl,
        instagramUrl,
        telegramUrl,
        dribbbleUrl,
        threadsUrl,
        facebookUrl, 
        xUrl,
        pinterestUrl, 
        behanceUrl
      } = req.body;
      
      console.log('ðŸ“Š Extracted values:', {
        whatsappUrl,
        instagramUrl,
        telegramUrl,
        dribbbleUrl,
        threadsUrl,
        facebookUrl,
        xUrl,
        pinterestUrl,
        behanceUrl
      });
      
      console.log('ðŸ’¾ Calling storage.updateSocialMediaLinks...');
      const links = await storage.updateSocialMediaLinks(
        whatsappUrl || '',
        '', // linkedinUrl (not using currently)
        instagramUrl || '',
        threadsUrl || '',
        '', // tiktokUrl (not using currently)
        dribbbleUrl || '',
        facebookUrl || '',
        xUrl || '',
        pinterestUrl || '',
        behanceUrl || '',
        telegramUrl || ''
      );
      
      console.log('âœ… Storage returned:', links);
      res.json({ success: true, data: links });
    } catch (error) {
      console.error('âŒ Error updating social media links:', error);
      res.status(500).json({ success: false, error: 'Failed to update social media links' });
    }
  });

  // Register meeting routes
  // Register teacher application routes
  const teacherApplicationRoutes = (await import('./routes/teacher-application-routes.js')).default;
  app.use('/api', teacherApplicationRoutes);

  // Register shop verification routes
  const shopVerificationRoutes = (await import('./routes/shop-verification-routes.js')).default;
  app.use('/api', shopVerificationRoutes);

  const { registerMeetingRoutes } = await import('./meeting-routes.js');
  registerMeetingRoutes(app);

  // Test email routes (for testing email templates)
  const testEmailRoutes = (await import("./routes/test-emails.js")).default;
  app.use("/api", testEmailRoutes);

  return server;
}

