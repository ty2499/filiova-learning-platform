import cron from 'node-cron';
import { db } from '../db';
import { 
  creatorBalances, 
  creatorPayoutRequests, 
  payoutAccounts,
  adminNotifications,
  jobExecutions,
  users,
  profiles
} from '../../shared/schema';
import { eq, and, sql, gte } from 'drizzle-orm';

/**
 * Payout Automation Service
 * 
 * Handles automated monthly payout workflows:
 * - 2nd of month: Create payout requests and notify admin
 * - 5th of month: Finalize approved payouts
 */

const MINIMUM_PAYOUT_AMOUNT = 50.00;

/**
 * Job 1: Create Monthly Payout Requests (Runs on 2nd of every month at 00:05 UTC)
 * 
 * This job:
 * 1. Finds all creators with available balance >= $50
 * 2. Creates auto-generated payout requests
 * 3. Sends notification to admin
 */
async function createMonthlyPayoutRequests() {
  const jobType = 'payout_creation';
  const runDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  
  console.log(`üîÑ [${runDate}] Starting payout creation job...`);
  
  try {
    // Check if job already ran today (idempotency)
    const [existingRun] = await db.select()
      .from(jobExecutions)
      .where(and(
        eq(jobExecutions.jobType, jobType),
        eq(jobExecutions.runDate, runDate),
        eq(jobExecutions.status, 'completed')
      ));
    
    if (existingRun) {
      console.log(`‚úÖ Job already completed today (${runDate})`);
      return { success: true, message: 'Job already ran today' };
    }
    
    // Create job execution record
    const [jobRun] = await db.insert(jobExecutions).values({
      jobType,
      runDate,
      status: 'running',
    }).returning();
    
    const startTime = Date.now();
    
    // Get next payout date (5th of current month)
    const now = new Date();
    const nextPayoutDate = new Date(now.getFullYear(), now.getMonth(), 5, 0, 0, 0);
    
    // Find all creators with available balance >= $50
    const eligibleCreators = await db.select({
      creatorId: creatorBalances.creatorId,
      availableBalance: creatorBalances.availableBalance,
      creator: {
        id: users.id,
        email: users.email,
        name: profiles.name,
        role: profiles.role,
      }
    })
      .from(creatorBalances)
      .leftJoin(users, eq(creatorBalances.creatorId, users.id))
      .leftJoin(profiles, eq(users.id, profiles.userId))
      .where(sql`${creatorBalances.availableBalance}::numeric >= ${MINIMUM_PAYOUT_AMOUNT}`);
    
    console.log(`üìä Found ${eligibleCreators.length} eligible creators for payout`);
    
    let payoutsCreated = 0;
    let totalAmount = 0;
    const payoutDetails: any[] = [];
    
    for (const creator of eligibleCreators) {
      const availableBalance = parseFloat(creator.availableBalance);
      
      // Get creator's default payout account
      const [defaultAccount] = await db.select()
        .from(payoutAccounts)
        .where(and(
          eq(payoutAccounts.userId, creator.creatorId),
          eq(payoutAccounts.isDefault, true)
        ))
        .limit(1);
      
      if (!defaultAccount) {
        console.warn(`‚ö†Ô∏è Creator ${creator.creatorId} has no default payout account, skipping`);
        continue;
      }
      
      // Create payout request
      const [payoutRequest] = await db.insert(creatorPayoutRequests).values({
        creatorId: creator.creatorId,
        amountRequested: availableBalance.toString(),
        payoutMethod: defaultAccount.type,
        payoutAccountId: defaultAccount.id,
        status: 'awaiting_admin',
        payoutDate: nextPayoutDate,
        isAutoGenerated: true,
        notificationSent: false,
      }).returning();
      
      payoutsCreated++;
      totalAmount += availableBalance;
      
      payoutDetails.push({
        creatorId: creator.creatorId,
        creatorName: creator.creator?.name || 'Unknown',
        amount: availableBalance,
        method: defaultAccount.type,
        requestId: payoutRequest.id,
      });
      
      console.log(`üí∏ Created payout for ${creator.creator?.name}: $${availableBalance.toFixed(2)} via ${defaultAccount.type}`);
    }
    
    // Create admin notification
    if (payoutsCreated > 0) {
      await db.insert(adminNotifications).values({
        type: 'payout_due',
        title: `${payoutsCreated} Payout Requests Ready`,
        message: `${payoutsCreated} creators are ready for monthly payout. Total amount: $${totalAmount.toFixed(2)}. Deadline: ${nextPayoutDate.toLocaleDateString()}`,
        data: {
          payoutCount: payoutsCreated,
          totalAmount: totalAmount.toFixed(2),
          deadline: nextPayoutDate.toISOString(),
          details: payoutDetails,
        },
        targetRole: 'admin',
        priority: 'high',
        expiresAt: nextPayoutDate, // Hide after payout deadline
      });
      
      console.log(`üì¨ Admin notification created: ${payoutsCreated} payouts, total $${totalAmount.toFixed(2)}`);
    }
    
    // Update job execution
    const duration = Date.now() - startTime;
    await db.update(jobExecutions)
      .set({
        status: 'completed',
        recordsProcessed: payoutsCreated,
        completedAt: new Date(),
        durationMs: duration,
        metadata: {
          totalAmount: totalAmount.toFixed(2),
          eligibleCreators: eligibleCreators.length,
          payoutsCreated,
        },
      })
      .where(eq(jobExecutions.id, jobRun.id));
    
    console.log(`‚úÖ Payout creation job completed in ${duration}ms`);
    
    return {
      success: true,
      payoutsCreated,
      totalAmount: totalAmount.toFixed(2),
      message: `Created ${payoutsCreated} payout requests totaling $${totalAmount.toFixed(2)}`,
    };
    
  } catch (error) {
    console.error('‚ùå Error in payout creation job:', error);
    
    // Mark job as failed
    await db.insert(jobExecutions).values({
      jobType,
      runDate,
      status: 'failed',
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
    });
    
    throw error;
  }
}

/**
 * Job 2: Finalize Approved Payouts (Runs on 5th of every month at 00:05 UTC)
 * 
 * This job:
 * 1. Finds all payout requests in 'approved' or 'payment_processing' status
 * 2. Marks them as 'completed'
 * 3. Updates creator balances
 * 4. Sends confirmation notifications to creators
 */
async function finalizeApprovedPayouts() {
  const jobType = 'payout_finalization';
  const runDate = new Date().toISOString().split('T')[0];
  
  console.log(`üîÑ [${runDate}] Starting payout finalization job...`);
  
  try {
    // Check if job already ran today
    const [existingRun] = await db.select()
      .from(jobExecutions)
      .where(and(
        eq(jobExecutions.jobType, jobType),
        eq(jobExecutions.runDate, runDate),
        eq(jobExecutions.status, 'completed')
      ));
    
    if (existingRun) {
      console.log(`‚úÖ Job already completed today (${runDate})`);
      return { success: true, message: 'Job already ran today' };
    }
    
    // Create job execution record
    const [jobRun] = await db.insert(jobExecutions).values({
      jobType,
      runDate,
      status: 'running',
    }).returning();
    
    const startTime = Date.now();
    
    // Find all payouts that are approved or in processing
    const payoutsToFinalize = await db.select()
      .from(creatorPayoutRequests)
      .where(and(
        eq(creatorPayoutRequests.status, 'payment_processing'),
        sql`DATE(${creatorPayoutRequests.payoutDate}) <= CURRENT_DATE`
      ));
    
    console.log(`üìä Found ${payoutsToFinalize.length} payouts to finalize`);
    
    let finalizedCount = 0;
    
    for (const payout of payoutsToFinalize) {
      // Mark as completed
      await db.update(creatorPayoutRequests)
        .set({
          status: 'completed',
          finalizedAt: new Date(),
          finalizedByJob: true,
        })
        .where(eq(creatorPayoutRequests.id, payout.id));
      
      // Update creator balance
      const amountPaid = parseFloat(payout.amountApproved || payout.amountRequested);
      
      await db.execute(sql`
        UPDATE creator_balances 
        SET 
          total_withdrawn = total_withdrawn::numeric + ${amountPaid}::numeric,
          last_payout_date = NOW(),
          next_payout_date = (DATE_TRUNC('month', CURRENT_DATE + interval '1 month') + interval '4 days')::timestamp,
          updated_at = NOW()
        WHERE creator_id = ${payout.creatorId}
      `);
      
      finalizedCount++;
      console.log(`‚úÖ Finalized payout ${payout.id} for creator ${payout.creatorId}: $${amountPaid.toFixed(2)}`);
    }
    
    // Update job execution
    const duration = Date.now() - startTime;
    await db.update(jobExecutions)
      .set({
        status: 'completed',
        recordsProcessed: finalizedCount,
        completedAt: new Date(),
        durationMs: duration,
        metadata: {
          finalizedCount,
          processedDate: runDate,
        },
      })
      .where(eq(jobExecutions.id, jobRun.id));
    
    console.log(`‚úÖ Payout finalization job completed in ${duration}ms`);
    
    return {
      success: true,
      finalizedCount,
      message: `Finalized ${finalizedCount} payouts`,
    };
    
  } catch (error) {
    console.error('‚ùå Error in payout finalization job:', error);
    
    await db.insert(jobExecutions).values({
      jobType,
      runDate,
      status: 'failed',
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
    });
    
    throw error;
  }
}

/**
 * Initialize scheduled jobs
 * 
 * Cron schedule format: minute hour day-of-month month day-of-week
 * 
 * - 2nd of month: '5 0 2 * *' (00:05 UTC on 2nd)
 * - 5th of month: '5 0 5 * *' (00:05 UTC on 5th)
 */
export function initializePayoutScheduler() {
  console.log('üöÄ Initializing payout automation scheduler...');
  
  // Job 1: Create payout requests on 2nd of every month at 00:05 UTC
  cron.schedule('5 0 2 * *', async () => {
    console.log('‚è∞ Triggered: Monthly payout creation (2nd of month)');
    try {
      await createMonthlyPayoutRequests();
    } catch (error) {
      console.error('Failed to create monthly payouts:', error);
    }
  }, {
    timezone: 'UTC'
  });
  
  // Job 2: Finalize approved payouts on 5th of every month at 00:05 UTC
  cron.schedule('5 0 5 * *', async () => {
    console.log('‚è∞ Triggered: Payout finalization (5th of month)');
    try {
      await finalizeApprovedPayouts();
    } catch (error) {
      console.error('Failed to finalize payouts:', error);
    }
  }, {
    timezone: 'UTC'
  });
  
  console.log('‚úÖ Payout scheduler initialized');
  console.log('  üìÖ Payout creation: 2nd of every month at 00:05 UTC');
  console.log('  üìÖ Payout finalization: 5th of every month at 00:05 UTC');
}

// Export manual trigger functions for testing/admin use
export { createMonthlyPayoutRequests, finalizeApprovedPayouts };
