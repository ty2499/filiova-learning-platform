// Catalog data loader - loads static catalog data from JSON files
// This eliminates database egress costs by serving catalog data from CDN

export interface CourseListing {
  id: string;
  title: string;
  description: string | null;
  thumbnailUrl: string | null;
  image: string | null;
  categoryId: string | null;
  pricingType: string;
  gradeTier: string | null;
  difficulty: string | null;
  duration: number | null;
  tags: string[] | null;
  language: string | null;
  isFeatured: boolean | null;
  lessonCount: number;
  moduleCount: number;
}

export interface CourseDetail extends CourseListing {
  learningObjectives: string[] | null;
  certificationType: string | null;
  credits: number | null;
  publisherName: string | null;
  publisherBio: string | null;
  modules: Module[];
}

export interface Module {
  id: string;
  title: string;
  description: string | null;
  orderNum: number;
  lessons: Lesson[];
}

export interface Lesson {
  id: number;
  title: string;
  description: string | null;
  content: string | null;
  durationMinutes: number | null;
  order: number | null;
  freePreview: boolean | null;
  videoUrl: string | null;
  images: string[] | null;
}

export interface SubjectListing {
  id: string;
  name: string;
  description: string | null;
  iconUrl: string | null;
  gradeLevel: number;
  gradeSystem: string;
  lessonCount: number;
  chapterCount: number;
}

export interface SubjectDetail extends SubjectListing {
  chapters: Chapter[];
}

export interface Chapter {
  id: string;
  title: string;
  description: string | null;
  order: number;
  isActive: boolean;
  lessons: SubjectLesson[];
}

export interface SubjectLesson {
  id: string;
  title: string;
  notes: string | null;
  examples: string[] | null;
  order: number;
  isActive: boolean | null;
  cloudinaryImages: string[] | null;
  exercises: Exercise[];
}

export interface Exercise {
  id: string;
  question: string;
  options: string[] | null;
  correctAnswer: string | null;
  explanation: string | null;
  order: number;
}

export interface Category {
  id: string;
  name: string;
  displayName: string | null;
  description: string | null;
  color: string | null;
  isActive: boolean;
}

export interface CatalogIndex {
  version: string;
  generatedAt: string;
  stats: {
    totalCourses: number;
    totalSubjects: number;
    totalCategories: number;
    totalCourseLessons: number;
    totalSubjectLessons: number;
  };
  files: {
    manifest: string;
    categories: string;
    coursesListing: string;
    subjectsListing: string;
    courses: string[];
    subjects: string[];
  };
}

// Cache for loaded data to avoid repeated fetches
const catalogCache = new Map<string, any>();

// Base path for catalog files
const CATALOG_BASE = '/catalog';

/**
 * Load catalog index (lightweight metadata about catalog)
 */
export async function loadCatalogIndex(): Promise<CatalogIndex> {
  const cacheKey = 'catalog-index';
  
  if (catalogCache.has(cacheKey)) {
    return catalogCache.get(cacheKey);
  }
  
  const response = await fetch(`${CATALOG_BASE}/index.json`);
  if (!response.ok) {
    throw new Error('Failed to load catalog index');
  }
  
  const data = await response.json();
  catalogCache.set(cacheKey, data);
  return data;
}

/**
 * Load all categories
 */
export async function loadCategories(): Promise<Category[]> {
  const cacheKey = 'categories';
  
  if (catalogCache.has(cacheKey)) {
    return catalogCache.get(cacheKey);
  }
  
  const response = await fetch(`${CATALOG_BASE}/categories.json`);
  if (!response.ok) {
    throw new Error('Failed to load categories');
  }
  
  const data = await response.json();
  catalogCache.set(cacheKey, data);
  return data;
}

/**
 * Load courses listing (without full content - for browse pages)
 */
export async function loadCoursesListing(): Promise<CourseListing[]> {
  const cacheKey = 'courses-listing';
  
  if (catalogCache.has(cacheKey)) {
    return catalogCache.get(cacheKey);
  }
  
  const response = await fetch(`${CATALOG_BASE}/courses-listing.json`);
  if (!response.ok) {
    throw new Error('Failed to load courses listing');
  }
  
  const data = await response.json();
  catalogCache.set(cacheKey, data);
  return data;
}

/**
 * Load full course detail by ID
 * Note: Individual course detail files are not generated by the fast generator.
 * Use API endpoint for full course details with caching enabled.
 */
export async function loadCourseDetail(courseId: string): Promise<CourseDetail | null> {
  // For now, return course from listing without nested modules/lessons
  // In production, you would fetch from API: /api/courses/${courseId}
  const courses = await loadCoursesListing();
  const course = courses.find(c => c.id === courseId);
  
  if (!course) {
    return null;
  }
  
  // Return course with empty modules (full details should come from cached API)
  return {
    ...course,
    learningObjectives: null,
    certificationType: null,
    credits: null,
    publisherName: null,
    publisherBio: null,
    modules: []
  } as CourseDetail;
}

/**
 * Load subjects listing (without full content - for browse pages)
 */
export async function loadSubjectsListing(): Promise<SubjectListing[]> {
  const cacheKey = 'subjects-listing';
  
  if (catalogCache.has(cacheKey)) {
    return catalogCache.get(cacheKey);
  }
  
  const response = await fetch(`${CATALOG_BASE}/subjects-listing.json`);
  if (!response.ok) {
    throw new Error('Failed to load subjects listing');
  }
  
  const data = await response.json();
  catalogCache.set(cacheKey, data);
  return data;
}

/**
 * Load full subject detail by ID
 * Note: Individual subject detail files are not generated by the fast generator.
 * Use API endpoint for full subject details with caching enabled.
 */
export async function loadSubjectDetail(subjectId: string): Promise<SubjectDetail | null> {
  // For now, return subject from listing without nested chapters/lessons
  // In production, you would fetch from API: /api/subjects/${subjectId}
  const subjects = await loadSubjectsListing();
  const subject = subjects.find(s => s.id === subjectId);
  
  if (!subject) {
    return null;
  }
  
  // Return subject with empty chapters (full details should come from cached API)
  return {
    ...subject,
    chapters: []
  };
}

/**
 * Filter courses by criteria
 */
export async function filterCourses(options: {
  difficulty?: string;
  categoryId?: string;
  gradeTier?: string;
  isFeatured?: boolean;
  searchQuery?: string;
}): Promise<CourseListing[]> {
  const courses = await loadCoursesListing();
  
  return courses.filter(course => {
    if (options.difficulty && course.difficulty !== options.difficulty) {
      return false;
    }
    
    if (options.categoryId && course.categoryId !== options.categoryId) {
      return false;
    }
    
    if (options.gradeTier && course.gradeTier !== options.gradeTier) {
      return false;
    }
    
    if (options.isFeatured !== undefined && course.isFeatured !== options.isFeatured) {
      return false;
    }
    
    if (options.searchQuery) {
      const query = options.searchQuery.toLowerCase();
      const matchesTitle = course.title.toLowerCase().includes(query);
      const matchesDescription = course.description?.toLowerCase().includes(query);
      const matchesTags = course.tags?.some(tag => tag.toLowerCase().includes(query));
      
      if (!matchesTitle && !matchesDescription && !matchesTags) {
        return false;
      }
    }
    
    return true;
  });
}

/**
 * Filter subjects by criteria
 */
export async function filterSubjects(options: {
  gradeLevel?: number;
  gradeSystem?: string;
  searchQuery?: string;
}): Promise<SubjectListing[]> {
  const subjects = await loadSubjectsListing();
  
  return subjects.filter(subject => {
    if (options.gradeLevel !== undefined && subject.gradeLevel !== options.gradeLevel) {
      return false;
    }
    
    if (options.gradeSystem) {
      // Show subjects that match the grade system OR are marked as 'all'
      if (subject.gradeSystem !== options.gradeSystem && subject.gradeSystem !== 'all') {
        return false;
      }
    }
    
    if (options.searchQuery) {
      const query = options.searchQuery.toLowerCase();
      const matchesName = subject.name.toLowerCase().includes(query);
      const matchesDescription = subject.description?.toLowerCase().includes(query);
      
      if (!matchesName && !matchesDescription) {
        return false;
      }
    }
    
    return true;
  });
}

/**
 * Get featured courses
 */
export async function getFeaturedCourses(limit?: number): Promise<CourseListing[]> {
  const courses = await loadCoursesListing();
  const featured = courses.filter(c => c.isFeatured);
  
  if (limit) {
    return featured.slice(0, limit);
  }
  
  return featured;
}

/**
 * Clear catalog cache (use after regenerating manifests)
 */
export function clearCatalogCache() {
  catalogCache.clear();
}
